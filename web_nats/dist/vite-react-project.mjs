function MM(o, n) {
  for (var s = 0; s < n.length; s++) {
    const l = n[s];
    if (typeof l != "string" && !Array.isArray(l)) {
      for (const d in l)
        if (d !== "default" && !(d in o)) {
          const v = Object.getOwnPropertyDescriptor(l, d);
          v && Object.defineProperty(o, d, v.get ? v : {
            enumerable: !0,
            get: () => l[d]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }));
}
function U1(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var Ly = { exports: {} }, pm = {}, Py = { exports: {} }, Kt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CR;
function jM() {
  if (CR) return Kt;
  CR = 1;
  var o = Symbol.for("react.element"), n = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), l = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), v = Symbol.for("react.provider"), p = Symbol.for("react.context"), E = Symbol.for("react.forward_ref"), _ = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), N = Symbol.for("react.lazy"), O = Symbol.iterator;
  function P(Y) {
    return Y === null || typeof Y != "object" ? null : (Y = O && Y[O] || Y["@@iterator"], typeof Y == "function" ? Y : null);
  }
  var z = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, B = Object.assign, ie = {};
  function K(Y, ue, st) {
    this.props = Y, this.context = ue, this.refs = ie, this.updater = st || z;
  }
  K.prototype.isReactComponent = {}, K.prototype.setState = function(Y, ue) {
    if (typeof Y != "object" && typeof Y != "function" && Y != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, Y, ue, "setState");
  }, K.prototype.forceUpdate = function(Y) {
    this.updater.enqueueForceUpdate(this, Y, "forceUpdate");
  };
  function be() {
  }
  be.prototype = K.prototype;
  function ae(Y, ue, st) {
    this.props = Y, this.context = ue, this.refs = ie, this.updater = st || z;
  }
  var ve = ae.prototype = new be();
  ve.constructor = ae, B(ve, K.prototype), ve.isPureReactComponent = !0;
  var De = Array.isArray, Re = Object.prototype.hasOwnProperty, lt = { current: null }, Ve = { key: !0, ref: !0, __self: !0, __source: !0 };
  function wt(Y, ue, st) {
    var dt, ot = {}, Ot = null, ct = null;
    if (ue != null) for (dt in ue.ref !== void 0 && (ct = ue.ref), ue.key !== void 0 && (Ot = "" + ue.key), ue) Re.call(ue, dt) && !Ve.hasOwnProperty(dt) && (ot[dt] = ue[dt]);
    var ht = arguments.length - 2;
    if (ht === 1) ot.children = st;
    else if (1 < ht) {
      for (var Ae = Array(ht), Lt = 0; Lt < ht; Lt++) Ae[Lt] = arguments[Lt + 2];
      ot.children = Ae;
    }
    if (Y && Y.defaultProps) for (dt in ht = Y.defaultProps, ht) ot[dt] === void 0 && (ot[dt] = ht[dt]);
    return { $$typeof: o, type: Y, key: Ot, ref: ct, props: ot, _owner: lt.current };
  }
  function Rt(Y, ue) {
    return { $$typeof: o, type: Y.type, key: ue, ref: Y.ref, props: Y.props, _owner: Y._owner };
  }
  function zt(Y) {
    return typeof Y == "object" && Y !== null && Y.$$typeof === o;
  }
  function it(Y) {
    var ue = { "=": "=0", ":": "=2" };
    return "$" + Y.replace(/[=:]/g, function(st) {
      return ue[st];
    });
  }
  var Bt = /\/+/g;
  function Ke(Y, ue) {
    return typeof Y == "object" && Y !== null && Y.key != null ? it("" + Y.key) : ue.toString(36);
  }
  function Jt(Y, ue, st, dt, ot) {
    var Ot = typeof Y;
    (Ot === "undefined" || Ot === "boolean") && (Y = null);
    var ct = !1;
    if (Y === null) ct = !0;
    else switch (Ot) {
      case "string":
      case "number":
        ct = !0;
        break;
      case "object":
        switch (Y.$$typeof) {
          case o:
          case n:
            ct = !0;
        }
    }
    if (ct) return ct = Y, ot = ot(ct), Y = dt === "" ? "." + Ke(ct, 0) : dt, De(ot) ? (st = "", Y != null && (st = Y.replace(Bt, "$&/") + "/"), Jt(ot, ue, st, "", function(Lt) {
      return Lt;
    })) : ot != null && (zt(ot) && (ot = Rt(ot, st + (!ot.key || ct && ct.key === ot.key ? "" : ("" + ot.key).replace(Bt, "$&/") + "/") + Y)), ue.push(ot)), 1;
    if (ct = 0, dt = dt === "" ? "." : dt + ":", De(Y)) for (var ht = 0; ht < Y.length; ht++) {
      Ot = Y[ht];
      var Ae = dt + Ke(Ot, ht);
      ct += Jt(Ot, ue, st, Ae, ot);
    }
    else if (Ae = P(Y), typeof Ae == "function") for (Y = Ae.call(Y), ht = 0; !(Ot = Y.next()).done; ) Ot = Ot.value, Ae = dt + Ke(Ot, ht++), ct += Jt(Ot, ue, st, Ae, ot);
    else if (Ot === "object") throw ue = String(Y), Error("Objects are not valid as a React child (found: " + (ue === "[object Object]" ? "object with keys {" + Object.keys(Y).join(", ") + "}" : ue) + "). If you meant to render a collection of children, use an array instead.");
    return ct;
  }
  function jt(Y, ue, st) {
    if (Y == null) return Y;
    var dt = [], ot = 0;
    return Jt(Y, dt, "", "", function(Ot) {
      return ue.call(st, Ot, ot++);
    }), dt;
  }
  function Ht(Y) {
    if (Y._status === -1) {
      var ue = Y._result;
      ue = ue(), ue.then(function(st) {
        (Y._status === 0 || Y._status === -1) && (Y._status = 1, Y._result = st);
      }, function(st) {
        (Y._status === 0 || Y._status === -1) && (Y._status = 2, Y._result = st);
      }), Y._status === -1 && (Y._status = 0, Y._result = ue);
    }
    if (Y._status === 1) return Y._result.default;
    throw Y._result;
  }
  var Ye = { current: null }, Ce = { transition: null }, Ze = { ReactCurrentDispatcher: Ye, ReactCurrentBatchConfig: Ce, ReactCurrentOwner: lt };
  function ke() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Kt.Children = { map: jt, forEach: function(Y, ue, st) {
    jt(Y, function() {
      ue.apply(this, arguments);
    }, st);
  }, count: function(Y) {
    var ue = 0;
    return jt(Y, function() {
      ue++;
    }), ue;
  }, toArray: function(Y) {
    return jt(Y, function(ue) {
      return ue;
    }) || [];
  }, only: function(Y) {
    if (!zt(Y)) throw Error("React.Children.only expected to receive a single React element child.");
    return Y;
  } }, Kt.Component = K, Kt.Fragment = s, Kt.Profiler = d, Kt.PureComponent = ae, Kt.StrictMode = l, Kt.Suspense = _, Kt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ze, Kt.act = ke, Kt.cloneElement = function(Y, ue, st) {
    if (Y == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + Y + ".");
    var dt = B({}, Y.props), ot = Y.key, Ot = Y.ref, ct = Y._owner;
    if (ue != null) {
      if (ue.ref !== void 0 && (Ot = ue.ref, ct = lt.current), ue.key !== void 0 && (ot = "" + ue.key), Y.type && Y.type.defaultProps) var ht = Y.type.defaultProps;
      for (Ae in ue) Re.call(ue, Ae) && !Ve.hasOwnProperty(Ae) && (dt[Ae] = ue[Ae] === void 0 && ht !== void 0 ? ht[Ae] : ue[Ae]);
    }
    var Ae = arguments.length - 2;
    if (Ae === 1) dt.children = st;
    else if (1 < Ae) {
      ht = Array(Ae);
      for (var Lt = 0; Lt < Ae; Lt++) ht[Lt] = arguments[Lt + 2];
      dt.children = ht;
    }
    return { $$typeof: o, type: Y.type, key: ot, ref: Ot, props: dt, _owner: ct };
  }, Kt.createContext = function(Y) {
    return Y = { $$typeof: p, _currentValue: Y, _currentValue2: Y, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, Y.Provider = { $$typeof: v, _context: Y }, Y.Consumer = Y;
  }, Kt.createElement = wt, Kt.createFactory = function(Y) {
    var ue = wt.bind(null, Y);
    return ue.type = Y, ue;
  }, Kt.createRef = function() {
    return { current: null };
  }, Kt.forwardRef = function(Y) {
    return { $$typeof: E, render: Y };
  }, Kt.isValidElement = zt, Kt.lazy = function(Y) {
    return { $$typeof: N, _payload: { _status: -1, _result: Y }, _init: Ht };
  }, Kt.memo = function(Y, ue) {
    return { $$typeof: x, type: Y, compare: ue === void 0 ? null : ue };
  }, Kt.startTransition = function(Y) {
    var ue = Ce.transition;
    Ce.transition = {};
    try {
      Y();
    } finally {
      Ce.transition = ue;
    }
  }, Kt.unstable_act = ke, Kt.useCallback = function(Y, ue) {
    return Ye.current.useCallback(Y, ue);
  }, Kt.useContext = function(Y) {
    return Ye.current.useContext(Y);
  }, Kt.useDebugValue = function() {
  }, Kt.useDeferredValue = function(Y) {
    return Ye.current.useDeferredValue(Y);
  }, Kt.useEffect = function(Y, ue) {
    return Ye.current.useEffect(Y, ue);
  }, Kt.useId = function() {
    return Ye.current.useId();
  }, Kt.useImperativeHandle = function(Y, ue, st) {
    return Ye.current.useImperativeHandle(Y, ue, st);
  }, Kt.useInsertionEffect = function(Y, ue) {
    return Ye.current.useInsertionEffect(Y, ue);
  }, Kt.useLayoutEffect = function(Y, ue) {
    return Ye.current.useLayoutEffect(Y, ue);
  }, Kt.useMemo = function(Y, ue) {
    return Ye.current.useMemo(Y, ue);
  }, Kt.useReducer = function(Y, ue, st) {
    return Ye.current.useReducer(Y, ue, st);
  }, Kt.useRef = function(Y) {
    return Ye.current.useRef(Y);
  }, Kt.useState = function(Y) {
    return Ye.current.useState(Y);
  }, Kt.useSyncExternalStore = function(Y, ue, st) {
    return Ye.current.useSyncExternalStore(Y, ue, st);
  }, Kt.useTransition = function() {
    return Ye.current.useTransition();
  }, Kt.version = "18.3.1", Kt;
}
var bm = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
bm.exports;
var RR;
function LM() {
  return RR || (RR = 1, function(o, n) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var s = "18.3.1", l = Symbol.for("react.element"), d = Symbol.for("react.portal"), v = Symbol.for("react.fragment"), p = Symbol.for("react.strict_mode"), E = Symbol.for("react.profiler"), _ = Symbol.for("react.provider"), x = Symbol.for("react.context"), N = Symbol.for("react.forward_ref"), O = Symbol.for("react.suspense"), P = Symbol.for("react.suspense_list"), z = Symbol.for("react.memo"), B = Symbol.for("react.lazy"), ie = Symbol.for("react.offscreen"), K = Symbol.iterator, be = "@@iterator";
      function ae(C) {
        if (C === null || typeof C != "object")
          return null;
        var F = K && C[K] || C[be];
        return typeof F == "function" ? F : null;
      }
      var ve = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, De = {
        transition: null
      }, Re = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, lt = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, Ve = {}, wt = null;
      function Rt(C) {
        wt = C;
      }
      Ve.setExtraStackFrame = function(C) {
        wt = C;
      }, Ve.getCurrentStack = null, Ve.getStackAddendum = function() {
        var C = "";
        wt && (C += wt);
        var F = Ve.getCurrentStack;
        return F && (C += F() || ""), C;
      };
      var zt = !1, it = !1, Bt = !1, Ke = !1, Jt = !1, jt = {
        ReactCurrentDispatcher: ve,
        ReactCurrentBatchConfig: De,
        ReactCurrentOwner: lt
      };
      jt.ReactDebugCurrentFrame = Ve, jt.ReactCurrentActQueue = Re;
      function Ht(C) {
        {
          for (var F = arguments.length, te = new Array(F > 1 ? F - 1 : 0), oe = 1; oe < F; oe++)
            te[oe - 1] = arguments[oe];
          Ce("warn", C, te);
        }
      }
      function Ye(C) {
        {
          for (var F = arguments.length, te = new Array(F > 1 ? F - 1 : 0), oe = 1; oe < F; oe++)
            te[oe - 1] = arguments[oe];
          Ce("error", C, te);
        }
      }
      function Ce(C, F, te) {
        {
          var oe = jt.ReactDebugCurrentFrame, Te = oe.getStackAddendum();
          Te !== "" && (F += "%s", te = te.concat([Te]));
          var gt = te.map(function(Pe) {
            return String(Pe);
          });
          gt.unshift("Warning: " + F), Function.prototype.apply.call(console[C], console, gt);
        }
      }
      var Ze = {};
      function ke(C, F) {
        {
          var te = C.constructor, oe = te && (te.displayName || te.name) || "ReactClass", Te = oe + "." + F;
          if (Ze[Te])
            return;
          Ye("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", F, oe), Ze[Te] = !0;
        }
      }
      var Y = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(C) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(C, F, te) {
          ke(C, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(C, F, te, oe) {
          ke(C, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(C, F, te, oe) {
          ke(C, "setState");
        }
      }, ue = Object.assign, st = {};
      Object.freeze(st);
      function dt(C, F, te) {
        this.props = C, this.context = F, this.refs = st, this.updater = te || Y;
      }
      dt.prototype.isReactComponent = {}, dt.prototype.setState = function(C, F) {
        if (typeof C != "object" && typeof C != "function" && C != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, C, F, "setState");
      }, dt.prototype.forceUpdate = function(C) {
        this.updater.enqueueForceUpdate(this, C, "forceUpdate");
      };
      {
        var ot = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, Ot = function(C, F) {
          Object.defineProperty(dt.prototype, C, {
            get: function() {
              Ht("%s(...) is deprecated in plain JavaScript React classes. %s", F[0], F[1]);
            }
          });
        };
        for (var ct in ot)
          ot.hasOwnProperty(ct) && Ot(ct, ot[ct]);
      }
      function ht() {
      }
      ht.prototype = dt.prototype;
      function Ae(C, F, te) {
        this.props = C, this.context = F, this.refs = st, this.updater = te || Y;
      }
      var Lt = Ae.prototype = new ht();
      Lt.constructor = Ae, ue(Lt, dt.prototype), Lt.isPureReactComponent = !0;
      function Un() {
        var C = {
          current: null
        };
        return Object.seal(C), C;
      }
      var dr = Array.isArray;
      function wn(C) {
        return dr(C);
      }
      function $n(C) {
        {
          var F = typeof Symbol == "function" && Symbol.toStringTag, te = F && C[Symbol.toStringTag] || C.constructor.name || "Object";
          return te;
        }
      }
      function Fn(C) {
        try {
          return jn(C), !1;
        } catch {
          return !0;
        }
      }
      function jn(C) {
        return "" + C;
      }
      function xr(C) {
        if (Fn(C))
          return Ye("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", $n(C)), jn(C);
      }
      function wi(C, F, te) {
        var oe = C.displayName;
        if (oe)
          return oe;
        var Te = F.displayName || F.name || "";
        return Te !== "" ? te + "(" + Te + ")" : te;
      }
      function Fr(C) {
        return C.displayName || "Context";
      }
      function Kn(C) {
        if (C == null)
          return null;
        if (typeof C.tag == "number" && Ye("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof C == "function")
          return C.displayName || C.name || null;
        if (typeof C == "string")
          return C;
        switch (C) {
          case v:
            return "Fragment";
          case d:
            return "Portal";
          case E:
            return "Profiler";
          case p:
            return "StrictMode";
          case O:
            return "Suspense";
          case P:
            return "SuspenseList";
        }
        if (typeof C == "object")
          switch (C.$$typeof) {
            case x:
              var F = C;
              return Fr(F) + ".Consumer";
            case _:
              var te = C;
              return Fr(te._context) + ".Provider";
            case N:
              return wi(C, C.render, "ForwardRef");
            case z:
              var oe = C.displayName || null;
              return oe !== null ? oe : Kn(C.type) || "Memo";
            case B: {
              var Te = C, gt = Te._payload, Pe = Te._init;
              try {
                return Kn(Pe(gt));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Sn = Object.prototype.hasOwnProperty, Bn = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, qn, We, Tt;
      Tt = {};
      function hr(C) {
        if (Sn.call(C, "ref")) {
          var F = Object.getOwnPropertyDescriptor(C, "ref").get;
          if (F && F.isReactWarning)
            return !1;
        }
        return C.ref !== void 0;
      }
      function ai(C) {
        if (Sn.call(C, "key")) {
          var F = Object.getOwnPropertyDescriptor(C, "key").get;
          if (F && F.isReactWarning)
            return !1;
        }
        return C.key !== void 0;
      }
      function $i(C, F) {
        var te = function() {
          qn || (qn = !0, Ye("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", F));
        };
        te.isReactWarning = !0, Object.defineProperty(C, "key", {
          get: te,
          configurable: !0
        });
      }
      function oa(C, F) {
        var te = function() {
          We || (We = !0, Ye("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", F));
        };
        te.isReactWarning = !0, Object.defineProperty(C, "ref", {
          get: te,
          configurable: !0
        });
      }
      function Me(C) {
        if (typeof C.ref == "string" && lt.current && C.__self && lt.current.stateNode !== C.__self) {
          var F = Kn(lt.current.type);
          Tt[F] || (Ye('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', F, C.ref), Tt[F] = !0);
        }
      }
      var at = function(C, F, te, oe, Te, gt, Pe) {
        var St = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: l,
          // Built-in properties that belong on the element
          type: C,
          key: F,
          ref: te,
          props: Pe,
          // Record the component responsible for creating this element.
          _owner: gt
        };
        return St._store = {}, Object.defineProperty(St._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(St, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: oe
        }), Object.defineProperty(St, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Te
        }), Object.freeze && (Object.freeze(St.props), Object.freeze(St)), St;
      };
      function Pt(C, F, te) {
        var oe, Te = {}, gt = null, Pe = null, St = null, Gt = null;
        if (F != null) {
          hr(F) && (Pe = F.ref, Me(F)), ai(F) && (xr(F.key), gt = "" + F.key), St = F.__self === void 0 ? null : F.__self, Gt = F.__source === void 0 ? null : F.__source;
          for (oe in F)
            Sn.call(F, oe) && !Bn.hasOwnProperty(oe) && (Te[oe] = F[oe]);
        }
        var an = arguments.length - 2;
        if (an === 1)
          Te.children = te;
        else if (an > 1) {
          for (var Ln = Array(an), Tn = 0; Tn < an; Tn++)
            Ln[Tn] = arguments[Tn + 2];
          Object.freeze && Object.freeze(Ln), Te.children = Ln;
        }
        if (C && C.defaultProps) {
          var $t = C.defaultProps;
          for (oe in $t)
            Te[oe] === void 0 && (Te[oe] = $t[oe]);
        }
        if (gt || Pe) {
          var kn = typeof C == "function" ? C.displayName || C.name || "Unknown" : C;
          gt && $i(Te, kn), Pe && oa(Te, kn);
        }
        return at(C, gt, Pe, St, Gt, lt.current, Te);
      }
      function sn(C, F) {
        var te = at(C.type, F, C.ref, C._self, C._source, C._owner, C.props);
        return te;
      }
      function nn(C, F, te) {
        if (C == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + C + ".");
        var oe, Te = ue({}, C.props), gt = C.key, Pe = C.ref, St = C._self, Gt = C._source, an = C._owner;
        if (F != null) {
          hr(F) && (Pe = F.ref, an = lt.current), ai(F) && (xr(F.key), gt = "" + F.key);
          var Ln;
          C.type && C.type.defaultProps && (Ln = C.type.defaultProps);
          for (oe in F)
            Sn.call(F, oe) && !Bn.hasOwnProperty(oe) && (F[oe] === void 0 && Ln !== void 0 ? Te[oe] = Ln[oe] : Te[oe] = F[oe]);
        }
        var Tn = arguments.length - 2;
        if (Tn === 1)
          Te.children = te;
        else if (Tn > 1) {
          for (var $t = Array(Tn), kn = 0; kn < Tn; kn++)
            $t[kn] = arguments[kn + 2];
          Te.children = $t;
        }
        return at(C.type, gt, Pe, St, Gt, an, Te);
      }
      function _n(C) {
        return typeof C == "object" && C !== null && C.$$typeof === l;
      }
      var xn = ".", Xn = ":";
      function gn(C) {
        var F = /[=:]/g, te = {
          "=": "=0",
          ":": "=2"
        }, oe = C.replace(F, function(Te) {
          return te[Te];
        });
        return "$" + oe;
      }
      var on = !1, un = /\/+/g;
      function Dr(C) {
        return C.replace(un, "$&/");
      }
      function pr(C, F) {
        return typeof C == "object" && C !== null && C.key != null ? (xr(C.key), gn("" + C.key)) : F.toString(36);
      }
      function Zr(C, F, te, oe, Te) {
        var gt = typeof C;
        (gt === "undefined" || gt === "boolean") && (C = null);
        var Pe = !1;
        if (C === null)
          Pe = !0;
        else
          switch (gt) {
            case "string":
            case "number":
              Pe = !0;
              break;
            case "object":
              switch (C.$$typeof) {
                case l:
                case d:
                  Pe = !0;
              }
          }
        if (Pe) {
          var St = C, Gt = Te(St), an = oe === "" ? xn + pr(St, 0) : oe;
          if (wn(Gt)) {
            var Ln = "";
            an != null && (Ln = Dr(an) + "/"), Zr(Gt, F, Ln, "", function(dh) {
              return dh;
            });
          } else Gt != null && (_n(Gt) && (Gt.key && (!St || St.key !== Gt.key) && xr(Gt.key), Gt = sn(
            Gt,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            te + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (Gt.key && (!St || St.key !== Gt.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              Dr("" + Gt.key) + "/"
            ) : "") + an
          )), F.push(Gt));
          return 1;
        }
        var Tn, $t, kn = 0, Wn = oe === "" ? xn : oe + Xn;
        if (wn(C))
          for (var co = 0; co < C.length; co++)
            Tn = C[co], $t = Wn + pr(Tn, co), kn += Zr(Tn, F, te, $t, Te);
        else {
          var Vu = ae(C);
          if (typeof Vu == "function") {
            var Os = C;
            Vu === Os.entries && (on || Ht("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), on = !0);
            for (var qu = Vu.call(Os), Jo, fh = 0; !(Jo = qu.next()).done; )
              Tn = Jo.value, $t = Wn + pr(Tn, fh++), kn += Zr(Tn, F, te, $t, Te);
          } else if (gt === "object") {
            var uf = String(C);
            throw new Error("Objects are not valid as a React child (found: " + (uf === "[object Object]" ? "object with keys {" + Object.keys(C).join(", ") + "}" : uf) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return kn;
      }
      function la(C, F, te) {
        if (C == null)
          return C;
        var oe = [], Te = 0;
        return Zr(C, oe, "", "", function(gt) {
          return F.call(te, gt, Te++);
        }), oe;
      }
      function Rs(C) {
        var F = 0;
        return la(C, function() {
          F++;
        }), F;
      }
      function Aa(C, F, te) {
        la(C, function() {
          F.apply(this, arguments);
        }, te);
      }
      function ua(C) {
        return la(C, function(F) {
          return F;
        }) || [];
      }
      function Bi(C) {
        if (!_n(C))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return C;
      }
      function Hi(C) {
        var F = {
          $$typeof: x,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: C,
          _currentValue2: C,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        F.Provider = {
          $$typeof: _,
          _context: F
        };
        var te = !1, oe = !1, Te = !1;
        {
          var gt = {
            $$typeof: x,
            _context: F
          };
          Object.defineProperties(gt, {
            Provider: {
              get: function() {
                return oe || (oe = !0, Ye("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), F.Provider;
              },
              set: function(Pe) {
                F.Provider = Pe;
              }
            },
            _currentValue: {
              get: function() {
                return F._currentValue;
              },
              set: function(Pe) {
                F._currentValue = Pe;
              }
            },
            _currentValue2: {
              get: function() {
                return F._currentValue2;
              },
              set: function(Pe) {
                F._currentValue2 = Pe;
              }
            },
            _threadCount: {
              get: function() {
                return F._threadCount;
              },
              set: function(Pe) {
                F._threadCount = Pe;
              }
            },
            Consumer: {
              get: function() {
                return te || (te = !0, Ye("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), F.Consumer;
              }
            },
            displayName: {
              get: function() {
                return F.displayName;
              },
              set: function(Pe) {
                Te || (Ht("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Pe), Te = !0);
              }
            }
          }), F.Consumer = gt;
        }
        return F._currentRenderer = null, F._currentRenderer2 = null, F;
      }
      var Zn = -1, rr = 0, er = 1, ei = 2;
      function Ir(C) {
        if (C._status === Zn) {
          var F = C._result, te = F();
          if (te.then(function(gt) {
            if (C._status === rr || C._status === Zn) {
              var Pe = C;
              Pe._status = er, Pe._result = gt;
            }
          }, function(gt) {
            if (C._status === rr || C._status === Zn) {
              var Pe = C;
              Pe._status = ei, Pe._result = gt;
            }
          }), C._status === Zn) {
            var oe = C;
            oe._status = rr, oe._result = te;
          }
        }
        if (C._status === er) {
          var Te = C._result;
          return Te === void 0 && Ye(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Te), "default" in Te || Ye(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Te), Te.default;
        } else
          throw C._result;
      }
      function _i(C) {
        var F = {
          // We use these fields to store the result.
          _status: Zn,
          _result: C
        }, te = {
          $$typeof: B,
          _payload: F,
          _init: Ir
        };
        {
          var oe, Te;
          Object.defineProperties(te, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return oe;
              },
              set: function(gt) {
                Ye("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), oe = gt, Object.defineProperty(te, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Te;
              },
              set: function(gt) {
                Ye("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Te = gt, Object.defineProperty(te, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return te;
      }
      function Vi(C) {
        C != null && C.$$typeof === z ? Ye("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof C != "function" ? Ye("forwardRef requires a render function but was given %s.", C === null ? "null" : typeof C) : C.length !== 0 && C.length !== 2 && Ye("forwardRef render functions accept exactly two parameters: props and ref. %s", C.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), C != null && (C.defaultProps != null || C.propTypes != null) && Ye("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var F = {
          $$typeof: N,
          render: C
        };
        {
          var te;
          Object.defineProperty(F, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return te;
            },
            set: function(oe) {
              te = oe, !C.name && !C.displayName && (C.displayName = oe);
            }
          });
        }
        return F;
      }
      var I;
      I = Symbol.for("react.module.reference");
      function ye(C) {
        return !!(typeof C == "string" || typeof C == "function" || C === v || C === E || Jt || C === p || C === O || C === P || Ke || C === ie || zt || it || Bt || typeof C == "object" && C !== null && (C.$$typeof === B || C.$$typeof === z || C.$$typeof === _ || C.$$typeof === x || C.$$typeof === N || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        C.$$typeof === I || C.getModuleId !== void 0));
      }
      function Ne(C, F) {
        ye(C) || Ye("memo: The first argument must be a component. Instead received: %s", C === null ? "null" : typeof C);
        var te = {
          $$typeof: z,
          type: C,
          compare: F === void 0 ? null : F
        };
        {
          var oe;
          Object.defineProperty(te, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return oe;
            },
            set: function(Te) {
              oe = Te, !C.name && !C.displayName && (C.displayName = Te);
            }
          });
        }
        return te;
      }
      function Ue() {
        var C = ve.current;
        return C === null && Ye(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), C;
      }
      function Et(C) {
        var F = Ue();
        if (C._context !== void 0) {
          var te = C._context;
          te.Consumer === C ? Ye("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : te.Provider === C && Ye("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return F.useContext(C);
      }
      function _t(C) {
        var F = Ue();
        return F.useState(C);
      }
      function Ut(C, F, te) {
        var oe = Ue();
        return oe.useReducer(C, F, te);
      }
      function Ft(C) {
        var F = Ue();
        return F.useRef(C);
      }
      function Yn(C, F) {
        var te = Ue();
        return te.useEffect(C, F);
      }
      function Vt(C, F) {
        var te = Ue();
        return te.useInsertionEffect(C, F);
      }
      function Cn(C, F) {
        var te = Ue();
        return te.useLayoutEffect(C, F);
      }
      function T(C, F) {
        var te = Ue();
        return te.useCallback(C, F);
      }
      function j(C, F) {
        var te = Ue();
        return te.useMemo(C, F);
      }
      function A(C, F, te) {
        var oe = Ue();
        return oe.useImperativeHandle(C, F, te);
      }
      function D(C, F) {
        {
          var te = Ue();
          return te.useDebugValue(C, F);
        }
      }
      function U() {
        var C = Ue();
        return C.useTransition();
      }
      function W(C) {
        var F = Ue();
        return F.useDeferredValue(C);
      }
      function he() {
        var C = Ue();
        return C.useId();
      }
      function ge(C, F, te) {
        var oe = Ue();
        return oe.useSyncExternalStore(C, F, te);
      }
      var Z = 0, de, qe, xt, En, Dn, Da, lf;
      function Fl() {
      }
      Fl.__reactDisabledLog = !0;
      function ao() {
        {
          if (Z === 0) {
            de = console.log, qe = console.info, xt = console.warn, En = console.error, Dn = console.group, Da = console.groupCollapsed, lf = console.groupEnd;
            var C = {
              configurable: !0,
              enumerable: !0,
              value: Fl,
              writable: !0
            };
            Object.defineProperties(console, {
              info: C,
              log: C,
              warn: C,
              error: C,
              group: C,
              groupCollapsed: C,
              groupEnd: C
            });
          }
          Z++;
        }
      }
      function qi() {
        {
          if (Z--, Z === 0) {
            var C = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: ue({}, C, {
                value: de
              }),
              info: ue({}, C, {
                value: qe
              }),
              warn: ue({}, C, {
                value: xt
              }),
              error: ue({}, C, {
                value: En
              }),
              group: ue({}, C, {
                value: Dn
              }),
              groupCollapsed: ue({}, C, {
                value: Da
              }),
              groupEnd: ue({}, C, {
                value: lf
              })
            });
          }
          Z < 0 && Ye("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Ma = jt.ReactCurrentDispatcher, ja;
      function Il(C, F, te) {
        {
          if (ja === void 0)
            try {
              throw Error();
            } catch (Te) {
              var oe = Te.stack.trim().match(/\n( *(at )?)/);
              ja = oe && oe[1] || "";
            }
          return `
` + ja + C;
        }
      }
      var qo = !1, so;
      {
        var zl = typeof WeakMap == "function" ? WeakMap : Map;
        so = new zl();
      }
      function $l(C, F) {
        if (!C || qo)
          return "";
        {
          var te = so.get(C);
          if (te !== void 0)
            return te;
        }
        var oe;
        qo = !0;
        var Te = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var gt;
        gt = Ma.current, Ma.current = null, ao();
        try {
          if (F) {
            var Pe = function() {
              throw Error();
            };
            if (Object.defineProperty(Pe.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Pe, []);
              } catch (Wn) {
                oe = Wn;
              }
              Reflect.construct(C, [], Pe);
            } else {
              try {
                Pe.call();
              } catch (Wn) {
                oe = Wn;
              }
              C.call(Pe.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Wn) {
              oe = Wn;
            }
            C();
          }
        } catch (Wn) {
          if (Wn && oe && typeof Wn.stack == "string") {
            for (var St = Wn.stack.split(`
`), Gt = oe.stack.split(`
`), an = St.length - 1, Ln = Gt.length - 1; an >= 1 && Ln >= 0 && St[an] !== Gt[Ln]; )
              Ln--;
            for (; an >= 1 && Ln >= 0; an--, Ln--)
              if (St[an] !== Gt[Ln]) {
                if (an !== 1 || Ln !== 1)
                  do
                    if (an--, Ln--, Ln < 0 || St[an] !== Gt[Ln]) {
                      var Tn = `
` + St[an].replace(" at new ", " at ");
                      return C.displayName && Tn.includes("<anonymous>") && (Tn = Tn.replace("<anonymous>", C.displayName)), typeof C == "function" && so.set(C, Tn), Tn;
                    }
                  while (an >= 1 && Ln >= 0);
                break;
              }
          }
        } finally {
          qo = !1, Ma.current = gt, qi(), Error.prepareStackTrace = Te;
        }
        var $t = C ? C.displayName || C.name : "", kn = $t ? Il($t) : "";
        return typeof C == "function" && so.set(C, kn), kn;
      }
      function Ts(C, F, te) {
        return $l(C, !1);
      }
      function uh(C) {
        var F = C.prototype;
        return !!(F && F.isReactComponent);
      }
      function ks(C, F, te) {
        if (C == null)
          return "";
        if (typeof C == "function")
          return $l(C, uh(C));
        if (typeof C == "string")
          return Il(C);
        switch (C) {
          case O:
            return Il("Suspense");
          case P:
            return Il("SuspenseList");
        }
        if (typeof C == "object")
          switch (C.$$typeof) {
            case N:
              return Ts(C.render);
            case z:
              return ks(C.type, F, te);
            case B: {
              var oe = C, Te = oe._payload, gt = oe._init;
              try {
                return ks(gt(Te), F, te);
              } catch {
              }
            }
          }
        return "";
      }
      var cn = {}, Bl = jt.ReactDebugCurrentFrame;
      function rn(C) {
        if (C) {
          var F = C._owner, te = ks(C.type, C._source, F ? F.type : null);
          Bl.setExtraStackFrame(te);
        } else
          Bl.setExtraStackFrame(null);
      }
      function $u(C, F, te, oe, Te) {
        {
          var gt = Function.call.bind(Sn);
          for (var Pe in C)
            if (gt(C, Pe)) {
              var St = void 0;
              try {
                if (typeof C[Pe] != "function") {
                  var Gt = Error((oe || "React class") + ": " + te + " type `" + Pe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof C[Pe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Gt.name = "Invariant Violation", Gt;
                }
                St = C[Pe](F, Pe, oe, te, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (an) {
                St = an;
              }
              St && !(St instanceof Error) && (rn(Te), Ye("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", te, Pe, typeof St), rn(null)), St instanceof Error && !(St.message in cn) && (cn[St.message] = !0, rn(Te), Ye("Failed %s type: %s", te, St.message), rn(null));
            }
        }
      }
      function Za(C) {
        if (C) {
          var F = C._owner, te = ks(C.type, C._source, F ? F.type : null);
          Rt(te);
        } else
          Rt(null);
      }
      var Nt;
      Nt = !1;
      function Hl() {
        if (lt.current) {
          var C = Kn(lt.current.type);
          if (C)
            return `

Check the render method of \`` + C + "`.";
        }
        return "";
      }
      function zr(C) {
        if (C !== void 0) {
          var F = C.fileName.replace(/^.*[\\\/]/, ""), te = C.lineNumber;
          return `

Check your code at ` + F + ":" + te + ".";
        }
        return "";
      }
      function es(C) {
        return C != null ? zr(C.__source) : "";
      }
      var si = {};
      function ts(C) {
        var F = Hl();
        if (!F) {
          var te = typeof C == "string" ? C : C.displayName || C.name;
          te && (F = `

Check the top-level render call using <` + te + ">.");
        }
        return F;
      }
      function In(C, F) {
        if (!(!C._store || C._store.validated || C.key != null)) {
          C._store.validated = !0;
          var te = ts(F);
          if (!si[te]) {
            si[te] = !0;
            var oe = "";
            C && C._owner && C._owner !== lt.current && (oe = " It was passed a child from " + Kn(C._owner.type) + "."), Za(C), Ye('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', te, oe), Za(null);
          }
        }
      }
      function Rn(C, F) {
        if (typeof C == "object") {
          if (wn(C))
            for (var te = 0; te < C.length; te++) {
              var oe = C[te];
              _n(oe) && In(oe, F);
            }
          else if (_n(C))
            C._store && (C._store.validated = !0);
          else if (C) {
            var Te = ae(C);
            if (typeof Te == "function" && Te !== C.entries)
              for (var gt = Te.call(C), Pe; !(Pe = gt.next()).done; )
                _n(Pe.value) && In(Pe.value, F);
          }
        }
      }
      function oo(C) {
        {
          var F = C.type;
          if (F == null || typeof F == "string")
            return;
          var te;
          if (typeof F == "function")
            te = F.propTypes;
          else if (typeof F == "object" && (F.$$typeof === N || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          F.$$typeof === z))
            te = F.propTypes;
          else
            return;
          if (te) {
            var oe = Kn(F);
            $u(te, C.props, "prop", oe, C);
          } else if (F.PropTypes !== void 0 && !Nt) {
            Nt = !0;
            var Te = Kn(F);
            Ye("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Te || "Unknown");
          }
          typeof F.getDefaultProps == "function" && !F.getDefaultProps.isReactClassApproved && Ye("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Cr(C) {
        {
          for (var F = Object.keys(C.props), te = 0; te < F.length; te++) {
            var oe = F[te];
            if (oe !== "children" && oe !== "key") {
              Za(C), Ye("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), Za(null);
              break;
            }
          }
          C.ref !== null && (Za(C), Ye("Invalid attribute `ref` supplied to `React.Fragment`."), Za(null));
        }
      }
      function oi(C, F, te) {
        var oe = ye(C);
        if (!oe) {
          var Te = "";
          (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (Te += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var gt = es(F);
          gt ? Te += gt : Te += Hl();
          var Pe;
          C === null ? Pe = "null" : wn(C) ? Pe = "array" : C !== void 0 && C.$$typeof === l ? (Pe = "<" + (Kn(C.type) || "Unknown") + " />", Te = " Did you accidentally export a JSX literal instead of a component?") : Pe = typeof C, Ye("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Pe, Te);
        }
        var St = Pt.apply(this, arguments);
        if (St == null)
          return St;
        if (oe)
          for (var Gt = 2; Gt < arguments.length; Gt++)
            Rn(arguments[Gt], C);
        return C === v ? Cr(St) : oo(St), St;
      }
      var ca = !1;
      function Yo(C) {
        var F = oi.bind(null, C);
        return F.type = C, ca || (ca = !0, Ht("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(F, "type", {
          enumerable: !1,
          get: function() {
            return Ht("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: C
            }), C;
          }
        }), F;
      }
      function Bu(C, F, te) {
        for (var oe = nn.apply(this, arguments), Te = 2; Te < arguments.length; Te++)
          Rn(arguments[Te], oe.type);
        return oo(oe), oe;
      }
      function Hu(C, F) {
        var te = De.transition;
        De.transition = {};
        var oe = De.transition;
        De.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          C();
        } finally {
          if (De.transition = te, te === null && oe._updatedFibers) {
            var Te = oe._updatedFibers.size;
            Te > 10 && Ht("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), oe._updatedFibers.clear();
          }
        }
      }
      var lo = !1, Wo = null;
      function ch(C) {
        if (Wo === null)
          try {
            var F = ("require" + Math.random()).slice(0, 7), te = o && o[F];
            Wo = te.call(o, "timers").setImmediate;
          } catch {
            Wo = function(Te) {
              lo === !1 && (lo = !0, typeof MessageChannel > "u" && Ye("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var gt = new MessageChannel();
              gt.port1.onmessage = Te, gt.port2.postMessage(void 0);
            };
          }
        return Wo(C);
      }
      var fa = 0, La = !1;
      function ns(C) {
        {
          var F = fa;
          fa++, Re.current === null && (Re.current = []);
          var te = Re.isBatchingLegacy, oe;
          try {
            if (Re.isBatchingLegacy = !0, oe = C(), !te && Re.didScheduleLegacyUpdate) {
              var Te = Re.current;
              Te !== null && (Re.didScheduleLegacyUpdate = !1, uo(Te));
            }
          } catch ($t) {
            throw da(F), $t;
          } finally {
            Re.isBatchingLegacy = te;
          }
          if (oe !== null && typeof oe == "object" && typeof oe.then == "function") {
            var gt = oe, Pe = !1, St = {
              then: function($t, kn) {
                Pe = !0, gt.then(function(Wn) {
                  da(F), fa === 0 ? Vl(Wn, $t, kn) : $t(Wn);
                }, function(Wn) {
                  da(F), kn(Wn);
                });
              }
            };
            return !La && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Pe || (La = !0, Ye("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), St;
          } else {
            var Gt = oe;
            if (da(F), fa === 0) {
              var an = Re.current;
              an !== null && (uo(an), Re.current = null);
              var Ln = {
                then: function($t, kn) {
                  Re.current === null ? (Re.current = [], Vl(Gt, $t, kn)) : $t(Gt);
                }
              };
              return Ln;
            } else {
              var Tn = {
                then: function($t, kn) {
                  $t(Gt);
                }
              };
              return Tn;
            }
          }
        }
      }
      function da(C) {
        C !== fa - 1 && Ye("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), fa = C;
      }
      function Vl(C, F, te) {
        {
          var oe = Re.current;
          if (oe !== null)
            try {
              uo(oe), ch(function() {
                oe.length === 0 ? (Re.current = null, F(C)) : Vl(C, F, te);
              });
            } catch (Te) {
              te(Te);
            }
          else
            F(C);
        }
      }
      var ql = !1;
      function uo(C) {
        if (!ql) {
          ql = !0;
          var F = 0;
          try {
            for (; F < C.length; F++) {
              var te = C[F];
              do
                te = te(!0);
              while (te !== null);
            }
            C.length = 0;
          } catch (oe) {
            throw C = C.slice(F + 1), oe;
          } finally {
            ql = !1;
          }
        }
      }
      var Go = oi, Yl = Bu, Wl = Yo, Pa = {
        map: la,
        forEach: Aa,
        count: Rs,
        toArray: ua,
        only: Bi
      };
      n.Children = Pa, n.Component = dt, n.Fragment = v, n.Profiler = E, n.PureComponent = Ae, n.StrictMode = p, n.Suspense = O, n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = jt, n.act = ns, n.cloneElement = Yl, n.createContext = Hi, n.createElement = Go, n.createFactory = Wl, n.createRef = Un, n.forwardRef = Vi, n.isValidElement = _n, n.lazy = _i, n.memo = Ne, n.startTransition = Hu, n.unstable_act = ns, n.useCallback = T, n.useContext = Et, n.useDebugValue = D, n.useDeferredValue = W, n.useEffect = Yn, n.useId = he, n.useImperativeHandle = A, n.useInsertionEffect = Vt, n.useLayoutEffect = Cn, n.useMemo = j, n.useReducer = Ut, n.useRef = Ft, n.useState = _t, n.useSyncExternalStore = ge, n.useTransition = U, n.version = s, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(bm, bm.exports)), bm.exports;
}
var TR;
function Um() {
  return TR || (TR = 1, process.env.NODE_ENV === "production" ? Py.exports = jM() : Py.exports = LM()), Py.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kR;
function PM() {
  if (kR) return pm;
  kR = 1;
  var o = Um(), n = Symbol.for("react.element"), s = Symbol.for("react.fragment"), l = Object.prototype.hasOwnProperty, d = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, v = { key: !0, ref: !0, __self: !0, __source: !0 };
  function p(E, _, x) {
    var N, O = {}, P = null, z = null;
    x !== void 0 && (P = "" + x), _.key !== void 0 && (P = "" + _.key), _.ref !== void 0 && (z = _.ref);
    for (N in _) l.call(_, N) && !v.hasOwnProperty(N) && (O[N] = _[N]);
    if (E && E.defaultProps) for (N in _ = E.defaultProps, _) O[N] === void 0 && (O[N] = _[N]);
    return { $$typeof: n, type: E, key: P, ref: z, props: O, _owner: d.current };
  }
  return pm.Fragment = s, pm.jsx = p, pm.jsxs = p, pm;
}
var mm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OR;
function UM() {
  return OR || (OR = 1, process.env.NODE_ENV !== "production" && function() {
    var o = Um(), n = Symbol.for("react.element"), s = Symbol.for("react.portal"), l = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), v = Symbol.for("react.profiler"), p = Symbol.for("react.provider"), E = Symbol.for("react.context"), _ = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), N = Symbol.for("react.suspense_list"), O = Symbol.for("react.memo"), P = Symbol.for("react.lazy"), z = Symbol.for("react.offscreen"), B = Symbol.iterator, ie = "@@iterator";
    function K(I) {
      if (I === null || typeof I != "object")
        return null;
      var ye = B && I[B] || I[ie];
      return typeof ye == "function" ? ye : null;
    }
    var be = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function ae(I) {
      {
        for (var ye = arguments.length, Ne = new Array(ye > 1 ? ye - 1 : 0), Ue = 1; Ue < ye; Ue++)
          Ne[Ue - 1] = arguments[Ue];
        ve("error", I, Ne);
      }
    }
    function ve(I, ye, Ne) {
      {
        var Ue = be.ReactDebugCurrentFrame, Et = Ue.getStackAddendum();
        Et !== "" && (ye += "%s", Ne = Ne.concat([Et]));
        var _t = Ne.map(function(Ut) {
          return String(Ut);
        });
        _t.unshift("Warning: " + ye), Function.prototype.apply.call(console[I], console, _t);
      }
    }
    var De = !1, Re = !1, lt = !1, Ve = !1, wt = !1, Rt;
    Rt = Symbol.for("react.module.reference");
    function zt(I) {
      return !!(typeof I == "string" || typeof I == "function" || I === l || I === v || wt || I === d || I === x || I === N || Ve || I === z || De || Re || lt || typeof I == "object" && I !== null && (I.$$typeof === P || I.$$typeof === O || I.$$typeof === p || I.$$typeof === E || I.$$typeof === _ || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      I.$$typeof === Rt || I.getModuleId !== void 0));
    }
    function it(I, ye, Ne) {
      var Ue = I.displayName;
      if (Ue)
        return Ue;
      var Et = ye.displayName || ye.name || "";
      return Et !== "" ? Ne + "(" + Et + ")" : Ne;
    }
    function Bt(I) {
      return I.displayName || "Context";
    }
    function Ke(I) {
      if (I == null)
        return null;
      if (typeof I.tag == "number" && ae("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof I == "function")
        return I.displayName || I.name || null;
      if (typeof I == "string")
        return I;
      switch (I) {
        case l:
          return "Fragment";
        case s:
          return "Portal";
        case v:
          return "Profiler";
        case d:
          return "StrictMode";
        case x:
          return "Suspense";
        case N:
          return "SuspenseList";
      }
      if (typeof I == "object")
        switch (I.$$typeof) {
          case E:
            var ye = I;
            return Bt(ye) + ".Consumer";
          case p:
            var Ne = I;
            return Bt(Ne._context) + ".Provider";
          case _:
            return it(I, I.render, "ForwardRef");
          case O:
            var Ue = I.displayName || null;
            return Ue !== null ? Ue : Ke(I.type) || "Memo";
          case P: {
            var Et = I, _t = Et._payload, Ut = Et._init;
            try {
              return Ke(Ut(_t));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Jt = Object.assign, jt = 0, Ht, Ye, Ce, Ze, ke, Y, ue;
    function st() {
    }
    st.__reactDisabledLog = !0;
    function dt() {
      {
        if (jt === 0) {
          Ht = console.log, Ye = console.info, Ce = console.warn, Ze = console.error, ke = console.group, Y = console.groupCollapsed, ue = console.groupEnd;
          var I = {
            configurable: !0,
            enumerable: !0,
            value: st,
            writable: !0
          };
          Object.defineProperties(console, {
            info: I,
            log: I,
            warn: I,
            error: I,
            group: I,
            groupCollapsed: I,
            groupEnd: I
          });
        }
        jt++;
      }
    }
    function ot() {
      {
        if (jt--, jt === 0) {
          var I = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Jt({}, I, {
              value: Ht
            }),
            info: Jt({}, I, {
              value: Ye
            }),
            warn: Jt({}, I, {
              value: Ce
            }),
            error: Jt({}, I, {
              value: Ze
            }),
            group: Jt({}, I, {
              value: ke
            }),
            groupCollapsed: Jt({}, I, {
              value: Y
            }),
            groupEnd: Jt({}, I, {
              value: ue
            })
          });
        }
        jt < 0 && ae("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ot = be.ReactCurrentDispatcher, ct;
    function ht(I, ye, Ne) {
      {
        if (ct === void 0)
          try {
            throw Error();
          } catch (Et) {
            var Ue = Et.stack.trim().match(/\n( *(at )?)/);
            ct = Ue && Ue[1] || "";
          }
        return `
` + ct + I;
      }
    }
    var Ae = !1, Lt;
    {
      var Un = typeof WeakMap == "function" ? WeakMap : Map;
      Lt = new Un();
    }
    function dr(I, ye) {
      if (!I || Ae)
        return "";
      {
        var Ne = Lt.get(I);
        if (Ne !== void 0)
          return Ne;
      }
      var Ue;
      Ae = !0;
      var Et = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var _t;
      _t = Ot.current, Ot.current = null, dt();
      try {
        if (ye) {
          var Ut = function() {
            throw Error();
          };
          if (Object.defineProperty(Ut.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ut, []);
            } catch (D) {
              Ue = D;
            }
            Reflect.construct(I, [], Ut);
          } else {
            try {
              Ut.call();
            } catch (D) {
              Ue = D;
            }
            I.call(Ut.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (D) {
            Ue = D;
          }
          I();
        }
      } catch (D) {
        if (D && Ue && typeof D.stack == "string") {
          for (var Ft = D.stack.split(`
`), Yn = Ue.stack.split(`
`), Vt = Ft.length - 1, Cn = Yn.length - 1; Vt >= 1 && Cn >= 0 && Ft[Vt] !== Yn[Cn]; )
            Cn--;
          for (; Vt >= 1 && Cn >= 0; Vt--, Cn--)
            if (Ft[Vt] !== Yn[Cn]) {
              if (Vt !== 1 || Cn !== 1)
                do
                  if (Vt--, Cn--, Cn < 0 || Ft[Vt] !== Yn[Cn]) {
                    var T = `
` + Ft[Vt].replace(" at new ", " at ");
                    return I.displayName && T.includes("<anonymous>") && (T = T.replace("<anonymous>", I.displayName)), typeof I == "function" && Lt.set(I, T), T;
                  }
                while (Vt >= 1 && Cn >= 0);
              break;
            }
        }
      } finally {
        Ae = !1, Ot.current = _t, ot(), Error.prepareStackTrace = Et;
      }
      var j = I ? I.displayName || I.name : "", A = j ? ht(j) : "";
      return typeof I == "function" && Lt.set(I, A), A;
    }
    function wn(I, ye, Ne) {
      return dr(I, !1);
    }
    function $n(I) {
      var ye = I.prototype;
      return !!(ye && ye.isReactComponent);
    }
    function Fn(I, ye, Ne) {
      if (I == null)
        return "";
      if (typeof I == "function")
        return dr(I, $n(I));
      if (typeof I == "string")
        return ht(I);
      switch (I) {
        case x:
          return ht("Suspense");
        case N:
          return ht("SuspenseList");
      }
      if (typeof I == "object")
        switch (I.$$typeof) {
          case _:
            return wn(I.render);
          case O:
            return Fn(I.type, ye, Ne);
          case P: {
            var Ue = I, Et = Ue._payload, _t = Ue._init;
            try {
              return Fn(_t(Et), ye, Ne);
            } catch {
            }
          }
        }
      return "";
    }
    var jn = Object.prototype.hasOwnProperty, xr = {}, wi = be.ReactDebugCurrentFrame;
    function Fr(I) {
      if (I) {
        var ye = I._owner, Ne = Fn(I.type, I._source, ye ? ye.type : null);
        wi.setExtraStackFrame(Ne);
      } else
        wi.setExtraStackFrame(null);
    }
    function Kn(I, ye, Ne, Ue, Et) {
      {
        var _t = Function.call.bind(jn);
        for (var Ut in I)
          if (_t(I, Ut)) {
            var Ft = void 0;
            try {
              if (typeof I[Ut] != "function") {
                var Yn = Error((Ue || "React class") + ": " + Ne + " type `" + Ut + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof I[Ut] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Yn.name = "Invariant Violation", Yn;
              }
              Ft = I[Ut](ye, Ut, Ue, Ne, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Vt) {
              Ft = Vt;
            }
            Ft && !(Ft instanceof Error) && (Fr(Et), ae("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ue || "React class", Ne, Ut, typeof Ft), Fr(null)), Ft instanceof Error && !(Ft.message in xr) && (xr[Ft.message] = !0, Fr(Et), ae("Failed %s type: %s", Ne, Ft.message), Fr(null));
          }
      }
    }
    var Sn = Array.isArray;
    function Bn(I) {
      return Sn(I);
    }
    function qn(I) {
      {
        var ye = typeof Symbol == "function" && Symbol.toStringTag, Ne = ye && I[Symbol.toStringTag] || I.constructor.name || "Object";
        return Ne;
      }
    }
    function We(I) {
      try {
        return Tt(I), !1;
      } catch {
        return !0;
      }
    }
    function Tt(I) {
      return "" + I;
    }
    function hr(I) {
      if (We(I))
        return ae("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qn(I)), Tt(I);
    }
    var ai = be.ReactCurrentOwner, $i = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, oa, Me;
    function at(I) {
      if (jn.call(I, "ref")) {
        var ye = Object.getOwnPropertyDescriptor(I, "ref").get;
        if (ye && ye.isReactWarning)
          return !1;
      }
      return I.ref !== void 0;
    }
    function Pt(I) {
      if (jn.call(I, "key")) {
        var ye = Object.getOwnPropertyDescriptor(I, "key").get;
        if (ye && ye.isReactWarning)
          return !1;
      }
      return I.key !== void 0;
    }
    function sn(I, ye) {
      typeof I.ref == "string" && ai.current;
    }
    function nn(I, ye) {
      {
        var Ne = function() {
          oa || (oa = !0, ae("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ye));
        };
        Ne.isReactWarning = !0, Object.defineProperty(I, "key", {
          get: Ne,
          configurable: !0
        });
      }
    }
    function _n(I, ye) {
      {
        var Ne = function() {
          Me || (Me = !0, ae("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ye));
        };
        Ne.isReactWarning = !0, Object.defineProperty(I, "ref", {
          get: Ne,
          configurable: !0
        });
      }
    }
    var xn = function(I, ye, Ne, Ue, Et, _t, Ut) {
      var Ft = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: I,
        key: ye,
        ref: Ne,
        props: Ut,
        // Record the component responsible for creating this element.
        _owner: _t
      };
      return Ft._store = {}, Object.defineProperty(Ft._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ft, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ue
      }), Object.defineProperty(Ft, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Et
      }), Object.freeze && (Object.freeze(Ft.props), Object.freeze(Ft)), Ft;
    };
    function Xn(I, ye, Ne, Ue, Et) {
      {
        var _t, Ut = {}, Ft = null, Yn = null;
        Ne !== void 0 && (hr(Ne), Ft = "" + Ne), Pt(ye) && (hr(ye.key), Ft = "" + ye.key), at(ye) && (Yn = ye.ref, sn(ye, Et));
        for (_t in ye)
          jn.call(ye, _t) && !$i.hasOwnProperty(_t) && (Ut[_t] = ye[_t]);
        if (I && I.defaultProps) {
          var Vt = I.defaultProps;
          for (_t in Vt)
            Ut[_t] === void 0 && (Ut[_t] = Vt[_t]);
        }
        if (Ft || Yn) {
          var Cn = typeof I == "function" ? I.displayName || I.name || "Unknown" : I;
          Ft && nn(Ut, Cn), Yn && _n(Ut, Cn);
        }
        return xn(I, Ft, Yn, Et, Ue, ai.current, Ut);
      }
    }
    var gn = be.ReactCurrentOwner, on = be.ReactDebugCurrentFrame;
    function un(I) {
      if (I) {
        var ye = I._owner, Ne = Fn(I.type, I._source, ye ? ye.type : null);
        on.setExtraStackFrame(Ne);
      } else
        on.setExtraStackFrame(null);
    }
    var Dr;
    Dr = !1;
    function pr(I) {
      return typeof I == "object" && I !== null && I.$$typeof === n;
    }
    function Zr() {
      {
        if (gn.current) {
          var I = Ke(gn.current.type);
          if (I)
            return `

Check the render method of \`` + I + "`.";
        }
        return "";
      }
    }
    function la(I) {
      return "";
    }
    var Rs = {};
    function Aa(I) {
      {
        var ye = Zr();
        if (!ye) {
          var Ne = typeof I == "string" ? I : I.displayName || I.name;
          Ne && (ye = `

Check the top-level render call using <` + Ne + ">.");
        }
        return ye;
      }
    }
    function ua(I, ye) {
      {
        if (!I._store || I._store.validated || I.key != null)
          return;
        I._store.validated = !0;
        var Ne = Aa(ye);
        if (Rs[Ne])
          return;
        Rs[Ne] = !0;
        var Ue = "";
        I && I._owner && I._owner !== gn.current && (Ue = " It was passed a child from " + Ke(I._owner.type) + "."), un(I), ae('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ne, Ue), un(null);
      }
    }
    function Bi(I, ye) {
      {
        if (typeof I != "object")
          return;
        if (Bn(I))
          for (var Ne = 0; Ne < I.length; Ne++) {
            var Ue = I[Ne];
            pr(Ue) && ua(Ue, ye);
          }
        else if (pr(I))
          I._store && (I._store.validated = !0);
        else if (I) {
          var Et = K(I);
          if (typeof Et == "function" && Et !== I.entries)
            for (var _t = Et.call(I), Ut; !(Ut = _t.next()).done; )
              pr(Ut.value) && ua(Ut.value, ye);
        }
      }
    }
    function Hi(I) {
      {
        var ye = I.type;
        if (ye == null || typeof ye == "string")
          return;
        var Ne;
        if (typeof ye == "function")
          Ne = ye.propTypes;
        else if (typeof ye == "object" && (ye.$$typeof === _ || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ye.$$typeof === O))
          Ne = ye.propTypes;
        else
          return;
        if (Ne) {
          var Ue = Ke(ye);
          Kn(Ne, I.props, "prop", Ue, I);
        } else if (ye.PropTypes !== void 0 && !Dr) {
          Dr = !0;
          var Et = Ke(ye);
          ae("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Et || "Unknown");
        }
        typeof ye.getDefaultProps == "function" && !ye.getDefaultProps.isReactClassApproved && ae("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Zn(I) {
      {
        for (var ye = Object.keys(I.props), Ne = 0; Ne < ye.length; Ne++) {
          var Ue = ye[Ne];
          if (Ue !== "children" && Ue !== "key") {
            un(I), ae("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ue), un(null);
            break;
          }
        }
        I.ref !== null && (un(I), ae("Invalid attribute `ref` supplied to `React.Fragment`."), un(null));
      }
    }
    var rr = {};
    function er(I, ye, Ne, Ue, Et, _t) {
      {
        var Ut = zt(I);
        if (!Ut) {
          var Ft = "";
          (I === void 0 || typeof I == "object" && I !== null && Object.keys(I).length === 0) && (Ft += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Yn = la();
          Yn ? Ft += Yn : Ft += Zr();
          var Vt;
          I === null ? Vt = "null" : Bn(I) ? Vt = "array" : I !== void 0 && I.$$typeof === n ? (Vt = "<" + (Ke(I.type) || "Unknown") + " />", Ft = " Did you accidentally export a JSX literal instead of a component?") : Vt = typeof I, ae("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Vt, Ft);
        }
        var Cn = Xn(I, ye, Ne, Et, _t);
        if (Cn == null)
          return Cn;
        if (Ut) {
          var T = ye.children;
          if (T !== void 0)
            if (Ue)
              if (Bn(T)) {
                for (var j = 0; j < T.length; j++)
                  Bi(T[j], I);
                Object.freeze && Object.freeze(T);
              } else
                ae("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Bi(T, I);
        }
        if (jn.call(ye, "key")) {
          var A = Ke(I), D = Object.keys(ye).filter(function(he) {
            return he !== "key";
          }), U = D.length > 0 ? "{key: someKey, " + D.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!rr[A + U]) {
            var W = D.length > 0 ? "{" + D.join(": ..., ") + ": ...}" : "{}";
            ae(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, U, A, W, A), rr[A + U] = !0;
          }
        }
        return I === l ? Zn(Cn) : Hi(Cn), Cn;
      }
    }
    function ei(I, ye, Ne) {
      return er(I, ye, Ne, !0);
    }
    function Ir(I, ye, Ne) {
      return er(I, ye, Ne, !1);
    }
    var _i = Ir, Vi = ei;
    mm.Fragment = l, mm.jsx = _i, mm.jsxs = Vi;
  }()), mm;
}
var NR;
function FM() {
  return NR || (NR = 1, process.env.NODE_ENV === "production" ? Ly.exports = PM() : Ly.exports = UM()), Ly.exports;
}
var me = FM(), Wd = {}, Uy = { exports: {} }, ka = {}, Fy = { exports: {} }, UE = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var AR;
function IM() {
  return AR || (AR = 1, function(o) {
    function n(Ce, Ze) {
      var ke = Ce.length;
      Ce.push(Ze);
      e: for (; 0 < ke; ) {
        var Y = ke - 1 >>> 1, ue = Ce[Y];
        if (0 < d(ue, Ze)) Ce[Y] = Ze, Ce[ke] = ue, ke = Y;
        else break e;
      }
    }
    function s(Ce) {
      return Ce.length === 0 ? null : Ce[0];
    }
    function l(Ce) {
      if (Ce.length === 0) return null;
      var Ze = Ce[0], ke = Ce.pop();
      if (ke !== Ze) {
        Ce[0] = ke;
        e: for (var Y = 0, ue = Ce.length, st = ue >>> 1; Y < st; ) {
          var dt = 2 * (Y + 1) - 1, ot = Ce[dt], Ot = dt + 1, ct = Ce[Ot];
          if (0 > d(ot, ke)) Ot < ue && 0 > d(ct, ot) ? (Ce[Y] = ct, Ce[Ot] = ke, Y = Ot) : (Ce[Y] = ot, Ce[dt] = ke, Y = dt);
          else if (Ot < ue && 0 > d(ct, ke)) Ce[Y] = ct, Ce[Ot] = ke, Y = Ot;
          else break e;
        }
      }
      return Ze;
    }
    function d(Ce, Ze) {
      var ke = Ce.sortIndex - Ze.sortIndex;
      return ke !== 0 ? ke : Ce.id - Ze.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var v = performance;
      o.unstable_now = function() {
        return v.now();
      };
    } else {
      var p = Date, E = p.now();
      o.unstable_now = function() {
        return p.now() - E;
      };
    }
    var _ = [], x = [], N = 1, O = null, P = 3, z = !1, B = !1, ie = !1, K = typeof setTimeout == "function" ? setTimeout : null, be = typeof clearTimeout == "function" ? clearTimeout : null, ae = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function ve(Ce) {
      for (var Ze = s(x); Ze !== null; ) {
        if (Ze.callback === null) l(x);
        else if (Ze.startTime <= Ce) l(x), Ze.sortIndex = Ze.expirationTime, n(_, Ze);
        else break;
        Ze = s(x);
      }
    }
    function De(Ce) {
      if (ie = !1, ve(Ce), !B) if (s(_) !== null) B = !0, Ht(Re);
      else {
        var Ze = s(x);
        Ze !== null && Ye(De, Ze.startTime - Ce);
      }
    }
    function Re(Ce, Ze) {
      B = !1, ie && (ie = !1, be(wt), wt = -1), z = !0;
      var ke = P;
      try {
        for (ve(Ze), O = s(_); O !== null && (!(O.expirationTime > Ze) || Ce && !it()); ) {
          var Y = O.callback;
          if (typeof Y == "function") {
            O.callback = null, P = O.priorityLevel;
            var ue = Y(O.expirationTime <= Ze);
            Ze = o.unstable_now(), typeof ue == "function" ? O.callback = ue : O === s(_) && l(_), ve(Ze);
          } else l(_);
          O = s(_);
        }
        if (O !== null) var st = !0;
        else {
          var dt = s(x);
          dt !== null && Ye(De, dt.startTime - Ze), st = !1;
        }
        return st;
      } finally {
        O = null, P = ke, z = !1;
      }
    }
    var lt = !1, Ve = null, wt = -1, Rt = 5, zt = -1;
    function it() {
      return !(o.unstable_now() - zt < Rt);
    }
    function Bt() {
      if (Ve !== null) {
        var Ce = o.unstable_now();
        zt = Ce;
        var Ze = !0;
        try {
          Ze = Ve(!0, Ce);
        } finally {
          Ze ? Ke() : (lt = !1, Ve = null);
        }
      } else lt = !1;
    }
    var Ke;
    if (typeof ae == "function") Ke = function() {
      ae(Bt);
    };
    else if (typeof MessageChannel < "u") {
      var Jt = new MessageChannel(), jt = Jt.port2;
      Jt.port1.onmessage = Bt, Ke = function() {
        jt.postMessage(null);
      };
    } else Ke = function() {
      K(Bt, 0);
    };
    function Ht(Ce) {
      Ve = Ce, lt || (lt = !0, Ke());
    }
    function Ye(Ce, Ze) {
      wt = K(function() {
        Ce(o.unstable_now());
      }, Ze);
    }
    o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(Ce) {
      Ce.callback = null;
    }, o.unstable_continueExecution = function() {
      B || z || (B = !0, Ht(Re));
    }, o.unstable_forceFrameRate = function(Ce) {
      0 > Ce || 125 < Ce ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Rt = 0 < Ce ? Math.floor(1e3 / Ce) : 5;
    }, o.unstable_getCurrentPriorityLevel = function() {
      return P;
    }, o.unstable_getFirstCallbackNode = function() {
      return s(_);
    }, o.unstable_next = function(Ce) {
      switch (P) {
        case 1:
        case 2:
        case 3:
          var Ze = 3;
          break;
        default:
          Ze = P;
      }
      var ke = P;
      P = Ze;
      try {
        return Ce();
      } finally {
        P = ke;
      }
    }, o.unstable_pauseExecution = function() {
    }, o.unstable_requestPaint = function() {
    }, o.unstable_runWithPriority = function(Ce, Ze) {
      switch (Ce) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          Ce = 3;
      }
      var ke = P;
      P = Ce;
      try {
        return Ze();
      } finally {
        P = ke;
      }
    }, o.unstable_scheduleCallback = function(Ce, Ze, ke) {
      var Y = o.unstable_now();
      switch (typeof ke == "object" && ke !== null ? (ke = ke.delay, ke = typeof ke == "number" && 0 < ke ? Y + ke : Y) : ke = Y, Ce) {
        case 1:
          var ue = -1;
          break;
        case 2:
          ue = 250;
          break;
        case 5:
          ue = 1073741823;
          break;
        case 4:
          ue = 1e4;
          break;
        default:
          ue = 5e3;
      }
      return ue = ke + ue, Ce = { id: N++, callback: Ze, priorityLevel: Ce, startTime: ke, expirationTime: ue, sortIndex: -1 }, ke > Y ? (Ce.sortIndex = ke, n(x, Ce), s(_) === null && Ce === s(x) && (ie ? (be(wt), wt = -1) : ie = !0, Ye(De, ke - Y))) : (Ce.sortIndex = ue, n(_, Ce), B || z || (B = !0, Ht(Re))), Ce;
    }, o.unstable_shouldYield = it, o.unstable_wrapCallback = function(Ce) {
      var Ze = P;
      return function() {
        var ke = P;
        P = Ze;
        try {
          return Ce.apply(this, arguments);
        } finally {
          P = ke;
        }
      };
    };
  }(UE)), UE;
}
var FE = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DR;
function zM() {
  return DR || (DR = 1, function(o) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = !1, s = 5;
      function l(Me, at) {
        var Pt = Me.length;
        Me.push(at), p(Me, at, Pt);
      }
      function d(Me) {
        return Me.length === 0 ? null : Me[0];
      }
      function v(Me) {
        if (Me.length === 0)
          return null;
        var at = Me[0], Pt = Me.pop();
        return Pt !== at && (Me[0] = Pt, E(Me, Pt, 0)), at;
      }
      function p(Me, at, Pt) {
        for (var sn = Pt; sn > 0; ) {
          var nn = sn - 1 >>> 1, _n = Me[nn];
          if (_(_n, at) > 0)
            Me[nn] = at, Me[sn] = _n, sn = nn;
          else
            return;
        }
      }
      function E(Me, at, Pt) {
        for (var sn = Pt, nn = Me.length, _n = nn >>> 1; sn < _n; ) {
          var xn = (sn + 1) * 2 - 1, Xn = Me[xn], gn = xn + 1, on = Me[gn];
          if (_(Xn, at) < 0)
            gn < nn && _(on, Xn) < 0 ? (Me[sn] = on, Me[gn] = at, sn = gn) : (Me[sn] = Xn, Me[xn] = at, sn = xn);
          else if (gn < nn && _(on, at) < 0)
            Me[sn] = on, Me[gn] = at, sn = gn;
          else
            return;
        }
      }
      function _(Me, at) {
        var Pt = Me.sortIndex - at.sortIndex;
        return Pt !== 0 ? Pt : Me.id - at.id;
      }
      var x = 1, N = 2, O = 3, P = 4, z = 5;
      function B(Me, at) {
      }
      var ie = typeof performance == "object" && typeof performance.now == "function";
      if (ie) {
        var K = performance;
        o.unstable_now = function() {
          return K.now();
        };
      } else {
        var be = Date, ae = be.now();
        o.unstable_now = function() {
          return be.now() - ae;
        };
      }
      var ve = 1073741823, De = -1, Re = 250, lt = 5e3, Ve = 1e4, wt = ve, Rt = [], zt = [], it = 1, Bt = null, Ke = O, Jt = !1, jt = !1, Ht = !1, Ye = typeof setTimeout == "function" ? setTimeout : null, Ce = typeof clearTimeout == "function" ? clearTimeout : null, Ze = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ke(Me) {
        for (var at = d(zt); at !== null; ) {
          if (at.callback === null)
            v(zt);
          else if (at.startTime <= Me)
            v(zt), at.sortIndex = at.expirationTime, l(Rt, at);
          else
            return;
          at = d(zt);
        }
      }
      function Y(Me) {
        if (Ht = !1, ke(Me), !jt)
          if (d(Rt) !== null)
            jt = !0, Tt(ue);
          else {
            var at = d(zt);
            at !== null && hr(Y, at.startTime - Me);
          }
      }
      function ue(Me, at) {
        jt = !1, Ht && (Ht = !1, ai()), Jt = !0;
        var Pt = Ke;
        try {
          var sn;
          if (!n) return st(Me, at);
        } finally {
          Bt = null, Ke = Pt, Jt = !1;
        }
      }
      function st(Me, at) {
        var Pt = at;
        for (ke(Pt), Bt = d(Rt); Bt !== null && !(Bt.expirationTime > Pt && (!Me || wi())); ) {
          var sn = Bt.callback;
          if (typeof sn == "function") {
            Bt.callback = null, Ke = Bt.priorityLevel;
            var nn = Bt.expirationTime <= Pt, _n = sn(nn);
            Pt = o.unstable_now(), typeof _n == "function" ? Bt.callback = _n : Bt === d(Rt) && v(Rt), ke(Pt);
          } else
            v(Rt);
          Bt = d(Rt);
        }
        if (Bt !== null)
          return !0;
        var xn = d(zt);
        return xn !== null && hr(Y, xn.startTime - Pt), !1;
      }
      function dt(Me, at) {
        switch (Me) {
          case x:
          case N:
          case O:
          case P:
          case z:
            break;
          default:
            Me = O;
        }
        var Pt = Ke;
        Ke = Me;
        try {
          return at();
        } finally {
          Ke = Pt;
        }
      }
      function ot(Me) {
        var at;
        switch (Ke) {
          case x:
          case N:
          case O:
            at = O;
            break;
          default:
            at = Ke;
            break;
        }
        var Pt = Ke;
        Ke = at;
        try {
          return Me();
        } finally {
          Ke = Pt;
        }
      }
      function Ot(Me) {
        var at = Ke;
        return function() {
          var Pt = Ke;
          Ke = at;
          try {
            return Me.apply(this, arguments);
          } finally {
            Ke = Pt;
          }
        };
      }
      function ct(Me, at, Pt) {
        var sn = o.unstable_now(), nn;
        if (typeof Pt == "object" && Pt !== null) {
          var _n = Pt.delay;
          typeof _n == "number" && _n > 0 ? nn = sn + _n : nn = sn;
        } else
          nn = sn;
        var xn;
        switch (Me) {
          case x:
            xn = De;
            break;
          case N:
            xn = Re;
            break;
          case z:
            xn = wt;
            break;
          case P:
            xn = Ve;
            break;
          case O:
          default:
            xn = lt;
            break;
        }
        var Xn = nn + xn, gn = {
          id: it++,
          callback: at,
          priorityLevel: Me,
          startTime: nn,
          expirationTime: Xn,
          sortIndex: -1
        };
        return nn > sn ? (gn.sortIndex = nn, l(zt, gn), d(Rt) === null && gn === d(zt) && (Ht ? ai() : Ht = !0, hr(Y, nn - sn))) : (gn.sortIndex = Xn, l(Rt, gn), !jt && !Jt && (jt = !0, Tt(ue))), gn;
      }
      function ht() {
      }
      function Ae() {
        !jt && !Jt && (jt = !0, Tt(ue));
      }
      function Lt() {
        return d(Rt);
      }
      function Un(Me) {
        Me.callback = null;
      }
      function dr() {
        return Ke;
      }
      var wn = !1, $n = null, Fn = -1, jn = s, xr = -1;
      function wi() {
        var Me = o.unstable_now() - xr;
        return !(Me < jn);
      }
      function Fr() {
      }
      function Kn(Me) {
        if (Me < 0 || Me > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Me > 0 ? jn = Math.floor(1e3 / Me) : jn = s;
      }
      var Sn = function() {
        if ($n !== null) {
          var Me = o.unstable_now();
          xr = Me;
          var at = !0, Pt = !0;
          try {
            Pt = $n(at, Me);
          } finally {
            Pt ? Bn() : (wn = !1, $n = null);
          }
        } else
          wn = !1;
      }, Bn;
      if (typeof Ze == "function")
        Bn = function() {
          Ze(Sn);
        };
      else if (typeof MessageChannel < "u") {
        var qn = new MessageChannel(), We = qn.port2;
        qn.port1.onmessage = Sn, Bn = function() {
          We.postMessage(null);
        };
      } else
        Bn = function() {
          Ye(Sn, 0);
        };
      function Tt(Me) {
        $n = Me, wn || (wn = !0, Bn());
      }
      function hr(Me, at) {
        Fn = Ye(function() {
          Me(o.unstable_now());
        }, at);
      }
      function ai() {
        Ce(Fn), Fn = -1;
      }
      var $i = Fr, oa = null;
      o.unstable_IdlePriority = z, o.unstable_ImmediatePriority = x, o.unstable_LowPriority = P, o.unstable_NormalPriority = O, o.unstable_Profiling = oa, o.unstable_UserBlockingPriority = N, o.unstable_cancelCallback = Un, o.unstable_continueExecution = Ae, o.unstable_forceFrameRate = Kn, o.unstable_getCurrentPriorityLevel = dr, o.unstable_getFirstCallbackNode = Lt, o.unstable_next = ot, o.unstable_pauseExecution = ht, o.unstable_requestPaint = $i, o.unstable_runWithPriority = dt, o.unstable_scheduleCallback = ct, o.unstable_shouldYield = wi, o.unstable_wrapCallback = Ot, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(FE)), FE;
}
var MR;
function F1() {
  return MR || (MR = 1, process.env.NODE_ENV === "production" ? Fy.exports = IM() : Fy.exports = zM()), Fy.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jR;
function $M() {
  if (jR) return ka;
  jR = 1;
  var o = Um(), n = F1();
  function s(r) {
    for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + r, c = 1; c < arguments.length; c++) i += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + r + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var l = /* @__PURE__ */ new Set(), d = {};
  function v(r, i) {
    p(r, i), p(r + "Capture", i);
  }
  function p(r, i) {
    for (d[r] = i, r = 0; r < i.length; r++) l.add(i[r]);
  }
  var E = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), _ = Object.prototype.hasOwnProperty, x = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, N = {}, O = {};
  function P(r) {
    return _.call(O, r) ? !0 : _.call(N, r) ? !1 : x.test(r) ? O[r] = !0 : (N[r] = !0, !1);
  }
  function z(r, i, c, h) {
    if (c !== null && c.type === 0) return !1;
    switch (typeof i) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return h ? !1 : c !== null ? !c.acceptsBooleans : (r = r.toLowerCase().slice(0, 5), r !== "data-" && r !== "aria-");
      default:
        return !1;
    }
  }
  function B(r, i, c, h) {
    if (i === null || typeof i > "u" || z(r, i, c, h)) return !0;
    if (h) return !1;
    if (c !== null) switch (c.type) {
      case 3:
        return !i;
      case 4:
        return i === !1;
      case 5:
        return isNaN(i);
      case 6:
        return isNaN(i) || 1 > i;
    }
    return !1;
  }
  function ie(r, i, c, h, g, b, R) {
    this.acceptsBooleans = i === 2 || i === 3 || i === 4, this.attributeName = h, this.attributeNamespace = g, this.mustUseProperty = c, this.propertyName = r, this.type = i, this.sanitizeURL = b, this.removeEmptyString = R;
  }
  var K = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(r) {
    K[r] = new ie(r, 0, !1, r, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(r) {
    var i = r[0];
    K[i] = new ie(i, 1, !1, r[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(r) {
    K[r] = new ie(r, 2, !1, r.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(r) {
    K[r] = new ie(r, 2, !1, r, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(r) {
    K[r] = new ie(r, 3, !1, r.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(r) {
    K[r] = new ie(r, 3, !0, r, null, !1, !1);
  }), ["capture", "download"].forEach(function(r) {
    K[r] = new ie(r, 4, !1, r, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(r) {
    K[r] = new ie(r, 6, !1, r, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(r) {
    K[r] = new ie(r, 5, !1, r.toLowerCase(), null, !1, !1);
  });
  var be = /[\-:]([a-z])/g;
  function ae(r) {
    return r[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(r) {
    var i = r.replace(
      be,
      ae
    );
    K[i] = new ie(i, 1, !1, r, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(r) {
    var i = r.replace(be, ae);
    K[i] = new ie(i, 1, !1, r, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(r) {
    var i = r.replace(be, ae);
    K[i] = new ie(i, 1, !1, r, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(r) {
    K[r] = new ie(r, 1, !1, r.toLowerCase(), null, !1, !1);
  }), K.xlinkHref = new ie("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(r) {
    K[r] = new ie(r, 1, !1, r.toLowerCase(), null, !0, !0);
  });
  function ve(r, i, c, h) {
    var g = K.hasOwnProperty(i) ? K[i] : null;
    (g !== null ? g.type !== 0 : h || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (B(i, c, g, h) && (c = null), h || g === null ? P(i) && (c === null ? r.removeAttribute(i) : r.setAttribute(i, "" + c)) : g.mustUseProperty ? r[g.propertyName] = c === null ? g.type === 3 ? !1 : "" : c : (i = g.attributeName, h = g.attributeNamespace, c === null ? r.removeAttribute(i) : (g = g.type, c = g === 3 || g === 4 && c === !0 ? "" : "" + c, h ? r.setAttributeNS(h, i, c) : r.setAttribute(i, c))));
  }
  var De = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Re = Symbol.for("react.element"), lt = Symbol.for("react.portal"), Ve = Symbol.for("react.fragment"), wt = Symbol.for("react.strict_mode"), Rt = Symbol.for("react.profiler"), zt = Symbol.for("react.provider"), it = Symbol.for("react.context"), Bt = Symbol.for("react.forward_ref"), Ke = Symbol.for("react.suspense"), Jt = Symbol.for("react.suspense_list"), jt = Symbol.for("react.memo"), Ht = Symbol.for("react.lazy"), Ye = Symbol.for("react.offscreen"), Ce = Symbol.iterator;
  function Ze(r) {
    return r === null || typeof r != "object" ? null : (r = Ce && r[Ce] || r["@@iterator"], typeof r == "function" ? r : null);
  }
  var ke = Object.assign, Y;
  function ue(r) {
    if (Y === void 0) try {
      throw Error();
    } catch (c) {
      var i = c.stack.trim().match(/\n( *(at )?)/);
      Y = i && i[1] || "";
    }
    return `
` + Y + r;
  }
  var st = !1;
  function dt(r, i) {
    if (!r || st) return "";
    st = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (i) if (i = function() {
        throw Error();
      }, Object.defineProperty(i.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(i, []);
        } catch (ne) {
          var h = ne;
        }
        Reflect.construct(r, [], i);
      } else {
        try {
          i.call();
        } catch (ne) {
          h = ne;
        }
        r.call(i.prototype);
      }
      else {
        try {
          throw Error();
        } catch (ne) {
          h = ne;
        }
        r();
      }
    } catch (ne) {
      if (ne && h && typeof ne.stack == "string") {
        for (var g = ne.stack.split(`
`), b = h.stack.split(`
`), R = g.length - 1, L = b.length - 1; 1 <= R && 0 <= L && g[R] !== b[L]; ) L--;
        for (; 1 <= R && 0 <= L; R--, L--) if (g[R] !== b[L]) {
          if (R !== 1 || L !== 1)
            do
              if (R--, L--, 0 > L || g[R] !== b[L]) {
                var $ = `
` + g[R].replace(" at new ", " at ");
                return r.displayName && $.includes("<anonymous>") && ($ = $.replace("<anonymous>", r.displayName)), $;
              }
            while (1 <= R && 0 <= L);
          break;
        }
      }
    } finally {
      st = !1, Error.prepareStackTrace = c;
    }
    return (r = r ? r.displayName || r.name : "") ? ue(r) : "";
  }
  function ot(r) {
    switch (r.tag) {
      case 5:
        return ue(r.type);
      case 16:
        return ue("Lazy");
      case 13:
        return ue("Suspense");
      case 19:
        return ue("SuspenseList");
      case 0:
      case 2:
      case 15:
        return r = dt(r.type, !1), r;
      case 11:
        return r = dt(r.type.render, !1), r;
      case 1:
        return r = dt(r.type, !0), r;
      default:
        return "";
    }
  }
  function Ot(r) {
    if (r == null) return null;
    if (typeof r == "function") return r.displayName || r.name || null;
    if (typeof r == "string") return r;
    switch (r) {
      case Ve:
        return "Fragment";
      case lt:
        return "Portal";
      case Rt:
        return "Profiler";
      case wt:
        return "StrictMode";
      case Ke:
        return "Suspense";
      case Jt:
        return "SuspenseList";
    }
    if (typeof r == "object") switch (r.$$typeof) {
      case it:
        return (r.displayName || "Context") + ".Consumer";
      case zt:
        return (r._context.displayName || "Context") + ".Provider";
      case Bt:
        var i = r.render;
        return r = r.displayName, r || (r = i.displayName || i.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
      case jt:
        return i = r.displayName || null, i !== null ? i : Ot(r.type) || "Memo";
      case Ht:
        i = r._payload, r = r._init;
        try {
          return Ot(r(i));
        } catch {
        }
    }
    return null;
  }
  function ct(r) {
    var i = r.type;
    switch (r.tag) {
      case 24:
        return "Cache";
      case 9:
        return (i.displayName || "Context") + ".Consumer";
      case 10:
        return (i._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return r = i.render, r = r.displayName || r.name || "", i.displayName || (r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return i;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Ot(i);
      case 8:
        return i === wt ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof i == "function") return i.displayName || i.name || null;
        if (typeof i == "string") return i;
    }
    return null;
  }
  function ht(r) {
    switch (typeof r) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return r;
      case "object":
        return r;
      default:
        return "";
    }
  }
  function Ae(r) {
    var i = r.type;
    return (r = r.nodeName) && r.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function Lt(r) {
    var i = Ae(r) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(r.constructor.prototype, i), h = "" + r[i];
    if (!r.hasOwnProperty(i) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var g = c.get, b = c.set;
      return Object.defineProperty(r, i, { configurable: !0, get: function() {
        return g.call(this);
      }, set: function(R) {
        h = "" + R, b.call(this, R);
      } }), Object.defineProperty(r, i, { enumerable: c.enumerable }), { getValue: function() {
        return h;
      }, setValue: function(R) {
        h = "" + R;
      }, stopTracking: function() {
        r._valueTracker = null, delete r[i];
      } };
    }
  }
  function Un(r) {
    r._valueTracker || (r._valueTracker = Lt(r));
  }
  function dr(r) {
    if (!r) return !1;
    var i = r._valueTracker;
    if (!i) return !0;
    var c = i.getValue(), h = "";
    return r && (h = Ae(r) ? r.checked ? "true" : "false" : r.value), r = h, r !== c ? (i.setValue(r), !0) : !1;
  }
  function wn(r) {
    if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u") return null;
    try {
      return r.activeElement || r.body;
    } catch {
      return r.body;
    }
  }
  function $n(r, i) {
    var c = i.checked;
    return ke({}, i, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c ?? r._wrapperState.initialChecked });
  }
  function Fn(r, i) {
    var c = i.defaultValue == null ? "" : i.defaultValue, h = i.checked != null ? i.checked : i.defaultChecked;
    c = ht(i.value != null ? i.value : c), r._wrapperState = { initialChecked: h, initialValue: c, controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null };
  }
  function jn(r, i) {
    i = i.checked, i != null && ve(r, "checked", i, !1);
  }
  function xr(r, i) {
    jn(r, i);
    var c = ht(i.value), h = i.type;
    if (c != null) h === "number" ? (c === 0 && r.value === "" || r.value != c) && (r.value = "" + c) : r.value !== "" + c && (r.value = "" + c);
    else if (h === "submit" || h === "reset") {
      r.removeAttribute("value");
      return;
    }
    i.hasOwnProperty("value") ? Fr(r, i.type, c) : i.hasOwnProperty("defaultValue") && Fr(r, i.type, ht(i.defaultValue)), i.checked == null && i.defaultChecked != null && (r.defaultChecked = !!i.defaultChecked);
  }
  function wi(r, i, c) {
    if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
      var h = i.type;
      if (!(h !== "submit" && h !== "reset" || i.value !== void 0 && i.value !== null)) return;
      i = "" + r._wrapperState.initialValue, c || i === r.value || (r.value = i), r.defaultValue = i;
    }
    c = r.name, c !== "" && (r.name = ""), r.defaultChecked = !!r._wrapperState.initialChecked, c !== "" && (r.name = c);
  }
  function Fr(r, i, c) {
    (i !== "number" || wn(r.ownerDocument) !== r) && (c == null ? r.defaultValue = "" + r._wrapperState.initialValue : r.defaultValue !== "" + c && (r.defaultValue = "" + c));
  }
  var Kn = Array.isArray;
  function Sn(r, i, c, h) {
    if (r = r.options, i) {
      i = {};
      for (var g = 0; g < c.length; g++) i["$" + c[g]] = !0;
      for (c = 0; c < r.length; c++) g = i.hasOwnProperty("$" + r[c].value), r[c].selected !== g && (r[c].selected = g), g && h && (r[c].defaultSelected = !0);
    } else {
      for (c = "" + ht(c), i = null, g = 0; g < r.length; g++) {
        if (r[g].value === c) {
          r[g].selected = !0, h && (r[g].defaultSelected = !0);
          return;
        }
        i !== null || r[g].disabled || (i = r[g]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function Bn(r, i) {
    if (i.dangerouslySetInnerHTML != null) throw Error(s(91));
    return ke({}, i, { value: void 0, defaultValue: void 0, children: "" + r._wrapperState.initialValue });
  }
  function qn(r, i) {
    var c = i.value;
    if (c == null) {
      if (c = i.children, i = i.defaultValue, c != null) {
        if (i != null) throw Error(s(92));
        if (Kn(c)) {
          if (1 < c.length) throw Error(s(93));
          c = c[0];
        }
        i = c;
      }
      i == null && (i = ""), c = i;
    }
    r._wrapperState = { initialValue: ht(c) };
  }
  function We(r, i) {
    var c = ht(i.value), h = ht(i.defaultValue);
    c != null && (c = "" + c, c !== r.value && (r.value = c), i.defaultValue == null && r.defaultValue !== c && (r.defaultValue = c)), h != null && (r.defaultValue = "" + h);
  }
  function Tt(r) {
    var i = r.textContent;
    i === r._wrapperState.initialValue && i !== "" && i !== null && (r.value = i);
  }
  function hr(r) {
    switch (r) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function ai(r, i) {
    return r == null || r === "http://www.w3.org/1999/xhtml" ? hr(i) : r === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : r;
  }
  var $i, oa = function(r) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, c, h, g) {
      MSApp.execUnsafeLocalFunction(function() {
        return r(i, c, h, g);
      });
    } : r;
  }(function(r, i) {
    if (r.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in r) r.innerHTML = i;
    else {
      for ($i = $i || document.createElement("div"), $i.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>", i = $i.firstChild; r.firstChild; ) r.removeChild(r.firstChild);
      for (; i.firstChild; ) r.appendChild(i.firstChild);
    }
  });
  function Me(r, i) {
    if (i) {
      var c = r.firstChild;
      if (c && c === r.lastChild && c.nodeType === 3) {
        c.nodeValue = i;
        return;
      }
    }
    r.textContent = i;
  }
  var at = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Pt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(at).forEach(function(r) {
    Pt.forEach(function(i) {
      i = i + r.charAt(0).toUpperCase() + r.substring(1), at[i] = at[r];
    });
  });
  function sn(r, i, c) {
    return i == null || typeof i == "boolean" || i === "" ? "" : c || typeof i != "number" || i === 0 || at.hasOwnProperty(r) && at[r] ? ("" + i).trim() : i + "px";
  }
  function nn(r, i) {
    r = r.style;
    for (var c in i) if (i.hasOwnProperty(c)) {
      var h = c.indexOf("--") === 0, g = sn(c, i[c], h);
      c === "float" && (c = "cssFloat"), h ? r.setProperty(c, g) : r[c] = g;
    }
  }
  var _n = ke({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function xn(r, i) {
    if (i) {
      if (_n[r] && (i.children != null || i.dangerouslySetInnerHTML != null)) throw Error(s(137, r));
      if (i.dangerouslySetInnerHTML != null) {
        if (i.children != null) throw Error(s(60));
        if (typeof i.dangerouslySetInnerHTML != "object" || !("__html" in i.dangerouslySetInnerHTML)) throw Error(s(61));
      }
      if (i.style != null && typeof i.style != "object") throw Error(s(62));
    }
  }
  function Xn(r, i) {
    if (r.indexOf("-") === -1) return typeof i.is == "string";
    switch (r) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var gn = null;
  function on(r) {
    return r = r.target || r.srcElement || window, r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === 3 ? r.parentNode : r;
  }
  var un = null, Dr = null, pr = null;
  function Zr(r) {
    if (r = pt(r)) {
      if (typeof un != "function") throw Error(s(280));
      var i = r.stateNode;
      i && (i = ir(i), un(r.stateNode, r.type, i));
    }
  }
  function la(r) {
    Dr ? pr ? pr.push(r) : pr = [r] : Dr = r;
  }
  function Rs() {
    if (Dr) {
      var r = Dr, i = pr;
      if (pr = Dr = null, Zr(r), i) for (r = 0; r < i.length; r++) Zr(i[r]);
    }
  }
  function Aa(r, i) {
    return r(i);
  }
  function ua() {
  }
  var Bi = !1;
  function Hi(r, i, c) {
    if (Bi) return r(i, c);
    Bi = !0;
    try {
      return Aa(r, i, c);
    } finally {
      Bi = !1, (Dr !== null || pr !== null) && (ua(), Rs());
    }
  }
  function Zn(r, i) {
    var c = r.stateNode;
    if (c === null) return null;
    var h = ir(c);
    if (h === null) return null;
    c = h[i];
    e: switch (i) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (h = !h.disabled) || (r = r.type, h = !(r === "button" || r === "input" || r === "select" || r === "textarea")), r = !h;
        break e;
      default:
        r = !1;
    }
    if (r) return null;
    if (c && typeof c != "function") throw Error(s(231, i, typeof c));
    return c;
  }
  var rr = !1;
  if (E) try {
    var er = {};
    Object.defineProperty(er, "passive", { get: function() {
      rr = !0;
    } }), window.addEventListener("test", er, er), window.removeEventListener("test", er, er);
  } catch {
    rr = !1;
  }
  function ei(r, i, c, h, g, b, R, L, $) {
    var ne = Array.prototype.slice.call(arguments, 3);
    try {
      i.apply(c, ne);
    } catch (we) {
      this.onError(we);
    }
  }
  var Ir = !1, _i = null, Vi = !1, I = null, ye = { onError: function(r) {
    Ir = !0, _i = r;
  } };
  function Ne(r, i, c, h, g, b, R, L, $) {
    Ir = !1, _i = null, ei.apply(ye, arguments);
  }
  function Ue(r, i, c, h, g, b, R, L, $) {
    if (Ne.apply(this, arguments), Ir) {
      if (Ir) {
        var ne = _i;
        Ir = !1, _i = null;
      } else throw Error(s(198));
      Vi || (Vi = !0, I = ne);
    }
  }
  function Et(r) {
    var i = r, c = r;
    if (r.alternate) for (; i.return; ) i = i.return;
    else {
      r = i;
      do
        i = r, i.flags & 4098 && (c = i.return), r = i.return;
      while (r);
    }
    return i.tag === 3 ? c : null;
  }
  function _t(r) {
    if (r.tag === 13) {
      var i = r.memoizedState;
      if (i === null && (r = r.alternate, r !== null && (i = r.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function Ut(r) {
    if (Et(r) !== r) throw Error(s(188));
  }
  function Ft(r) {
    var i = r.alternate;
    if (!i) {
      if (i = Et(r), i === null) throw Error(s(188));
      return i !== r ? null : r;
    }
    for (var c = r, h = i; ; ) {
      var g = c.return;
      if (g === null) break;
      var b = g.alternate;
      if (b === null) {
        if (h = g.return, h !== null) {
          c = h;
          continue;
        }
        break;
      }
      if (g.child === b.child) {
        for (b = g.child; b; ) {
          if (b === c) return Ut(g), r;
          if (b === h) return Ut(g), i;
          b = b.sibling;
        }
        throw Error(s(188));
      }
      if (c.return !== h.return) c = g, h = b;
      else {
        for (var R = !1, L = g.child; L; ) {
          if (L === c) {
            R = !0, c = g, h = b;
            break;
          }
          if (L === h) {
            R = !0, h = g, c = b;
            break;
          }
          L = L.sibling;
        }
        if (!R) {
          for (L = b.child; L; ) {
            if (L === c) {
              R = !0, c = b, h = g;
              break;
            }
            if (L === h) {
              R = !0, h = b, c = g;
              break;
            }
            L = L.sibling;
          }
          if (!R) throw Error(s(189));
        }
      }
      if (c.alternate !== h) throw Error(s(190));
    }
    if (c.tag !== 3) throw Error(s(188));
    return c.stateNode.current === c ? r : i;
  }
  function Yn(r) {
    return r = Ft(r), r !== null ? Vt(r) : null;
  }
  function Vt(r) {
    if (r.tag === 5 || r.tag === 6) return r;
    for (r = r.child; r !== null; ) {
      var i = Vt(r);
      if (i !== null) return i;
      r = r.sibling;
    }
    return null;
  }
  var Cn = n.unstable_scheduleCallback, T = n.unstable_cancelCallback, j = n.unstable_shouldYield, A = n.unstable_requestPaint, D = n.unstable_now, U = n.unstable_getCurrentPriorityLevel, W = n.unstable_ImmediatePriority, he = n.unstable_UserBlockingPriority, ge = n.unstable_NormalPriority, Z = n.unstable_LowPriority, de = n.unstable_IdlePriority, qe = null, xt = null;
  function En(r) {
    if (xt && typeof xt.onCommitFiberRoot == "function") try {
      xt.onCommitFiberRoot(qe, r, void 0, (r.current.flags & 128) === 128);
    } catch {
    }
  }
  var Dn = Math.clz32 ? Math.clz32 : Fl, Da = Math.log, lf = Math.LN2;
  function Fl(r) {
    return r >>>= 0, r === 0 ? 32 : 31 - (Da(r) / lf | 0) | 0;
  }
  var ao = 64, qi = 4194304;
  function Ma(r) {
    switch (r & -r) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return r & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return r;
    }
  }
  function ja(r, i) {
    var c = r.pendingLanes;
    if (c === 0) return 0;
    var h = 0, g = r.suspendedLanes, b = r.pingedLanes, R = c & 268435455;
    if (R !== 0) {
      var L = R & ~g;
      L !== 0 ? h = Ma(L) : (b &= R, b !== 0 && (h = Ma(b)));
    } else R = c & ~g, R !== 0 ? h = Ma(R) : b !== 0 && (h = Ma(b));
    if (h === 0) return 0;
    if (i !== 0 && i !== h && !(i & g) && (g = h & -h, b = i & -i, g >= b || g === 16 && (b & 4194240) !== 0)) return i;
    if (h & 4 && (h |= c & 16), i = r.entangledLanes, i !== 0) for (r = r.entanglements, i &= h; 0 < i; ) c = 31 - Dn(i), g = 1 << c, h |= r[c], i &= ~g;
    return h;
  }
  function Il(r, i) {
    switch (r) {
      case 1:
      case 2:
      case 4:
        return i + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function qo(r, i) {
    for (var c = r.suspendedLanes, h = r.pingedLanes, g = r.expirationTimes, b = r.pendingLanes; 0 < b; ) {
      var R = 31 - Dn(b), L = 1 << R, $ = g[R];
      $ === -1 ? (!(L & c) || L & h) && (g[R] = Il(L, i)) : $ <= i && (r.expiredLanes |= L), b &= ~L;
    }
  }
  function so(r) {
    return r = r.pendingLanes & -1073741825, r !== 0 ? r : r & 1073741824 ? 1073741824 : 0;
  }
  function zl() {
    var r = ao;
    return ao <<= 1, !(ao & 4194240) && (ao = 64), r;
  }
  function $l(r) {
    for (var i = [], c = 0; 31 > c; c++) i.push(r);
    return i;
  }
  function Ts(r, i, c) {
    r.pendingLanes |= i, i !== 536870912 && (r.suspendedLanes = 0, r.pingedLanes = 0), r = r.eventTimes, i = 31 - Dn(i), r[i] = c;
  }
  function uh(r, i) {
    var c = r.pendingLanes & ~i;
    r.pendingLanes = i, r.suspendedLanes = 0, r.pingedLanes = 0, r.expiredLanes &= i, r.mutableReadLanes &= i, r.entangledLanes &= i, i = r.entanglements;
    var h = r.eventTimes;
    for (r = r.expirationTimes; 0 < c; ) {
      var g = 31 - Dn(c), b = 1 << g;
      i[g] = 0, h[g] = -1, r[g] = -1, c &= ~b;
    }
  }
  function ks(r, i) {
    var c = r.entangledLanes |= i;
    for (r = r.entanglements; c; ) {
      var h = 31 - Dn(c), g = 1 << h;
      g & i | r[h] & i && (r[h] |= i), c &= ~g;
    }
  }
  var cn = 0;
  function Bl(r) {
    return r &= -r, 1 < r ? 4 < r ? r & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var rn, $u, Za, Nt, Hl, zr = !1, es = [], si = null, ts = null, In = null, Rn = /* @__PURE__ */ new Map(), oo = /* @__PURE__ */ new Map(), Cr = [], oi = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function ca(r, i) {
    switch (r) {
      case "focusin":
      case "focusout":
        si = null;
        break;
      case "dragenter":
      case "dragleave":
        ts = null;
        break;
      case "mouseover":
      case "mouseout":
        In = null;
        break;
      case "pointerover":
      case "pointerout":
        Rn.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        oo.delete(i.pointerId);
    }
  }
  function Yo(r, i, c, h, g, b) {
    return r === null || r.nativeEvent !== b ? (r = { blockedOn: i, domEventName: c, eventSystemFlags: h, nativeEvent: b, targetContainers: [g] }, i !== null && (i = pt(i), i !== null && $u(i)), r) : (r.eventSystemFlags |= h, i = r.targetContainers, g !== null && i.indexOf(g) === -1 && i.push(g), r);
  }
  function Bu(r, i, c, h, g) {
    switch (i) {
      case "focusin":
        return si = Yo(si, r, i, c, h, g), !0;
      case "dragenter":
        return ts = Yo(ts, r, i, c, h, g), !0;
      case "mouseover":
        return In = Yo(In, r, i, c, h, g), !0;
      case "pointerover":
        var b = g.pointerId;
        return Rn.set(b, Yo(Rn.get(b) || null, r, i, c, h, g)), !0;
      case "gotpointercapture":
        return b = g.pointerId, oo.set(b, Yo(oo.get(b) || null, r, i, c, h, g)), !0;
    }
    return !1;
  }
  function Hu(r) {
    var i = tl(r.target);
    if (i !== null) {
      var c = Et(i);
      if (c !== null) {
        if (i = c.tag, i === 13) {
          if (i = _t(c), i !== null) {
            r.blockedOn = i, Hl(r.priority, function() {
              Za(c);
            });
            return;
          }
        } else if (i === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          r.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    r.blockedOn = null;
  }
  function lo(r) {
    if (r.blockedOn !== null) return !1;
    for (var i = r.targetContainers; 0 < i.length; ) {
      var c = Yl(r.domEventName, r.eventSystemFlags, i[0], r.nativeEvent);
      if (c === null) {
        c = r.nativeEvent;
        var h = new c.constructor(c.type, c);
        gn = h, c.target.dispatchEvent(h), gn = null;
      } else return i = pt(c), i !== null && $u(i), r.blockedOn = c, !1;
      i.shift();
    }
    return !0;
  }
  function Wo(r, i, c) {
    lo(r) && c.delete(i);
  }
  function ch() {
    zr = !1, si !== null && lo(si) && (si = null), ts !== null && lo(ts) && (ts = null), In !== null && lo(In) && (In = null), Rn.forEach(Wo), oo.forEach(Wo);
  }
  function fa(r, i) {
    r.blockedOn === i && (r.blockedOn = null, zr || (zr = !0, n.unstable_scheduleCallback(n.unstable_NormalPriority, ch)));
  }
  function La(r) {
    function i(g) {
      return fa(g, r);
    }
    if (0 < es.length) {
      fa(es[0], r);
      for (var c = 1; c < es.length; c++) {
        var h = es[c];
        h.blockedOn === r && (h.blockedOn = null);
      }
    }
    for (si !== null && fa(si, r), ts !== null && fa(ts, r), In !== null && fa(In, r), Rn.forEach(i), oo.forEach(i), c = 0; c < Cr.length; c++) h = Cr[c], h.blockedOn === r && (h.blockedOn = null);
    for (; 0 < Cr.length && (c = Cr[0], c.blockedOn === null); ) Hu(c), c.blockedOn === null && Cr.shift();
  }
  var ns = De.ReactCurrentBatchConfig, da = !0;
  function Vl(r, i, c, h) {
    var g = cn, b = ns.transition;
    ns.transition = null;
    try {
      cn = 1, uo(r, i, c, h);
    } finally {
      cn = g, ns.transition = b;
    }
  }
  function ql(r, i, c, h) {
    var g = cn, b = ns.transition;
    ns.transition = null;
    try {
      cn = 4, uo(r, i, c, h);
    } finally {
      cn = g, ns.transition = b;
    }
  }
  function uo(r, i, c, h) {
    if (da) {
      var g = Yl(r, i, c, h);
      if (g === null) Sf(r, i, h, Go, c), ca(r, h);
      else if (Bu(g, r, i, c, h)) h.stopPropagation();
      else if (ca(r, h), i & 4 && -1 < oi.indexOf(r)) {
        for (; g !== null; ) {
          var b = pt(g);
          if (b !== null && rn(b), b = Yl(r, i, c, h), b === null && Sf(r, i, h, Go, c), b === g) break;
          g = b;
        }
        g !== null && h.stopPropagation();
      } else Sf(r, i, h, null, c);
    }
  }
  var Go = null;
  function Yl(r, i, c, h) {
    if (Go = null, r = on(h), r = tl(r), r !== null) if (i = Et(r), i === null) r = null;
    else if (c = i.tag, c === 13) {
      if (r = _t(i), r !== null) return r;
      r = null;
    } else if (c === 3) {
      if (i.stateNode.current.memoizedState.isDehydrated) return i.tag === 3 ? i.stateNode.containerInfo : null;
      r = null;
    } else i !== r && (r = null);
    return Go = r, null;
  }
  function Wl(r) {
    switch (r) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (U()) {
          case W:
            return 1;
          case he:
            return 4;
          case ge:
          case Z:
            return 16;
          case de:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Pa = null, C = null, F = null;
  function te() {
    if (F) return F;
    var r, i = C, c = i.length, h, g = "value" in Pa ? Pa.value : Pa.textContent, b = g.length;
    for (r = 0; r < c && i[r] === g[r]; r++) ;
    var R = c - r;
    for (h = 1; h <= R && i[c - h] === g[b - h]; h++) ;
    return F = g.slice(r, 1 < h ? 1 - h : void 0);
  }
  function oe(r) {
    var i = r.keyCode;
    return "charCode" in r ? (r = r.charCode, r === 0 && i === 13 && (r = 13)) : r = i, r === 10 && (r = 13), 32 <= r || r === 13 ? r : 0;
  }
  function Te() {
    return !0;
  }
  function gt() {
    return !1;
  }
  function Pe(r) {
    function i(c, h, g, b, R) {
      this._reactName = c, this._targetInst = g, this.type = h, this.nativeEvent = b, this.target = R, this.currentTarget = null;
      for (var L in r) r.hasOwnProperty(L) && (c = r[L], this[L] = c ? c(b) : b[L]);
      return this.isDefaultPrevented = (b.defaultPrevented != null ? b.defaultPrevented : b.returnValue === !1) ? Te : gt, this.isPropagationStopped = gt, this;
    }
    return ke(i.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var c = this.nativeEvent;
      c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = Te);
    }, stopPropagation: function() {
      var c = this.nativeEvent;
      c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = Te);
    }, persist: function() {
    }, isPersistent: Te }), i;
  }
  var St = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(r) {
    return r.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Gt = Pe(St), an = ke({}, St, { view: 0, detail: 0 }), Ln = Pe(an), Tn, $t, kn, Wn = ke({}, an, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: mh, button: 0, buttons: 0, relatedTarget: function(r) {
    return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
  }, movementX: function(r) {
    return "movementX" in r ? r.movementX : (r !== kn && (kn && r.type === "mousemove" ? (Tn = r.screenX - kn.screenX, $t = r.screenY - kn.screenY) : $t = Tn = 0, kn = r), Tn);
  }, movementY: function(r) {
    return "movementY" in r ? r.movementY : $t;
  } }), co = Pe(Wn), Vu = ke({}, Wn, { dataTransfer: 0 }), Os = Pe(Vu), qu = ke({}, an, { relatedTarget: 0 }), Jo = Pe(qu), fh = ke({}, St, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), uf = Pe(fh), dh = ke({}, St, { clipboardData: function(r) {
    return "clipboardData" in r ? r.clipboardData : window.clipboardData;
  } }), Ym = Pe(dh), hh = ke({}, St, { data: 0 }), ph = Pe(hh), Wm = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Gm = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, S0 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ns(r) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(r) : (r = S0[r]) ? !!i[r] : !1;
  }
  function mh() {
    return Ns;
  }
  var vh = ke({}, an, { key: function(r) {
    if (r.key) {
      var i = Wm[r.key] || r.key;
      if (i !== "Unidentified") return i;
    }
    return r.type === "keypress" ? (r = oe(r), r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? Gm[r.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: mh, charCode: function(r) {
    return r.type === "keypress" ? oe(r) : 0;
  }, keyCode: function(r) {
    return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
  }, which: function(r) {
    return r.type === "keypress" ? oe(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
  } }), gh = Pe(vh), yh = ke({}, Wn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Jm = Pe(yh), cf = ke({}, an, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: mh }), Qm = Pe(cf), xi = ke({}, St, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), As = Pe(xi), mr = ke({}, Wn, {
    deltaX: function(r) {
      return "deltaX" in r ? r.deltaX : "wheelDeltaX" in r ? -r.wheelDeltaX : 0;
    },
    deltaY: function(r) {
      return "deltaY" in r ? r.deltaY : "wheelDeltaY" in r ? -r.wheelDeltaY : "wheelDelta" in r ? -r.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Ds = Pe(mr), bh = [9, 13, 27, 32], Gl = E && "CompositionEvent" in window, Yu = null;
  E && "documentMode" in document && (Yu = document.documentMode);
  var Wu = E && "TextEvent" in window && !Yu, Km = E && (!Gl || Yu && 8 < Yu && 11 >= Yu), Xm = " ", ff = !1;
  function Zm(r, i) {
    switch (r) {
      case "keyup":
        return bh.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function ev(r) {
    return r = r.detail, typeof r == "object" && "data" in r ? r.data : null;
  }
  var Jl = !1;
  function tv(r, i) {
    switch (r) {
      case "compositionend":
        return ev(i);
      case "keypress":
        return i.which !== 32 ? null : (ff = !0, Xm);
      case "textInput":
        return r = i.data, r === Xm && ff ? null : r;
      default:
        return null;
    }
  }
  function E0(r, i) {
    if (Jl) return r === "compositionend" || !Gl && Zm(r, i) ? (r = te(), F = C = Pa = null, Jl = !1, r) : null;
    switch (r) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length) return i.char;
          if (i.which) return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return Km && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var w0 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function nv(r) {
    var i = r && r.nodeName && r.nodeName.toLowerCase();
    return i === "input" ? !!w0[r.type] : i === "textarea";
  }
  function Sh(r, i, c, h) {
    la(h), i = Zu(i, "onChange"), 0 < i.length && (c = new Gt("onChange", "change", null, c, h), r.push({ event: c, listeners: i }));
  }
  var rs = null, Qo = null;
  function rv(r) {
    Zo(r, 0);
  }
  function Gu(r) {
    var i = Fa(r);
    if (dr(i)) return r;
  }
  function _0(r, i) {
    if (r === "change") return i;
  }
  var iv = !1;
  if (E) {
    var Eh;
    if (E) {
      var wh = "oninput" in document;
      if (!wh) {
        var av = document.createElement("div");
        av.setAttribute("oninput", "return;"), wh = typeof av.oninput == "function";
      }
      Eh = wh;
    } else Eh = !1;
    iv = Eh && (!document.documentMode || 9 < document.documentMode);
  }
  function sv() {
    rs && (rs.detachEvent("onpropertychange", ov), Qo = rs = null);
  }
  function ov(r) {
    if (r.propertyName === "value" && Gu(Qo)) {
      var i = [];
      Sh(i, Qo, r, on(r)), Hi(rv, i);
    }
  }
  function x0(r, i, c) {
    r === "focusin" ? (sv(), rs = i, Qo = c, rs.attachEvent("onpropertychange", ov)) : r === "focusout" && sv();
  }
  function lv(r) {
    if (r === "selectionchange" || r === "keyup" || r === "keydown") return Gu(Qo);
  }
  function C0(r, i) {
    if (r === "click") return Gu(i);
  }
  function uv(r, i) {
    if (r === "input" || r === "change") return Gu(i);
  }
  function R0(r, i) {
    return r === i && (r !== 0 || 1 / r === 1 / i) || r !== r && i !== i;
  }
  var Ua = typeof Object.is == "function" ? Object.is : R0;
  function Ju(r, i) {
    if (Ua(r, i)) return !0;
    if (typeof r != "object" || r === null || typeof i != "object" || i === null) return !1;
    var c = Object.keys(r), h = Object.keys(i);
    if (c.length !== h.length) return !1;
    for (h = 0; h < c.length; h++) {
      var g = c[h];
      if (!_.call(i, g) || !Ua(r[g], i[g])) return !1;
    }
    return !0;
  }
  function cv(r) {
    for (; r && r.firstChild; ) r = r.firstChild;
    return r;
  }
  function df(r, i) {
    var c = cv(r);
    r = 0;
    for (var h; c; ) {
      if (c.nodeType === 3) {
        if (h = r + c.textContent.length, r <= i && h >= i) return { node: c, offset: i - r };
        r = h;
      }
      e: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break e;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = cv(c);
    }
  }
  function fo(r, i) {
    return r && i ? r === i ? !0 : r && r.nodeType === 3 ? !1 : i && i.nodeType === 3 ? fo(r, i.parentNode) : "contains" in r ? r.contains(i) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function Qu() {
    for (var r = window, i = wn(); i instanceof r.HTMLIFrameElement; ) {
      try {
        var c = typeof i.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) r = i.contentWindow;
      else break;
      i = wn(r.document);
    }
    return i;
  }
  function hf(r) {
    var i = r && r.nodeName && r.nodeName.toLowerCase();
    return i && (i === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || i === "textarea" || r.contentEditable === "true");
  }
  function Ql(r) {
    var i = Qu(), c = r.focusedElem, h = r.selectionRange;
    if (i !== c && c && c.ownerDocument && fo(c.ownerDocument.documentElement, c)) {
      if (h !== null && hf(c)) {
        if (i = h.start, r = h.end, r === void 0 && (r = i), "selectionStart" in c) c.selectionStart = i, c.selectionEnd = Math.min(r, c.value.length);
        else if (r = (i = c.ownerDocument || document) && i.defaultView || window, r.getSelection) {
          r = r.getSelection();
          var g = c.textContent.length, b = Math.min(h.start, g);
          h = h.end === void 0 ? b : Math.min(h.end, g), !r.extend && b > h && (g = h, h = b, b = g), g = df(c, b);
          var R = df(
            c,
            h
          );
          g && R && (r.rangeCount !== 1 || r.anchorNode !== g.node || r.anchorOffset !== g.offset || r.focusNode !== R.node || r.focusOffset !== R.offset) && (i = i.createRange(), i.setStart(g.node, g.offset), r.removeAllRanges(), b > h ? (r.addRange(i), r.extend(R.node, R.offset)) : (i.setEnd(R.node, R.offset), r.addRange(i)));
        }
      }
      for (i = [], r = c; r = r.parentNode; ) r.nodeType === 1 && i.push({ element: r, left: r.scrollLeft, top: r.scrollTop });
      for (typeof c.focus == "function" && c.focus(), c = 0; c < i.length; c++) r = i[c], r.element.scrollLeft = r.left, r.element.scrollTop = r.top;
    }
  }
  var T0 = E && "documentMode" in document && 11 >= document.documentMode, Kl = null, _h = null, Ku = null, xh = !1;
  function Ch(r, i, c) {
    var h = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    xh || Kl == null || Kl !== wn(h) || (h = Kl, "selectionStart" in h && hf(h) ? h = { start: h.selectionStart, end: h.selectionEnd } : (h = (h.ownerDocument && h.ownerDocument.defaultView || window).getSelection(), h = { anchorNode: h.anchorNode, anchorOffset: h.anchorOffset, focusNode: h.focusNode, focusOffset: h.focusOffset }), Ku && Ju(Ku, h) || (Ku = h, h = Zu(_h, "onSelect"), 0 < h.length && (i = new Gt("onSelect", "select", null, i, c), r.push({ event: i, listeners: h }), i.target = Kl)));
  }
  function pf(r, i) {
    var c = {};
    return c[r.toLowerCase()] = i.toLowerCase(), c["Webkit" + r] = "webkit" + i, c["Moz" + r] = "moz" + i, c;
  }
  var Ko = { animationend: pf("Animation", "AnimationEnd"), animationiteration: pf("Animation", "AnimationIteration"), animationstart: pf("Animation", "AnimationStart"), transitionend: pf("Transition", "TransitionEnd") }, $r = {}, Rh = {};
  E && (Rh = document.createElement("div").style, "AnimationEvent" in window || (delete Ko.animationend.animation, delete Ko.animationiteration.animation, delete Ko.animationstart.animation), "TransitionEvent" in window || delete Ko.transitionend.transition);
  function mf(r) {
    if ($r[r]) return $r[r];
    if (!Ko[r]) return r;
    var i = Ko[r], c;
    for (c in i) if (i.hasOwnProperty(c) && c in Rh) return $r[r] = i[c];
    return r;
  }
  var fv = mf("animationend"), dv = mf("animationiteration"), hv = mf("animationstart"), pv = mf("transitionend"), Th = /* @__PURE__ */ new Map(), vf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ha(r, i) {
    Th.set(r, i), v(i, [r]);
  }
  for (var kh = 0; kh < vf.length; kh++) {
    var Xo = vf[kh], k0 = Xo.toLowerCase(), O0 = Xo[0].toUpperCase() + Xo.slice(1);
    ha(k0, "on" + O0);
  }
  ha(fv, "onAnimationEnd"), ha(dv, "onAnimationIteration"), ha(hv, "onAnimationStart"), ha("dblclick", "onDoubleClick"), ha("focusin", "onFocus"), ha("focusout", "onBlur"), ha(pv, "onTransitionEnd"), p("onMouseEnter", ["mouseout", "mouseover"]), p("onMouseLeave", ["mouseout", "mouseover"]), p("onPointerEnter", ["pointerout", "pointerover"]), p("onPointerLeave", ["pointerout", "pointerover"]), v("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), v("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), v("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), v("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), v("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), v("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Xu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Oh = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xu));
  function gf(r, i, c) {
    var h = r.type || "unknown-event";
    r.currentTarget = c, Ue(h, i, void 0, r), r.currentTarget = null;
  }
  function Zo(r, i) {
    i = (i & 4) !== 0;
    for (var c = 0; c < r.length; c++) {
      var h = r[c], g = h.event;
      h = h.listeners;
      e: {
        var b = void 0;
        if (i) for (var R = h.length - 1; 0 <= R; R--) {
          var L = h[R], $ = L.instance, ne = L.currentTarget;
          if (L = L.listener, $ !== b && g.isPropagationStopped()) break e;
          gf(g, L, ne), b = $;
        }
        else for (R = 0; R < h.length; R++) {
          if (L = h[R], $ = L.instance, ne = L.currentTarget, L = L.listener, $ !== b && g.isPropagationStopped()) break e;
          gf(g, L, ne), b = $;
        }
      }
    }
    if (Vi) throw r = I, Vi = !1, I = null, r;
  }
  function yn(r, i) {
    var c = i[nc];
    c === void 0 && (c = i[nc] = /* @__PURE__ */ new Set());
    var h = r + "__bubble";
    c.has(h) || (mv(i, r, 2, !1), c.add(h));
  }
  function yf(r, i, c) {
    var h = 0;
    i && (h |= 4), mv(c, r, h, i);
  }
  var bf = "_reactListening" + Math.random().toString(36).slice(2);
  function Xl(r) {
    if (!r[bf]) {
      r[bf] = !0, l.forEach(function(c) {
        c !== "selectionchange" && (Oh.has(c) || yf(c, !1, r), yf(c, !0, r));
      });
      var i = r.nodeType === 9 ? r : r.ownerDocument;
      i === null || i[bf] || (i[bf] = !0, yf("selectionchange", !1, i));
    }
  }
  function mv(r, i, c, h) {
    switch (Wl(i)) {
      case 1:
        var g = Vl;
        break;
      case 4:
        g = ql;
        break;
      default:
        g = uo;
    }
    c = g.bind(null, i, c, r), g = void 0, !rr || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (g = !0), h ? g !== void 0 ? r.addEventListener(i, c, { capture: !0, passive: g }) : r.addEventListener(i, c, !0) : g !== void 0 ? r.addEventListener(i, c, { passive: g }) : r.addEventListener(i, c, !1);
  }
  function Sf(r, i, c, h, g) {
    var b = h;
    if (!(i & 1) && !(i & 2) && h !== null) e: for (; ; ) {
      if (h === null) return;
      var R = h.tag;
      if (R === 3 || R === 4) {
        var L = h.stateNode.containerInfo;
        if (L === g || L.nodeType === 8 && L.parentNode === g) break;
        if (R === 4) for (R = h.return; R !== null; ) {
          var $ = R.tag;
          if (($ === 3 || $ === 4) && ($ = R.stateNode.containerInfo, $ === g || $.nodeType === 8 && $.parentNode === g)) return;
          R = R.return;
        }
        for (; L !== null; ) {
          if (R = tl(L), R === null) return;
          if ($ = R.tag, $ === 5 || $ === 6) {
            h = b = R;
            continue e;
          }
          L = L.parentNode;
        }
      }
      h = h.return;
    }
    Hi(function() {
      var ne = b, we = on(c), _e = [];
      e: {
        var Ee = Th.get(r);
        if (Ee !== void 0) {
          var Ge = Gt, et = r;
          switch (r) {
            case "keypress":
              if (oe(c) === 0) break e;
            case "keydown":
            case "keyup":
              Ge = gh;
              break;
            case "focusin":
              et = "focus", Ge = Jo;
              break;
            case "focusout":
              et = "blur", Ge = Jo;
              break;
            case "beforeblur":
            case "afterblur":
              Ge = Jo;
              break;
            case "click":
              if (c.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Ge = co;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Ge = Os;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Ge = Qm;
              break;
            case fv:
            case dv:
            case hv:
              Ge = uf;
              break;
            case pv:
              Ge = As;
              break;
            case "scroll":
              Ge = Ln;
              break;
            case "wheel":
              Ge = Ds;
              break;
            case "copy":
            case "cut":
            case "paste":
              Ge = Ym;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Ge = Jm;
          }
          var rt = (i & 4) !== 0, ur = !rt && r === "scroll", G = rt ? Ee !== null ? Ee + "Capture" : null : Ee;
          rt = [];
          for (var V = ne, X; V !== null; ) {
            X = V;
            var Oe = X.stateNode;
            if (X.tag === 5 && Oe !== null && (X = Oe, G !== null && (Oe = Zn(V, G), Oe != null && rt.push(Zl(V, Oe, X)))), ur) break;
            V = V.return;
          }
          0 < rt.length && (Ee = new Ge(Ee, et, null, c, we), _e.push({ event: Ee, listeners: rt }));
        }
      }
      if (!(i & 7)) {
        e: {
          if (Ee = r === "mouseover" || r === "pointerover", Ge = r === "mouseout" || r === "pointerout", Ee && c !== gn && (et = c.relatedTarget || c.fromElement) && (tl(et) || et[Ms])) break e;
          if ((Ge || Ee) && (Ee = we.window === we ? we : (Ee = we.ownerDocument) ? Ee.defaultView || Ee.parentWindow : window, Ge ? (et = c.relatedTarget || c.toElement, Ge = ne, et = et ? tl(et) : null, et !== null && (ur = Et(et), et !== ur || et.tag !== 5 && et.tag !== 6) && (et = null)) : (Ge = null, et = ne), Ge !== et)) {
            if (rt = co, Oe = "onMouseLeave", G = "onMouseEnter", V = "mouse", (r === "pointerout" || r === "pointerover") && (rt = Jm, Oe = "onPointerLeave", G = "onPointerEnter", V = "pointer"), ur = Ge == null ? Ee : Fa(Ge), X = et == null ? Ee : Fa(et), Ee = new rt(Oe, V + "leave", Ge, c, we), Ee.target = ur, Ee.relatedTarget = X, Oe = null, tl(we) === ne && (rt = new rt(G, V + "enter", et, c, we), rt.target = X, rt.relatedTarget = ur, Oe = rt), ur = Oe, Ge && et) t: {
              for (rt = Ge, G = et, V = 0, X = rt; X; X = ho(X)) V++;
              for (X = 0, Oe = G; Oe; Oe = ho(Oe)) X++;
              for (; 0 < V - X; ) rt = ho(rt), V--;
              for (; 0 < X - V; ) G = ho(G), X--;
              for (; V--; ) {
                if (rt === G || G !== null && rt === G.alternate) break t;
                rt = ho(rt), G = ho(G);
              }
              rt = null;
            }
            else rt = null;
            Ge !== null && vv(_e, Ee, Ge, rt, !1), et !== null && ur !== null && vv(_e, ur, et, rt, !0);
          }
        }
        e: {
          if (Ee = ne ? Fa(ne) : window, Ge = Ee.nodeName && Ee.nodeName.toLowerCase(), Ge === "select" || Ge === "input" && Ee.type === "file") var Be = _0;
          else if (nv(Ee)) if (iv) Be = uv;
          else {
            Be = lv;
            var vt = x0;
          }
          else (Ge = Ee.nodeName) && Ge.toLowerCase() === "input" && (Ee.type === "checkbox" || Ee.type === "radio") && (Be = C0);
          if (Be && (Be = Be(r, ne))) {
            Sh(_e, Be, c, we);
            break e;
          }
          vt && vt(r, Ee, ne), r === "focusout" && (vt = Ee._wrapperState) && vt.controlled && Ee.type === "number" && Fr(Ee, "number", Ee.value);
        }
        switch (vt = ne ? Fa(ne) : window, r) {
          case "focusin":
            (nv(vt) || vt.contentEditable === "true") && (Kl = vt, _h = ne, Ku = null);
            break;
          case "focusout":
            Ku = _h = Kl = null;
            break;
          case "mousedown":
            xh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            xh = !1, Ch(_e, c, we);
            break;
          case "selectionchange":
            if (T0) break;
          case "keydown":
          case "keyup":
            Ch(_e, c, we);
        }
        var bt;
        if (Gl) e: {
          switch (r) {
            case "compositionstart":
              var At = "onCompositionStart";
              break e;
            case "compositionend":
              At = "onCompositionEnd";
              break e;
            case "compositionupdate":
              At = "onCompositionUpdate";
              break e;
          }
          At = void 0;
        }
        else Jl ? Zm(r, c) && (At = "onCompositionEnd") : r === "keydown" && c.keyCode === 229 && (At = "onCompositionStart");
        At && (Km && c.locale !== "ko" && (Jl || At !== "onCompositionStart" ? At === "onCompositionEnd" && Jl && (bt = te()) : (Pa = we, C = "value" in Pa ? Pa.value : Pa.textContent, Jl = !0)), vt = Zu(ne, At), 0 < vt.length && (At = new ph(At, r, null, c, we), _e.push({ event: At, listeners: vt }), bt ? At.data = bt : (bt = ev(c), bt !== null && (At.data = bt)))), (bt = Wu ? tv(r, c) : E0(r, c)) && (ne = Zu(ne, "onBeforeInput"), 0 < ne.length && (we = new ph("onBeforeInput", "beforeinput", null, c, we), _e.push({ event: we, listeners: ne }), we.data = bt));
      }
      Zo(_e, i);
    });
  }
  function Zl(r, i, c) {
    return { instance: r, listener: i, currentTarget: c };
  }
  function Zu(r, i) {
    for (var c = i + "Capture", h = []; r !== null; ) {
      var g = r, b = g.stateNode;
      g.tag === 5 && b !== null && (g = b, b = Zn(r, c), b != null && h.unshift(Zl(r, b, g)), b = Zn(r, i), b != null && h.push(Zl(r, b, g))), r = r.return;
    }
    return h;
  }
  function ho(r) {
    if (r === null) return null;
    do
      r = r.return;
    while (r && r.tag !== 5);
    return r || null;
  }
  function vv(r, i, c, h, g) {
    for (var b = i._reactName, R = []; c !== null && c !== h; ) {
      var L = c, $ = L.alternate, ne = L.stateNode;
      if ($ !== null && $ === h) break;
      L.tag === 5 && ne !== null && (L = ne, g ? ($ = Zn(c, b), $ != null && R.unshift(Zl(c, $, L))) : g || ($ = Zn(c, b), $ != null && R.push(Zl(c, $, L)))), c = c.return;
    }
    R.length !== 0 && r.push({ event: i, listeners: R });
  }
  var gv = /\r\n?/g, N0 = /\u0000|\uFFFD/g;
  function yv(r) {
    return (typeof r == "string" ? r : "" + r).replace(gv, `
`).replace(N0, "");
  }
  function Ef(r, i, c) {
    if (i = yv(i), yv(r) !== i && c) throw Error(s(425));
  }
  function po() {
  }
  var ec = null, el = null;
  function wf(r, i) {
    return r === "textarea" || r === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var _f = typeof setTimeout == "function" ? setTimeout : void 0, Nh = typeof clearTimeout == "function" ? clearTimeout : void 0, bv = typeof Promise == "function" ? Promise : void 0, eu = typeof queueMicrotask == "function" ? queueMicrotask : typeof bv < "u" ? function(r) {
    return bv.resolve(null).then(r).catch(xf);
  } : _f;
  function xf(r) {
    setTimeout(function() {
      throw r;
    });
  }
  function tu(r, i) {
    var c = i, h = 0;
    do {
      var g = c.nextSibling;
      if (r.removeChild(c), g && g.nodeType === 8) if (c = g.data, c === "/$") {
        if (h === 0) {
          r.removeChild(g), La(i);
          return;
        }
        h--;
      } else c !== "$" && c !== "$?" && c !== "$!" || h++;
      c = g;
    } while (c);
    La(i);
  }
  function is(r) {
    for (; r != null; r = r.nextSibling) {
      var i = r.nodeType;
      if (i === 1 || i === 3) break;
      if (i === 8) {
        if (i = r.data, i === "$" || i === "$!" || i === "$?") break;
        if (i === "/$") return null;
      }
    }
    return r;
  }
  function Sv(r) {
    r = r.previousSibling;
    for (var i = 0; r; ) {
      if (r.nodeType === 8) {
        var c = r.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (i === 0) return r;
          i--;
        } else c === "/$" && i++;
      }
      r = r.previousSibling;
    }
    return null;
  }
  var mo = Math.random().toString(36).slice(2), as = "__reactFiber$" + mo, tc = "__reactProps$" + mo, Ms = "__reactContainer$" + mo, nc = "__reactEvents$" + mo, nu = "__reactListeners$" + mo, A0 = "__reactHandles$" + mo;
  function tl(r) {
    var i = r[as];
    if (i) return i;
    for (var c = r.parentNode; c; ) {
      if (i = c[Ms] || c[as]) {
        if (c = i.alternate, i.child !== null || c !== null && c.child !== null) for (r = Sv(r); r !== null; ) {
          if (c = r[as]) return c;
          r = Sv(r);
        }
        return i;
      }
      r = c, c = r.parentNode;
    }
    return null;
  }
  function pt(r) {
    return r = r[as] || r[Ms], !r || r.tag !== 5 && r.tag !== 6 && r.tag !== 13 && r.tag !== 3 ? null : r;
  }
  function Fa(r) {
    if (r.tag === 5 || r.tag === 6) return r.stateNode;
    throw Error(s(33));
  }
  function ir(r) {
    return r[tc] || null;
  }
  var Xt = [], pa = -1;
  function Ia(r) {
    return { current: r };
  }
  function Pn(r) {
    0 > pa || (r.current = Xt[pa], Xt[pa] = null, pa--);
  }
  function ft(r, i) {
    pa++, Xt[pa] = r.current, r.current = i;
  }
  var Ci = {}, tr = Ia(Ci), Rr = Ia(!1), Ri = Ci;
  function ma(r, i) {
    var c = r.type.contextTypes;
    if (!c) return Ci;
    var h = r.stateNode;
    if (h && h.__reactInternalMemoizedUnmaskedChildContext === i) return h.__reactInternalMemoizedMaskedChildContext;
    var g = {}, b;
    for (b in c) g[b] = i[b];
    return h && (r = r.stateNode, r.__reactInternalMemoizedUnmaskedChildContext = i, r.__reactInternalMemoizedMaskedChildContext = g), g;
  }
  function vr(r) {
    return r = r.childContextTypes, r != null;
  }
  function ru() {
    Pn(Rr), Pn(tr);
  }
  function Ev(r, i, c) {
    if (tr.current !== Ci) throw Error(s(168));
    ft(tr, i), ft(Rr, c);
  }
  function rc(r, i, c) {
    var h = r.stateNode;
    if (i = i.childContextTypes, typeof h.getChildContext != "function") return c;
    h = h.getChildContext();
    for (var g in h) if (!(g in i)) throw Error(s(108, ct(r) || "Unknown", g));
    return ke({}, c, h);
  }
  function Ti(r) {
    return r = (r = r.stateNode) && r.__reactInternalMemoizedMergedChildContext || Ci, Ri = tr.current, ft(tr, r), ft(Rr, Rr.current), !0;
  }
  function Cf(r, i, c) {
    var h = r.stateNode;
    if (!h) throw Error(s(169));
    c ? (r = rc(r, i, Ri), h.__reactInternalMemoizedMergedChildContext = r, Pn(Rr), Pn(tr), ft(tr, r)) : Pn(Rr), ft(Rr, c);
  }
  var ss = null, iu = !1, js = !1;
  function Rf(r) {
    ss === null ? ss = [r] : ss.push(r);
  }
  function vo(r) {
    iu = !0, Rf(r);
  }
  function os() {
    if (!js && ss !== null) {
      js = !0;
      var r = 0, i = cn;
      try {
        var c = ss;
        for (cn = 1; r < c.length; r++) {
          var h = c[r];
          do
            h = h(!0);
          while (h !== null);
        }
        ss = null, iu = !1;
      } catch (g) {
        throw ss !== null && (ss = ss.slice(r + 1)), Cn(W, os), g;
      } finally {
        cn = i, js = !1;
      }
    }
    return null;
  }
  var go = [], yo = 0, bo = null, Ls = 0, gr = [], va = 0, Yi = null, ls = 1, us = "";
  function nl(r, i) {
    go[yo++] = Ls, go[yo++] = bo, bo = r, Ls = i;
  }
  function wv(r, i, c) {
    gr[va++] = ls, gr[va++] = us, gr[va++] = Yi, Yi = r;
    var h = ls;
    r = us;
    var g = 32 - Dn(h) - 1;
    h &= ~(1 << g), c += 1;
    var b = 32 - Dn(i) + g;
    if (30 < b) {
      var R = g - g % 5;
      b = (h & (1 << R) - 1).toString(32), h >>= R, g -= R, ls = 1 << 32 - Dn(i) + g | c << g | h, us = b + r;
    } else ls = 1 << b | c << g | h, us = r;
  }
  function Tf(r) {
    r.return !== null && (nl(r, 1), wv(r, 1, 0));
  }
  function kf(r) {
    for (; r === bo; ) bo = go[--yo], go[yo] = null, Ls = go[--yo], go[yo] = null;
    for (; r === Yi; ) Yi = gr[--va], gr[va] = null, us = gr[--va], gr[va] = null, ls = gr[--va], gr[va] = null;
  }
  var ki = null, Oi = null, Hn = !1, ga = null;
  function Ah(r, i) {
    var c = wa(5, null, null, 0);
    c.elementType = "DELETED", c.stateNode = i, c.return = r, i = r.deletions, i === null ? (r.deletions = [c], r.flags |= 16) : i.push(c);
  }
  function _v(r, i) {
    switch (r.tag) {
      case 5:
        var c = r.type;
        return i = i.nodeType !== 1 || c.toLowerCase() !== i.nodeName.toLowerCase() ? null : i, i !== null ? (r.stateNode = i, ki = r, Oi = is(i.firstChild), !0) : !1;
      case 6:
        return i = r.pendingProps === "" || i.nodeType !== 3 ? null : i, i !== null ? (r.stateNode = i, ki = r, Oi = null, !0) : !1;
      case 13:
        return i = i.nodeType !== 8 ? null : i, i !== null ? (c = Yi !== null ? { id: ls, overflow: us } : null, r.memoizedState = { dehydrated: i, treeContext: c, retryLane: 1073741824 }, c = wa(18, null, null, 0), c.stateNode = i, c.return = r, r.child = c, ki = r, Oi = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Dh(r) {
    return (r.mode & 1) !== 0 && (r.flags & 128) === 0;
  }
  function Mh(r) {
    if (Hn) {
      var i = Oi;
      if (i) {
        var c = i;
        if (!_v(r, i)) {
          if (Dh(r)) throw Error(s(418));
          i = is(c.nextSibling);
          var h = ki;
          i && _v(r, i) ? Ah(h, c) : (r.flags = r.flags & -4097 | 2, Hn = !1, ki = r);
        }
      } else {
        if (Dh(r)) throw Error(s(418));
        r.flags = r.flags & -4097 | 2, Hn = !1, ki = r;
      }
    }
  }
  function Tr(r) {
    for (r = r.return; r !== null && r.tag !== 5 && r.tag !== 3 && r.tag !== 13; ) r = r.return;
    ki = r;
  }
  function Of(r) {
    if (r !== ki) return !1;
    if (!Hn) return Tr(r), Hn = !0, !1;
    var i;
    if ((i = r.tag !== 3) && !(i = r.tag !== 5) && (i = r.type, i = i !== "head" && i !== "body" && !wf(r.type, r.memoizedProps)), i && (i = Oi)) {
      if (Dh(r)) throw ic(), Error(s(418));
      for (; i; ) Ah(r, i), i = is(i.nextSibling);
    }
    if (Tr(r), r.tag === 13) {
      if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(s(317));
      e: {
        for (r = r.nextSibling, i = 0; r; ) {
          if (r.nodeType === 8) {
            var c = r.data;
            if (c === "/$") {
              if (i === 0) {
                Oi = is(r.nextSibling);
                break e;
              }
              i--;
            } else c !== "$" && c !== "$!" && c !== "$?" || i++;
          }
          r = r.nextSibling;
        }
        Oi = null;
      }
    } else Oi = ki ? is(r.stateNode.nextSibling) : null;
    return !0;
  }
  function ic() {
    for (var r = Oi; r; ) r = is(r.nextSibling);
  }
  function So() {
    Oi = ki = null, Hn = !1;
  }
  function Ps(r) {
    ga === null ? ga = [r] : ga.push(r);
  }
  var D0 = De.ReactCurrentBatchConfig;
  function rl(r, i, c) {
    if (r = c.ref, r !== null && typeof r != "function" && typeof r != "object") {
      if (c._owner) {
        if (c = c._owner, c) {
          if (c.tag !== 1) throw Error(s(309));
          var h = c.stateNode;
        }
        if (!h) throw Error(s(147, r));
        var g = h, b = "" + r;
        return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === b ? i.ref : (i = function(R) {
          var L = g.refs;
          R === null ? delete L[b] : L[b] = R;
        }, i._stringRef = b, i);
      }
      if (typeof r != "string") throw Error(s(284));
      if (!c._owner) throw Error(s(290, r));
    }
    return r;
  }
  function Nf(r, i) {
    throw r = Object.prototype.toString.call(i), Error(s(31, r === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : r));
  }
  function xv(r) {
    var i = r._init;
    return i(r._payload);
  }
  function il(r) {
    function i(G, V) {
      if (r) {
        var X = G.deletions;
        X === null ? (G.deletions = [V], G.flags |= 16) : X.push(V);
      }
    }
    function c(G, V) {
      if (!r) return null;
      for (; V !== null; ) i(G, V), V = V.sibling;
      return null;
    }
    function h(G, V) {
      for (G = /* @__PURE__ */ new Map(); V !== null; ) V.key !== null ? G.set(V.key, V) : G.set(V.index, V), V = V.sibling;
      return G;
    }
    function g(G, V) {
      return G = ko(G, V), G.index = 0, G.sibling = null, G;
    }
    function b(G, V, X) {
      return G.index = X, r ? (X = G.alternate, X !== null ? (X = X.index, X < V ? (G.flags |= 2, V) : X) : (G.flags |= 2, V)) : (G.flags |= 1048576, V);
    }
    function R(G) {
      return r && G.alternate === null && (G.flags |= 2), G;
    }
    function L(G, V, X, Oe) {
      return V === null || V.tag !== 6 ? (V = cp(X, G.mode, Oe), V.return = G, V) : (V = g(V, X), V.return = G, V);
    }
    function $(G, V, X, Oe) {
      var Be = X.type;
      return Be === Ve ? we(G, V, X.props.children, Oe, X.key) : V !== null && (V.elementType === Be || typeof Be == "object" && Be !== null && Be.$$typeof === Ht && xv(Be) === V.type) ? (Oe = g(V, X.props), Oe.ref = rl(G, V, X), Oe.return = G, Oe) : (Oe = jc(X.type, X.key, X.props, null, G.mode, Oe), Oe.ref = rl(G, V, X), Oe.return = G, Oe);
    }
    function ne(G, V, X, Oe) {
      return V === null || V.tag !== 4 || V.stateNode.containerInfo !== X.containerInfo || V.stateNode.implementation !== X.implementation ? (V = ud(X, G.mode, Oe), V.return = G, V) : (V = g(V, X.children || []), V.return = G, V);
    }
    function we(G, V, X, Oe, Be) {
      return V === null || V.tag !== 7 ? (V = Bs(X, G.mode, Oe, Be), V.return = G, V) : (V = g(V, X), V.return = G, V);
    }
    function _e(G, V, X) {
      if (typeof V == "string" && V !== "" || typeof V == "number") return V = cp("" + V, G.mode, X), V.return = G, V;
      if (typeof V == "object" && V !== null) {
        switch (V.$$typeof) {
          case Re:
            return X = jc(V.type, V.key, V.props, null, G.mode, X), X.ref = rl(G, null, V), X.return = G, X;
          case lt:
            return V = ud(V, G.mode, X), V.return = G, V;
          case Ht:
            var Oe = V._init;
            return _e(G, Oe(V._payload), X);
        }
        if (Kn(V) || Ze(V)) return V = Bs(V, G.mode, X, null), V.return = G, V;
        Nf(G, V);
      }
      return null;
    }
    function Ee(G, V, X, Oe) {
      var Be = V !== null ? V.key : null;
      if (typeof X == "string" && X !== "" || typeof X == "number") return Be !== null ? null : L(G, V, "" + X, Oe);
      if (typeof X == "object" && X !== null) {
        switch (X.$$typeof) {
          case Re:
            return X.key === Be ? $(G, V, X, Oe) : null;
          case lt:
            return X.key === Be ? ne(G, V, X, Oe) : null;
          case Ht:
            return Be = X._init, Ee(
              G,
              V,
              Be(X._payload),
              Oe
            );
        }
        if (Kn(X) || Ze(X)) return Be !== null ? null : we(G, V, X, Oe, null);
        Nf(G, X);
      }
      return null;
    }
    function Ge(G, V, X, Oe, Be) {
      if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number") return G = G.get(X) || null, L(V, G, "" + Oe, Be);
      if (typeof Oe == "object" && Oe !== null) {
        switch (Oe.$$typeof) {
          case Re:
            return G = G.get(Oe.key === null ? X : Oe.key) || null, $(V, G, Oe, Be);
          case lt:
            return G = G.get(Oe.key === null ? X : Oe.key) || null, ne(V, G, Oe, Be);
          case Ht:
            var vt = Oe._init;
            return Ge(G, V, X, vt(Oe._payload), Be);
        }
        if (Kn(Oe) || Ze(Oe)) return G = G.get(X) || null, we(V, G, Oe, Be, null);
        Nf(V, Oe);
      }
      return null;
    }
    function et(G, V, X, Oe) {
      for (var Be = null, vt = null, bt = V, At = V = 0, Or = null; bt !== null && At < X.length; At++) {
        bt.index > At ? (Or = bt, bt = null) : Or = bt.sibling;
        var hn = Ee(G, bt, X[At], Oe);
        if (hn === null) {
          bt === null && (bt = Or);
          break;
        }
        r && bt && hn.alternate === null && i(G, bt), V = b(hn, V, At), vt === null ? Be = hn : vt.sibling = hn, vt = hn, bt = Or;
      }
      if (At === X.length) return c(G, bt), Hn && nl(G, At), Be;
      if (bt === null) {
        for (; At < X.length; At++) bt = _e(G, X[At], Oe), bt !== null && (V = b(bt, V, At), vt === null ? Be = bt : vt.sibling = bt, vt = bt);
        return Hn && nl(G, At), Be;
      }
      for (bt = h(G, bt); At < X.length; At++) Or = Ge(bt, G, At, X[At], Oe), Or !== null && (r && Or.alternate !== null && bt.delete(Or.key === null ? At : Or.key), V = b(Or, V, At), vt === null ? Be = Or : vt.sibling = Or, vt = Or);
      return r && bt.forEach(function(Ao) {
        return i(G, Ao);
      }), Hn && nl(G, At), Be;
    }
    function rt(G, V, X, Oe) {
      var Be = Ze(X);
      if (typeof Be != "function") throw Error(s(150));
      if (X = Be.call(X), X == null) throw Error(s(151));
      for (var vt = Be = null, bt = V, At = V = 0, Or = null, hn = X.next(); bt !== null && !hn.done; At++, hn = X.next()) {
        bt.index > At ? (Or = bt, bt = null) : Or = bt.sibling;
        var Ao = Ee(G, bt, hn.value, Oe);
        if (Ao === null) {
          bt === null && (bt = Or);
          break;
        }
        r && bt && Ao.alternate === null && i(G, bt), V = b(Ao, V, At), vt === null ? Be = Ao : vt.sibling = Ao, vt = Ao, bt = Or;
      }
      if (hn.done) return c(
        G,
        bt
      ), Hn && nl(G, At), Be;
      if (bt === null) {
        for (; !hn.done; At++, hn = X.next()) hn = _e(G, hn.value, Oe), hn !== null && (V = b(hn, V, At), vt === null ? Be = hn : vt.sibling = hn, vt = hn);
        return Hn && nl(G, At), Be;
      }
      for (bt = h(G, bt); !hn.done; At++, hn = X.next()) hn = Ge(bt, G, At, hn.value, Oe), hn !== null && (r && hn.alternate !== null && bt.delete(hn.key === null ? At : hn.key), V = b(hn, V, At), vt === null ? Be = hn : vt.sibling = hn, vt = hn);
      return r && bt.forEach(function(Y0) {
        return i(G, Y0);
      }), Hn && nl(G, At), Be;
    }
    function ur(G, V, X, Oe) {
      if (typeof X == "object" && X !== null && X.type === Ve && X.key === null && (X = X.props.children), typeof X == "object" && X !== null) {
        switch (X.$$typeof) {
          case Re:
            e: {
              for (var Be = X.key, vt = V; vt !== null; ) {
                if (vt.key === Be) {
                  if (Be = X.type, Be === Ve) {
                    if (vt.tag === 7) {
                      c(G, vt.sibling), V = g(vt, X.props.children), V.return = G, G = V;
                      break e;
                    }
                  } else if (vt.elementType === Be || typeof Be == "object" && Be !== null && Be.$$typeof === Ht && xv(Be) === vt.type) {
                    c(G, vt.sibling), V = g(vt, X.props), V.ref = rl(G, vt, X), V.return = G, G = V;
                    break e;
                  }
                  c(G, vt);
                  break;
                } else i(G, vt);
                vt = vt.sibling;
              }
              X.type === Ve ? (V = Bs(X.props.children, G.mode, Oe, X.key), V.return = G, G = V) : (Oe = jc(X.type, X.key, X.props, null, G.mode, Oe), Oe.ref = rl(G, V, X), Oe.return = G, G = Oe);
            }
            return R(G);
          case lt:
            e: {
              for (vt = X.key; V !== null; ) {
                if (V.key === vt) if (V.tag === 4 && V.stateNode.containerInfo === X.containerInfo && V.stateNode.implementation === X.implementation) {
                  c(G, V.sibling), V = g(V, X.children || []), V.return = G, G = V;
                  break e;
                } else {
                  c(G, V);
                  break;
                }
                else i(G, V);
                V = V.sibling;
              }
              V = ud(X, G.mode, Oe), V.return = G, G = V;
            }
            return R(G);
          case Ht:
            return vt = X._init, ur(G, V, vt(X._payload), Oe);
        }
        if (Kn(X)) return et(G, V, X, Oe);
        if (Ze(X)) return rt(G, V, X, Oe);
        Nf(G, X);
      }
      return typeof X == "string" && X !== "" || typeof X == "number" ? (X = "" + X, V !== null && V.tag === 6 ? (c(G, V.sibling), V = g(V, X), V.return = G, G = V) : (c(G, V), V = cp(X, G.mode, Oe), V.return = G, G = V), R(G)) : c(G, V);
    }
    return ur;
  }
  var ar = il(!0), Fe = il(!1), Wi = Ia(null), Ni = null, au = null, jh = null;
  function Lh() {
    jh = au = Ni = null;
  }
  function Ph(r) {
    var i = Wi.current;
    Pn(Wi), r._currentValue = i;
  }
  function Uh(r, i, c) {
    for (; r !== null; ) {
      var h = r.alternate;
      if ((r.childLanes & i) !== i ? (r.childLanes |= i, h !== null && (h.childLanes |= i)) : h !== null && (h.childLanes & i) !== i && (h.childLanes |= i), r === c) break;
      r = r.return;
    }
  }
  function Gn(r, i) {
    Ni = r, jh = au = null, r = r.dependencies, r !== null && r.firstContext !== null && (r.lanes & i && (br = !0), r.firstContext = null);
  }
  function ya(r) {
    var i = r._currentValue;
    if (jh !== r) if (r = { context: r, memoizedValue: i, next: null }, au === null) {
      if (Ni === null) throw Error(s(308));
      au = r, Ni.dependencies = { lanes: 0, firstContext: r };
    } else au = au.next = r;
    return i;
  }
  var al = null;
  function Fh(r) {
    al === null ? al = [r] : al.push(r);
  }
  function Ih(r, i, c, h) {
    var g = i.interleaved;
    return g === null ? (c.next = c, Fh(i)) : (c.next = g.next, g.next = c), i.interleaved = c, Gi(r, h);
  }
  function Gi(r, i) {
    r.lanes |= i;
    var c = r.alternate;
    for (c !== null && (c.lanes |= i), c = r, r = r.return; r !== null; ) r.childLanes |= i, c = r.alternate, c !== null && (c.childLanes |= i), c = r, r = r.return;
    return c.tag === 3 ? c.stateNode : null;
  }
  var Ji = !1;
  function zh(r) {
    r.updateQueue = { baseState: r.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Cv(r, i) {
    r = r.updateQueue, i.updateQueue === r && (i.updateQueue = { baseState: r.baseState, firstBaseUpdate: r.firstBaseUpdate, lastBaseUpdate: r.lastBaseUpdate, shared: r.shared, effects: r.effects });
  }
  function Us(r, i) {
    return { eventTime: r, lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function Eo(r, i, c) {
    var h = r.updateQueue;
    if (h === null) return null;
    if (h = h.shared, Zt & 2) {
      var g = h.pending;
      return g === null ? i.next = i : (i.next = g.next, g.next = i), h.pending = i, Gi(r, c);
    }
    return g = h.interleaved, g === null ? (i.next = i, Fh(h)) : (i.next = g.next, g.next = i), h.interleaved = i, Gi(r, c);
  }
  function Af(r, i, c) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (c & 4194240) !== 0)) {
      var h = i.lanes;
      h &= r.pendingLanes, c |= h, i.lanes = c, ks(r, c);
    }
  }
  function Rv(r, i) {
    var c = r.updateQueue, h = r.alternate;
    if (h !== null && (h = h.updateQueue, c === h)) {
      var g = null, b = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var R = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          b === null ? g = b = R : b = b.next = R, c = c.next;
        } while (c !== null);
        b === null ? g = b = i : b = b.next = i;
      } else g = b = i;
      c = { baseState: h.baseState, firstBaseUpdate: g, lastBaseUpdate: b, shared: h.shared, effects: h.effects }, r.updateQueue = c;
      return;
    }
    r = c.lastBaseUpdate, r === null ? c.firstBaseUpdate = i : r.next = i, c.lastBaseUpdate = i;
  }
  function ac(r, i, c, h) {
    var g = r.updateQueue;
    Ji = !1;
    var b = g.firstBaseUpdate, R = g.lastBaseUpdate, L = g.shared.pending;
    if (L !== null) {
      g.shared.pending = null;
      var $ = L, ne = $.next;
      $.next = null, R === null ? b = ne : R.next = ne, R = $;
      var we = r.alternate;
      we !== null && (we = we.updateQueue, L = we.lastBaseUpdate, L !== R && (L === null ? we.firstBaseUpdate = ne : L.next = ne, we.lastBaseUpdate = $));
    }
    if (b !== null) {
      var _e = g.baseState;
      R = 0, we = ne = $ = null, L = b;
      do {
        var Ee = L.lane, Ge = L.eventTime;
        if ((h & Ee) === Ee) {
          we !== null && (we = we.next = {
            eventTime: Ge,
            lane: 0,
            tag: L.tag,
            payload: L.payload,
            callback: L.callback,
            next: null
          });
          e: {
            var et = r, rt = L;
            switch (Ee = i, Ge = c, rt.tag) {
              case 1:
                if (et = rt.payload, typeof et == "function") {
                  _e = et.call(Ge, _e, Ee);
                  break e;
                }
                _e = et;
                break e;
              case 3:
                et.flags = et.flags & -65537 | 128;
              case 0:
                if (et = rt.payload, Ee = typeof et == "function" ? et.call(Ge, _e, Ee) : et, Ee == null) break e;
                _e = ke({}, _e, Ee);
                break e;
              case 2:
                Ji = !0;
            }
          }
          L.callback !== null && L.lane !== 0 && (r.flags |= 64, Ee = g.effects, Ee === null ? g.effects = [L] : Ee.push(L));
        } else Ge = { eventTime: Ge, lane: Ee, tag: L.tag, payload: L.payload, callback: L.callback, next: null }, we === null ? (ne = we = Ge, $ = _e) : we = we.next = Ge, R |= Ee;
        if (L = L.next, L === null) {
          if (L = g.shared.pending, L === null) break;
          Ee = L, L = Ee.next, Ee.next = null, g.lastBaseUpdate = Ee, g.shared.pending = null;
        }
      } while (!0);
      if (we === null && ($ = _e), g.baseState = $, g.firstBaseUpdate = ne, g.lastBaseUpdate = we, i = g.shared.interleaved, i !== null) {
        g = i;
        do
          R |= g.lane, g = g.next;
        while (g !== i);
      } else b === null && (g.shared.lanes = 0);
      ps |= R, r.lanes = R, r.memoizedState = _e;
    }
  }
  function $h(r, i, c) {
    if (r = i.effects, i.effects = null, r !== null) for (i = 0; i < r.length; i++) {
      var h = r[i], g = h.callback;
      if (g !== null) {
        if (h.callback = null, h = c, typeof g != "function") throw Error(s(191, g));
        g.call(h);
      }
    }
  }
  var sc = {}, cs = Ia(sc), oc = Ia(sc), lc = Ia(sc);
  function sl(r) {
    if (r === sc) throw Error(s(174));
    return r;
  }
  function Bh(r, i) {
    switch (ft(lc, i), ft(oc, r), ft(cs, sc), r = i.nodeType, r) {
      case 9:
      case 11:
        i = (i = i.documentElement) ? i.namespaceURI : ai(null, "");
        break;
      default:
        r = r === 8 ? i.parentNode : i, i = r.namespaceURI || null, r = r.tagName, i = ai(i, r);
    }
    Pn(cs), ft(cs, i);
  }
  function ol() {
    Pn(cs), Pn(oc), Pn(lc);
  }
  function Tv(r) {
    sl(lc.current);
    var i = sl(cs.current), c = ai(i, r.type);
    i !== c && (ft(oc, r), ft(cs, c));
  }
  function Df(r) {
    oc.current === r && (Pn(cs), Pn(oc));
  }
  var Jn = Ia(0);
  function Mf(r) {
    for (var i = r; i !== null; ) {
      if (i.tag === 13) {
        var c = i.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!")) return i;
      } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
        if (i.flags & 128) return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === r) break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === r) return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var uc = [];
  function mt() {
    for (var r = 0; r < uc.length; r++) uc[r]._workInProgressVersionPrimary = null;
    uc.length = 0;
  }
  var qt = De.ReactCurrentDispatcher, fn = De.ReactCurrentBatchConfig, On = 0, dn = null, yr = null, Mr = null, jf = !1, cc = !1, ll = 0, Se = 0;
  function ln() {
    throw Error(s(321));
  }
  function Ct(r, i) {
    if (i === null) return !1;
    for (var c = 0; c < i.length && c < r.length; c++) if (!Ua(r[c], i[c])) return !1;
    return !0;
  }
  function wo(r, i, c, h, g, b) {
    if (On = b, dn = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, qt.current = r === null || r.memoizedState === null ? Jf : vc, r = c(h, g), cc) {
      b = 0;
      do {
        if (cc = !1, ll = 0, 25 <= b) throw Error(s(301));
        b += 1, Mr = yr = null, i.updateQueue = null, qt.current = Qf, r = c(h, g);
      } while (cc);
    }
    if (qt.current = hl, i = yr !== null && yr.next !== null, On = 0, Mr = yr = dn = null, jf = !1, i) throw Error(s(300));
    return r;
  }
  function za() {
    var r = ll !== 0;
    return ll = 0, r;
  }
  function ti() {
    var r = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Mr === null ? dn.memoizedState = Mr = r : Mr = Mr.next = r, Mr;
  }
  function sr() {
    if (yr === null) {
      var r = dn.alternate;
      r = r !== null ? r.memoizedState : null;
    } else r = yr.next;
    var i = Mr === null ? dn.memoizedState : Mr.next;
    if (i !== null) Mr = i, yr = r;
    else {
      if (r === null) throw Error(s(310));
      yr = r, r = { memoizedState: yr.memoizedState, baseState: yr.baseState, baseQueue: yr.baseQueue, queue: yr.queue, next: null }, Mr === null ? dn.memoizedState = Mr = r : Mr = Mr.next = r;
    }
    return Mr;
  }
  function Fs(r, i) {
    return typeof i == "function" ? i(r) : i;
  }
  function _o(r) {
    var i = sr(), c = i.queue;
    if (c === null) throw Error(s(311));
    c.lastRenderedReducer = r;
    var h = yr, g = h.baseQueue, b = c.pending;
    if (b !== null) {
      if (g !== null) {
        var R = g.next;
        g.next = b.next, b.next = R;
      }
      h.baseQueue = g = b, c.pending = null;
    }
    if (g !== null) {
      b = g.next, h = h.baseState;
      var L = R = null, $ = null, ne = b;
      do {
        var we = ne.lane;
        if ((On & we) === we) $ !== null && ($ = $.next = { lane: 0, action: ne.action, hasEagerState: ne.hasEagerState, eagerState: ne.eagerState, next: null }), h = ne.hasEagerState ? ne.eagerState : r(h, ne.action);
        else {
          var _e = {
            lane: we,
            action: ne.action,
            hasEagerState: ne.hasEagerState,
            eagerState: ne.eagerState,
            next: null
          };
          $ === null ? (L = $ = _e, R = h) : $ = $.next = _e, dn.lanes |= we, ps |= we;
        }
        ne = ne.next;
      } while (ne !== null && ne !== b);
      $ === null ? R = h : $.next = L, Ua(h, i.memoizedState) || (br = !0), i.memoizedState = h, i.baseState = R, i.baseQueue = $, c.lastRenderedState = h;
    }
    if (r = c.interleaved, r !== null) {
      g = r;
      do
        b = g.lane, dn.lanes |= b, ps |= b, g = g.next;
      while (g !== r);
    } else g === null && (c.lanes = 0);
    return [i.memoizedState, c.dispatch];
  }
  function ul(r) {
    var i = sr(), c = i.queue;
    if (c === null) throw Error(s(311));
    c.lastRenderedReducer = r;
    var h = c.dispatch, g = c.pending, b = i.memoizedState;
    if (g !== null) {
      c.pending = null;
      var R = g = g.next;
      do
        b = r(b, R.action), R = R.next;
      while (R !== g);
      Ua(b, i.memoizedState) || (br = !0), i.memoizedState = b, i.baseQueue === null && (i.baseState = b), c.lastRenderedState = b;
    }
    return [b, h];
  }
  function Lf() {
  }
  function Pf(r, i) {
    var c = dn, h = sr(), g = i(), b = !Ua(h.memoizedState, g);
    if (b && (h.memoizedState = g, br = !0), h = h.queue, fc(If.bind(null, c, h, r), [r]), h.getSnapshot !== i || b || Mr !== null && Mr.memoizedState.tag & 1) {
      if (c.flags |= 2048, cl(9, Ff.bind(null, c, h, g, i), void 0, null), kr === null) throw Error(s(349));
      On & 30 || Uf(c, i, g);
    }
    return g;
  }
  function Uf(r, i, c) {
    r.flags |= 16384, r = { getSnapshot: i, value: c }, i = dn.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, dn.updateQueue = i, i.stores = [r]) : (c = i.stores, c === null ? i.stores = [r] : c.push(r));
  }
  function Ff(r, i, c, h) {
    i.value = c, i.getSnapshot = h, zf(i) && $f(r);
  }
  function If(r, i, c) {
    return c(function() {
      zf(i) && $f(r);
    });
  }
  function zf(r) {
    var i = r.getSnapshot;
    r = r.value;
    try {
      var c = i();
      return !Ua(r, c);
    } catch {
      return !0;
    }
  }
  function $f(r) {
    var i = Gi(r, 1);
    i !== null && fi(i, r, 1, -1);
  }
  function Bf(r) {
    var i = ti();
    return typeof r == "function" && (r = r()), i.memoizedState = i.baseState = r, r = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Fs, lastRenderedState: r }, i.queue = r, r = r.dispatch = dl.bind(null, dn, r), [i.memoizedState, r];
  }
  function cl(r, i, c, h) {
    return r = { tag: r, create: i, destroy: c, deps: h, next: null }, i = dn.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, dn.updateQueue = i, i.lastEffect = r.next = r) : (c = i.lastEffect, c === null ? i.lastEffect = r.next = r : (h = c.next, c.next = r, r.next = h, i.lastEffect = r)), r;
  }
  function Hf() {
    return sr().memoizedState;
  }
  function su(r, i, c, h) {
    var g = ti();
    dn.flags |= r, g.memoizedState = cl(1 | i, c, void 0, h === void 0 ? null : h);
  }
  function ou(r, i, c, h) {
    var g = sr();
    h = h === void 0 ? null : h;
    var b = void 0;
    if (yr !== null) {
      var R = yr.memoizedState;
      if (b = R.destroy, h !== null && Ct(h, R.deps)) {
        g.memoizedState = cl(i, c, b, h);
        return;
      }
    }
    dn.flags |= r, g.memoizedState = cl(1 | i, c, b, h);
  }
  function Vf(r, i) {
    return su(8390656, 8, r, i);
  }
  function fc(r, i) {
    return ou(2048, 8, r, i);
  }
  function qf(r, i) {
    return ou(4, 2, r, i);
  }
  function dc(r, i) {
    return ou(4, 4, r, i);
  }
  function fl(r, i) {
    if (typeof i == "function") return r = r(), i(r), function() {
      i(null);
    };
    if (i != null) return r = r(), i.current = r, function() {
      i.current = null;
    };
  }
  function Yf(r, i, c) {
    return c = c != null ? c.concat([r]) : null, ou(4, 4, fl.bind(null, i, r), c);
  }
  function hc() {
  }
  function Wf(r, i) {
    var c = sr();
    i = i === void 0 ? null : i;
    var h = c.memoizedState;
    return h !== null && i !== null && Ct(i, h[1]) ? h[0] : (c.memoizedState = [r, i], r);
  }
  function Gf(r, i) {
    var c = sr();
    i = i === void 0 ? null : i;
    var h = c.memoizedState;
    return h !== null && i !== null && Ct(i, h[1]) ? h[0] : (r = r(), c.memoizedState = [r, i], r);
  }
  function Hh(r, i, c) {
    return On & 21 ? (Ua(c, i) || (c = zl(), dn.lanes |= c, ps |= c, r.baseState = !0), i) : (r.baseState && (r.baseState = !1, br = !0), r.memoizedState = c);
  }
  function pc(r, i) {
    var c = cn;
    cn = c !== 0 && 4 > c ? c : 4, r(!0);
    var h = fn.transition;
    fn.transition = {};
    try {
      r(!1), i();
    } finally {
      cn = c, fn.transition = h;
    }
  }
  function Vh() {
    return sr().memoizedState;
  }
  function mc(r, i, c) {
    var h = ms(r);
    if (c = { lane: h, action: c, hasEagerState: !1, eagerState: null, next: null }, Qi(r)) kv(i, c);
    else if (c = Ih(r, i, c, h), c !== null) {
      var g = wr();
      fi(c, r, h, g), Mn(c, i, h);
    }
  }
  function dl(r, i, c) {
    var h = ms(r), g = { lane: h, action: c, hasEagerState: !1, eagerState: null, next: null };
    if (Qi(r)) kv(i, g);
    else {
      var b = r.alternate;
      if (r.lanes === 0 && (b === null || b.lanes === 0) && (b = i.lastRenderedReducer, b !== null)) try {
        var R = i.lastRenderedState, L = b(R, c);
        if (g.hasEagerState = !0, g.eagerState = L, Ua(L, R)) {
          var $ = i.interleaved;
          $ === null ? (g.next = g, Fh(i)) : (g.next = $.next, $.next = g), i.interleaved = g;
          return;
        }
      } catch {
      } finally {
      }
      c = Ih(r, i, g, h), c !== null && (g = wr(), fi(c, r, h, g), Mn(c, i, h));
    }
  }
  function Qi(r) {
    var i = r.alternate;
    return r === dn || i !== null && i === dn;
  }
  function kv(r, i) {
    cc = jf = !0;
    var c = r.pending;
    c === null ? i.next = i : (i.next = c.next, c.next = i), r.pending = i;
  }
  function Mn(r, i, c) {
    if (c & 4194240) {
      var h = i.lanes;
      h &= r.pendingLanes, c |= h, i.lanes = c, ks(r, c);
    }
  }
  var hl = { readContext: ya, useCallback: ln, useContext: ln, useEffect: ln, useImperativeHandle: ln, useInsertionEffect: ln, useLayoutEffect: ln, useMemo: ln, useReducer: ln, useRef: ln, useState: ln, useDebugValue: ln, useDeferredValue: ln, useTransition: ln, useMutableSource: ln, useSyncExternalStore: ln, useId: ln, unstable_isNewReconciler: !1 }, Jf = { readContext: ya, useCallback: function(r, i) {
    return ti().memoizedState = [r, i === void 0 ? null : i], r;
  }, useContext: ya, useEffect: Vf, useImperativeHandle: function(r, i, c) {
    return c = c != null ? c.concat([r]) : null, su(
      4194308,
      4,
      fl.bind(null, i, r),
      c
    );
  }, useLayoutEffect: function(r, i) {
    return su(4194308, 4, r, i);
  }, useInsertionEffect: function(r, i) {
    return su(4, 2, r, i);
  }, useMemo: function(r, i) {
    var c = ti();
    return i = i === void 0 ? null : i, r = r(), c.memoizedState = [r, i], r;
  }, useReducer: function(r, i, c) {
    var h = ti();
    return i = c !== void 0 ? c(i) : i, h.memoizedState = h.baseState = i, r = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: r, lastRenderedState: i }, h.queue = r, r = r.dispatch = mc.bind(null, dn, r), [h.memoizedState, r];
  }, useRef: function(r) {
    var i = ti();
    return r = { current: r }, i.memoizedState = r;
  }, useState: Bf, useDebugValue: hc, useDeferredValue: function(r) {
    return ti().memoizedState = r;
  }, useTransition: function() {
    var r = Bf(!1), i = r[0];
    return r = pc.bind(null, r[1]), ti().memoizedState = r, [i, r];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(r, i, c) {
    var h = dn, g = ti();
    if (Hn) {
      if (c === void 0) throw Error(s(407));
      c = c();
    } else {
      if (c = i(), kr === null) throw Error(s(349));
      On & 30 || Uf(h, i, c);
    }
    g.memoizedState = c;
    var b = { value: c, getSnapshot: i };
    return g.queue = b, Vf(If.bind(
      null,
      h,
      b,
      r
    ), [r]), h.flags |= 2048, cl(9, Ff.bind(null, h, b, c, i), void 0, null), c;
  }, useId: function() {
    var r = ti(), i = kr.identifierPrefix;
    if (Hn) {
      var c = us, h = ls;
      c = (h & ~(1 << 32 - Dn(h) - 1)).toString(32) + c, i = ":" + i + "R" + c, c = ll++, 0 < c && (i += "H" + c.toString(32)), i += ":";
    } else c = Se++, i = ":" + i + "r" + c.toString(32) + ":";
    return r.memoizedState = i;
  }, unstable_isNewReconciler: !1 }, vc = {
    readContext: ya,
    useCallback: Wf,
    useContext: ya,
    useEffect: fc,
    useImperativeHandle: Yf,
    useInsertionEffect: qf,
    useLayoutEffect: dc,
    useMemo: Gf,
    useReducer: _o,
    useRef: Hf,
    useState: function() {
      return _o(Fs);
    },
    useDebugValue: hc,
    useDeferredValue: function(r) {
      var i = sr();
      return Hh(i, yr.memoizedState, r);
    },
    useTransition: function() {
      var r = _o(Fs)[0], i = sr().memoizedState;
      return [r, i];
    },
    useMutableSource: Lf,
    useSyncExternalStore: Pf,
    useId: Vh,
    unstable_isNewReconciler: !1
  }, Qf = { readContext: ya, useCallback: Wf, useContext: ya, useEffect: fc, useImperativeHandle: Yf, useInsertionEffect: qf, useLayoutEffect: dc, useMemo: Gf, useReducer: ul, useRef: Hf, useState: function() {
    return ul(Fs);
  }, useDebugValue: hc, useDeferredValue: function(r) {
    var i = sr();
    return yr === null ? i.memoizedState = r : Hh(i, yr.memoizedState, r);
  }, useTransition: function() {
    var r = ul(Fs)[0], i = sr().memoizedState;
    return [r, i];
  }, useMutableSource: Lf, useSyncExternalStore: Pf, useId: Vh, unstable_isNewReconciler: !1 };
  function $a(r, i) {
    if (r && r.defaultProps) {
      i = ke({}, i), r = r.defaultProps;
      for (var c in r) i[c] === void 0 && (i[c] = r[c]);
      return i;
    }
    return i;
  }
  function qh(r, i, c, h) {
    i = r.memoizedState, c = c(h, i), c = c == null ? i : ke({}, i, c), r.memoizedState = c, r.lanes === 0 && (r.updateQueue.baseState = c);
  }
  var Kf = { isMounted: function(r) {
    return (r = r._reactInternals) ? Et(r) === r : !1;
  }, enqueueSetState: function(r, i, c) {
    r = r._reactInternals;
    var h = wr(), g = ms(r), b = Us(h, g);
    b.payload = i, c != null && (b.callback = c), i = Eo(r, b, g), i !== null && (fi(i, r, g, h), Af(i, r, g));
  }, enqueueReplaceState: function(r, i, c) {
    r = r._reactInternals;
    var h = wr(), g = ms(r), b = Us(h, g);
    b.tag = 1, b.payload = i, c != null && (b.callback = c), i = Eo(r, b, g), i !== null && (fi(i, r, g, h), Af(i, r, g));
  }, enqueueForceUpdate: function(r, i) {
    r = r._reactInternals;
    var c = wr(), h = ms(r), g = Us(c, h);
    g.tag = 2, i != null && (g.callback = i), i = Eo(r, g, h), i !== null && (fi(i, r, h, c), Af(i, r, h));
  } };
  function Ov(r, i, c, h, g, b, R) {
    return r = r.stateNode, typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(h, b, R) : i.prototype && i.prototype.isPureReactComponent ? !Ju(c, h) || !Ju(g, b) : !0;
  }
  function Xf(r, i, c) {
    var h = !1, g = Ci, b = i.contextType;
    return typeof b == "object" && b !== null ? b = ya(b) : (g = vr(i) ? Ri : tr.current, h = i.contextTypes, b = (h = h != null) ? ma(r, g) : Ci), i = new i(c, b), r.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, i.updater = Kf, r.stateNode = i, i._reactInternals = r, h && (r = r.stateNode, r.__reactInternalMemoizedUnmaskedChildContext = g, r.__reactInternalMemoizedMaskedChildContext = b), i;
  }
  function Nv(r, i, c, h) {
    r = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(c, h), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(c, h), i.state !== r && Kf.enqueueReplaceState(i, i.state, null);
  }
  function gc(r, i, c, h) {
    var g = r.stateNode;
    g.props = c, g.state = r.memoizedState, g.refs = {}, zh(r);
    var b = i.contextType;
    typeof b == "object" && b !== null ? g.context = ya(b) : (b = vr(i) ? Ri : tr.current, g.context = ma(r, b)), g.state = r.memoizedState, b = i.getDerivedStateFromProps, typeof b == "function" && (qh(r, i, b, c), g.state = r.memoizedState), typeof i.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (i = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), i !== g.state && Kf.enqueueReplaceState(g, g.state, null), ac(r, c, g, h), g.state = r.memoizedState), typeof g.componentDidMount == "function" && (r.flags |= 4194308);
  }
  function pl(r, i) {
    try {
      var c = "", h = i;
      do
        c += ot(h), h = h.return;
      while (h);
      var g = c;
    } catch (b) {
      g = `
Error generating stack: ` + b.message + `
` + b.stack;
    }
    return { value: r, source: i, stack: g, digest: null };
  }
  function Yh(r, i, c) {
    return { value: r, source: null, stack: c ?? null, digest: i ?? null };
  }
  function Wh(r, i) {
    try {
      console.error(i.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Zf = typeof WeakMap == "function" ? WeakMap : Map;
  function Av(r, i, c) {
    c = Us(-1, c), c.tag = 3, c.payload = { element: null };
    var h = i.value;
    return c.callback = function() {
      hu || (hu = !0, gl = h), Wh(r, i);
    }, c;
  }
  function Gh(r, i, c) {
    c = Us(-1, c), c.tag = 3;
    var h = r.type.getDerivedStateFromError;
    if (typeof h == "function") {
      var g = i.value;
      c.payload = function() {
        return h(g);
      }, c.callback = function() {
        Wh(r, i);
      };
    }
    var b = r.stateNode;
    return b !== null && typeof b.componentDidCatch == "function" && (c.callback = function() {
      Wh(r, i), typeof h != "function" && (Ro === null ? Ro = /* @__PURE__ */ new Set([this]) : Ro.add(this));
      var R = i.stack;
      this.componentDidCatch(i.value, { componentStack: R !== null ? R : "" });
    }), c;
  }
  function Jh(r, i, c) {
    var h = r.pingCache;
    if (h === null) {
      h = r.pingCache = new Zf();
      var g = /* @__PURE__ */ new Set();
      h.set(i, g);
    } else g = h.get(i), g === void 0 && (g = /* @__PURE__ */ new Set(), h.set(i, g));
    g.has(c) || (g.add(c), r = I0.bind(null, r, i, c), i.then(r, r));
  }
  function Dv(r) {
    do {
      var i;
      if ((i = r.tag === 13) && (i = r.memoizedState, i = i !== null ? i.dehydrated !== null : !0), i) return r;
      r = r.return;
    } while (r !== null);
    return null;
  }
  function xo(r, i, c, h, g) {
    return r.mode & 1 ? (r.flags |= 65536, r.lanes = g, r) : (r === i ? r.flags |= 65536 : (r.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (i = Us(-1, 1), i.tag = 2, Eo(c, i, 1))), c.lanes |= 1), r);
  }
  var yc = De.ReactCurrentOwner, br = !1;
  function Br(r, i, c, h) {
    i.child = r === null ? Fe(i, null, c, h) : ar(i, r.child, c, h);
  }
  function Ai(r, i, c, h, g) {
    c = c.render;
    var b = i.ref;
    return Gn(i, g), h = wo(r, i, c, h, b, g), c = za(), r !== null && !br ? (i.updateQueue = r.updateQueue, i.flags &= -2053, r.lanes &= ~g, Sa(r, i, g)) : (Hn && c && Tf(i), i.flags |= 1, Br(r, i, h, g), i.child);
  }
  function ml(r, i, c, h, g) {
    if (r === null) {
      var b = c.type;
      return typeof b == "function" && !up(b) && b.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (i.tag = 15, i.type = b, It(r, i, b, h, g)) : (r = jc(c.type, null, h, i, i.mode, g), r.ref = i.ref, r.return = i, i.child = r);
    }
    if (b = r.child, !(r.lanes & g)) {
      var R = b.memoizedProps;
      if (c = c.compare, c = c !== null ? c : Ju, c(R, h) && r.ref === i.ref) return Sa(r, i, g);
    }
    return i.flags |= 1, r = ko(b, h), r.ref = i.ref, r.return = i, i.child = r;
  }
  function It(r, i, c, h, g) {
    if (r !== null) {
      var b = r.memoizedProps;
      if (Ju(b, h) && r.ref === i.ref) if (br = !1, i.pendingProps = h = b, (r.lanes & g) !== 0) r.flags & 131072 && (br = !0);
      else return i.lanes = r.lanes, Sa(r, i, g);
    }
    return Mv(r, i, c, h, g);
  }
  function bc(r, i, c) {
    var h = i.pendingProps, g = h.children, b = r !== null ? r.memoizedState : null;
    if (h.mode === "hidden") if (!(i.mode & 1)) i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ft(cu, Ki), Ki |= c;
    else {
      if (!(c & 1073741824)) return r = b !== null ? b.baseLanes | c : c, i.lanes = i.childLanes = 1073741824, i.memoizedState = { baseLanes: r, cachePool: null, transitions: null }, i.updateQueue = null, ft(cu, Ki), Ki |= r, null;
      i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, h = b !== null ? b.baseLanes : c, ft(cu, Ki), Ki |= h;
    }
    else b !== null ? (h = b.baseLanes | c, i.memoizedState = null) : h = c, ft(cu, Ki), Ki |= h;
    return Br(r, i, g, c), i.child;
  }
  function Qh(r, i) {
    var c = i.ref;
    (r === null && c !== null || r !== null && r.ref !== c) && (i.flags |= 512, i.flags |= 2097152);
  }
  function Mv(r, i, c, h, g) {
    var b = vr(c) ? Ri : tr.current;
    return b = ma(i, b), Gn(i, g), c = wo(r, i, c, h, b, g), h = za(), r !== null && !br ? (i.updateQueue = r.updateQueue, i.flags &= -2053, r.lanes &= ~g, Sa(r, i, g)) : (Hn && h && Tf(i), i.flags |= 1, Br(r, i, c, g), i.child);
  }
  function jv(r, i, c, h, g) {
    if (vr(c)) {
      var b = !0;
      Ti(i);
    } else b = !1;
    if (Gn(i, g), i.stateNode === null) ba(r, i), Xf(i, c, h), gc(i, c, h, g), h = !0;
    else if (r === null) {
      var R = i.stateNode, L = i.memoizedProps;
      R.props = L;
      var $ = R.context, ne = c.contextType;
      typeof ne == "object" && ne !== null ? ne = ya(ne) : (ne = vr(c) ? Ri : tr.current, ne = ma(i, ne));
      var we = c.getDerivedStateFromProps, _e = typeof we == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      _e || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (L !== h || $ !== ne) && Nv(i, R, h, ne), Ji = !1;
      var Ee = i.memoizedState;
      R.state = Ee, ac(i, h, R, g), $ = i.memoizedState, L !== h || Ee !== $ || Rr.current || Ji ? (typeof we == "function" && (qh(i, c, we, h), $ = i.memoizedState), (L = Ji || Ov(i, c, L, h, Ee, $, ne)) ? (_e || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()), typeof R.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof R.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = h, i.memoizedState = $), R.props = h, R.state = $, R.context = ne, h = L) : (typeof R.componentDidMount == "function" && (i.flags |= 4194308), h = !1);
    } else {
      R = i.stateNode, Cv(r, i), L = i.memoizedProps, ne = i.type === i.elementType ? L : $a(i.type, L), R.props = ne, _e = i.pendingProps, Ee = R.context, $ = c.contextType, typeof $ == "object" && $ !== null ? $ = ya($) : ($ = vr(c) ? Ri : tr.current, $ = ma(i, $));
      var Ge = c.getDerivedStateFromProps;
      (we = typeof Ge == "function" || typeof R.getSnapshotBeforeUpdate == "function") || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (L !== _e || Ee !== $) && Nv(i, R, h, $), Ji = !1, Ee = i.memoizedState, R.state = Ee, ac(i, h, R, g);
      var et = i.memoizedState;
      L !== _e || Ee !== et || Rr.current || Ji ? (typeof Ge == "function" && (qh(i, c, Ge, h), et = i.memoizedState), (ne = Ji || Ov(i, c, ne, h, Ee, et, $) || !1) ? (we || typeof R.UNSAFE_componentWillUpdate != "function" && typeof R.componentWillUpdate != "function" || (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(h, et, $), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(h, et, $)), typeof R.componentDidUpdate == "function" && (i.flags |= 4), typeof R.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof R.componentDidUpdate != "function" || L === r.memoizedProps && Ee === r.memoizedState || (i.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || L === r.memoizedProps && Ee === r.memoizedState || (i.flags |= 1024), i.memoizedProps = h, i.memoizedState = et), R.props = h, R.state = et, R.context = $, h = ne) : (typeof R.componentDidUpdate != "function" || L === r.memoizedProps && Ee === r.memoizedState || (i.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || L === r.memoizedProps && Ee === r.memoizedState || (i.flags |= 1024), h = !1);
    }
    return Sc(r, i, c, h, b, g);
  }
  function Sc(r, i, c, h, g, b) {
    Qh(r, i);
    var R = (i.flags & 128) !== 0;
    if (!h && !R) return g && Cf(i, c, !1), Sa(r, i, b);
    h = i.stateNode, yc.current = i;
    var L = R && typeof c.getDerivedStateFromError != "function" ? null : h.render();
    return i.flags |= 1, r !== null && R ? (i.child = ar(i, r.child, null, b), i.child = ar(i, null, L, b)) : Br(r, i, L, b), i.memoizedState = h.state, g && Cf(i, c, !0), i.child;
  }
  function lu(r) {
    var i = r.stateNode;
    i.pendingContext ? Ev(r, i.pendingContext, i.pendingContext !== i.context) : i.context && Ev(r, i.context, !1), Bh(r, i.containerInfo);
  }
  function Lv(r, i, c, h, g) {
    return So(), Ps(g), i.flags |= 256, Br(r, i, c, h), i.child;
  }
  var ed = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Kh(r) {
    return { baseLanes: r, cachePool: null, transitions: null };
  }
  function td(r, i, c) {
    var h = i.pendingProps, g = Jn.current, b = !1, R = (i.flags & 128) !== 0, L;
    if ((L = R) || (L = r !== null && r.memoizedState === null ? !1 : (g & 2) !== 0), L ? (b = !0, i.flags &= -129) : (r === null || r.memoizedState !== null) && (g |= 1), ft(Jn, g & 1), r === null)
      return Mh(i), r = i.memoizedState, r !== null && (r = r.dehydrated, r !== null) ? (i.mode & 1 ? r.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824 : i.lanes = 1, null) : (R = h.children, r = h.fallback, b ? (h = i.mode, b = i.child, R = { mode: "hidden", children: R }, !(h & 1) && b !== null ? (b.childLanes = 0, b.pendingProps = R) : b = Oo(R, h, 0, null), r = Bs(r, h, c, null), b.return = i, r.return = i, b.sibling = r, i.child = b, i.child.memoizedState = Kh(c), i.memoizedState = ed, r) : Xh(i, R));
    if (g = r.memoizedState, g !== null && (L = g.dehydrated, L !== null)) return Pv(r, i, R, h, L, g, c);
    if (b) {
      b = h.fallback, R = i.mode, g = r.child, L = g.sibling;
      var $ = { mode: "hidden", children: h.children };
      return !(R & 1) && i.child !== g ? (h = i.child, h.childLanes = 0, h.pendingProps = $, i.deletions = null) : (h = ko(g, $), h.subtreeFlags = g.subtreeFlags & 14680064), L !== null ? b = ko(L, b) : (b = Bs(b, R, c, null), b.flags |= 2), b.return = i, h.return = i, h.sibling = b, i.child = h, h = b, b = i.child, R = r.child.memoizedState, R = R === null ? Kh(c) : { baseLanes: R.baseLanes | c, cachePool: null, transitions: R.transitions }, b.memoizedState = R, b.childLanes = r.childLanes & ~c, i.memoizedState = ed, h;
    }
    return b = r.child, r = b.sibling, h = ko(b, { mode: "visible", children: h.children }), !(i.mode & 1) && (h.lanes = c), h.return = i, h.sibling = null, r !== null && (c = i.deletions, c === null ? (i.deletions = [r], i.flags |= 16) : c.push(r)), i.child = h, i.memoizedState = null, h;
  }
  function Xh(r, i) {
    return i = Oo({ mode: "visible", children: i }, r.mode, 0, null), i.return = r, r.child = i;
  }
  function Ec(r, i, c, h) {
    return h !== null && Ps(h), ar(i, r.child, null, c), r = Xh(i, i.pendingProps.children), r.flags |= 2, i.memoizedState = null, r;
  }
  function Pv(r, i, c, h, g, b, R) {
    if (c)
      return i.flags & 256 ? (i.flags &= -257, h = Yh(Error(s(422))), Ec(r, i, R, h)) : i.memoizedState !== null ? (i.child = r.child, i.flags |= 128, null) : (b = h.fallback, g = i.mode, h = Oo({ mode: "visible", children: h.children }, g, 0, null), b = Bs(b, g, R, null), b.flags |= 2, h.return = i, b.return = i, h.sibling = b, i.child = h, i.mode & 1 && ar(i, r.child, null, R), i.child.memoizedState = Kh(R), i.memoizedState = ed, b);
    if (!(i.mode & 1)) return Ec(r, i, R, null);
    if (g.data === "$!") {
      if (h = g.nextSibling && g.nextSibling.dataset, h) var L = h.dgst;
      return h = L, b = Error(s(419)), h = Yh(b, h, void 0), Ec(r, i, R, h);
    }
    if (L = (R & r.childLanes) !== 0, br || L) {
      if (h = kr, h !== null) {
        switch (R & -R) {
          case 4:
            g = 2;
            break;
          case 16:
            g = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            g = 32;
            break;
          case 536870912:
            g = 268435456;
            break;
          default:
            g = 0;
        }
        g = g & (h.suspendedLanes | R) ? 0 : g, g !== 0 && g !== b.retryLane && (b.retryLane = g, Gi(r, g), fi(h, r, g, -1));
      }
      return lp(), h = Yh(Error(s(421))), Ec(r, i, R, h);
    }
    return g.data === "$?" ? (i.flags |= 128, i.child = r.child, i = z0.bind(null, r), g._reactRetry = i, null) : (r = b.treeContext, Oi = is(g.nextSibling), ki = i, Hn = !0, ga = null, r !== null && (gr[va++] = ls, gr[va++] = us, gr[va++] = Yi, ls = r.id, us = r.overflow, Yi = i), i = Xh(i, h.children), i.flags |= 4096, i);
  }
  function Zh(r, i, c) {
    r.lanes |= i;
    var h = r.alternate;
    h !== null && (h.lanes |= i), Uh(r.return, i, c);
  }
  function li(r, i, c, h, g) {
    var b = r.memoizedState;
    b === null ? r.memoizedState = { isBackwards: i, rendering: null, renderingStartTime: 0, last: h, tail: c, tailMode: g } : (b.isBackwards = i, b.rendering = null, b.renderingStartTime = 0, b.last = h, b.tail = c, b.tailMode = g);
  }
  function fs(r, i, c) {
    var h = i.pendingProps, g = h.revealOrder, b = h.tail;
    if (Br(r, i, h.children, c), h = Jn.current, h & 2) h = h & 1 | 2, i.flags |= 128;
    else {
      if (r !== null && r.flags & 128) e: for (r = i.child; r !== null; ) {
        if (r.tag === 13) r.memoizedState !== null && Zh(r, c, i);
        else if (r.tag === 19) Zh(r, c, i);
        else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === i) break e;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === i) break e;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      h &= 1;
    }
    if (ft(Jn, h), !(i.mode & 1)) i.memoizedState = null;
    else switch (g) {
      case "forwards":
        for (c = i.child, g = null; c !== null; ) r = c.alternate, r !== null && Mf(r) === null && (g = c), c = c.sibling;
        c = g, c === null ? (g = i.child, i.child = null) : (g = c.sibling, c.sibling = null), li(i, !1, g, c, b);
        break;
      case "backwards":
        for (c = null, g = i.child, i.child = null; g !== null; ) {
          if (r = g.alternate, r !== null && Mf(r) === null) {
            i.child = g;
            break;
          }
          r = g.sibling, g.sibling = c, c = g, g = r;
        }
        li(i, !0, c, null, b);
        break;
      case "together":
        li(i, !1, null, null, void 0);
        break;
      default:
        i.memoizedState = null;
    }
    return i.child;
  }
  function ba(r, i) {
    !(i.mode & 1) && r !== null && (r.alternate = null, i.alternate = null, i.flags |= 2);
  }
  function Sa(r, i, c) {
    if (r !== null && (i.dependencies = r.dependencies), ps |= i.lanes, !(c & i.childLanes)) return null;
    if (r !== null && i.child !== r.child) throw Error(s(153));
    if (i.child !== null) {
      for (r = i.child, c = ko(r, r.pendingProps), i.child = c, c.return = i; r.sibling !== null; ) r = r.sibling, c = c.sibling = ko(r, r.pendingProps), c.return = i;
      c.sibling = null;
    }
    return i.child;
  }
  function wc(r, i, c) {
    switch (i.tag) {
      case 3:
        lu(i), So();
        break;
      case 5:
        Tv(i);
        break;
      case 1:
        vr(i.type) && Ti(i);
        break;
      case 4:
        Bh(i, i.stateNode.containerInfo);
        break;
      case 10:
        var h = i.type._context, g = i.memoizedProps.value;
        ft(Wi, h._currentValue), h._currentValue = g;
        break;
      case 13:
        if (h = i.memoizedState, h !== null)
          return h.dehydrated !== null ? (ft(Jn, Jn.current & 1), i.flags |= 128, null) : c & i.child.childLanes ? td(r, i, c) : (ft(Jn, Jn.current & 1), r = Sa(r, i, c), r !== null ? r.sibling : null);
        ft(Jn, Jn.current & 1);
        break;
      case 19:
        if (h = (c & i.childLanes) !== 0, r.flags & 128) {
          if (h) return fs(r, i, c);
          i.flags |= 128;
        }
        if (g = i.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), ft(Jn, Jn.current), h) break;
        return null;
      case 22:
      case 23:
        return i.lanes = 0, bc(r, i, c);
    }
    return Sa(r, i, c);
  }
  var Ea, Sr, Uv, Fv;
  Ea = function(r, i) {
    for (var c = i.child; c !== null; ) {
      if (c.tag === 5 || c.tag === 6) r.appendChild(c.stateNode);
      else if (c.tag !== 4 && c.child !== null) {
        c.child.return = c, c = c.child;
        continue;
      }
      if (c === i) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === i) return;
        c = c.return;
      }
      c.sibling.return = c.return, c = c.sibling;
    }
  }, Sr = function() {
  }, Uv = function(r, i, c, h) {
    var g = r.memoizedProps;
    if (g !== h) {
      r = i.stateNode, sl(cs.current);
      var b = null;
      switch (c) {
        case "input":
          g = $n(r, g), h = $n(r, h), b = [];
          break;
        case "select":
          g = ke({}, g, { value: void 0 }), h = ke({}, h, { value: void 0 }), b = [];
          break;
        case "textarea":
          g = Bn(r, g), h = Bn(r, h), b = [];
          break;
        default:
          typeof g.onClick != "function" && typeof h.onClick == "function" && (r.onclick = po);
      }
      xn(c, h);
      var R;
      c = null;
      for (ne in g) if (!h.hasOwnProperty(ne) && g.hasOwnProperty(ne) && g[ne] != null) if (ne === "style") {
        var L = g[ne];
        for (R in L) L.hasOwnProperty(R) && (c || (c = {}), c[R] = "");
      } else ne !== "dangerouslySetInnerHTML" && ne !== "children" && ne !== "suppressContentEditableWarning" && ne !== "suppressHydrationWarning" && ne !== "autoFocus" && (d.hasOwnProperty(ne) ? b || (b = []) : (b = b || []).push(ne, null));
      for (ne in h) {
        var $ = h[ne];
        if (L = g?.[ne], h.hasOwnProperty(ne) && $ !== L && ($ != null || L != null)) if (ne === "style") if (L) {
          for (R in L) !L.hasOwnProperty(R) || $ && $.hasOwnProperty(R) || (c || (c = {}), c[R] = "");
          for (R in $) $.hasOwnProperty(R) && L[R] !== $[R] && (c || (c = {}), c[R] = $[R]);
        } else c || (b || (b = []), b.push(
          ne,
          c
        )), c = $;
        else ne === "dangerouslySetInnerHTML" ? ($ = $ ? $.__html : void 0, L = L ? L.__html : void 0, $ != null && L !== $ && (b = b || []).push(ne, $)) : ne === "children" ? typeof $ != "string" && typeof $ != "number" || (b = b || []).push(ne, "" + $) : ne !== "suppressContentEditableWarning" && ne !== "suppressHydrationWarning" && (d.hasOwnProperty(ne) ? ($ != null && ne === "onScroll" && yn("scroll", r), b || L === $ || (b = [])) : (b = b || []).push(ne, $));
      }
      c && (b = b || []).push("style", c);
      var ne = b;
      (i.updateQueue = ne) && (i.flags |= 4);
    }
  }, Fv = function(r, i, c, h) {
    c !== h && (i.flags |= 4);
  };
  function _c(r, i) {
    if (!Hn) switch (r.tailMode) {
      case "hidden":
        i = r.tail;
        for (var c = null; i !== null; ) i.alternate !== null && (c = i), i = i.sibling;
        c === null ? r.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = r.tail;
        for (var h = null; c !== null; ) c.alternate !== null && (h = c), c = c.sibling;
        h === null ? i || r.tail === null ? r.tail = null : r.tail.sibling = null : h.sibling = null;
    }
  }
  function jr(r) {
    var i = r.alternate !== null && r.alternate.child === r.child, c = 0, h = 0;
    if (i) for (var g = r.child; g !== null; ) c |= g.lanes | g.childLanes, h |= g.subtreeFlags & 14680064, h |= g.flags & 14680064, g.return = r, g = g.sibling;
    else for (g = r.child; g !== null; ) c |= g.lanes | g.childLanes, h |= g.subtreeFlags, h |= g.flags, g.return = r, g = g.sibling;
    return r.subtreeFlags |= h, r.childLanes = c, i;
  }
  function Iv(r, i, c) {
    var h = i.pendingProps;
    switch (kf(i), i.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return jr(i), null;
      case 1:
        return vr(i.type) && ru(), jr(i), null;
      case 3:
        return h = i.stateNode, ol(), Pn(Rr), Pn(tr), mt(), h.pendingContext && (h.context = h.pendingContext, h.pendingContext = null), (r === null || r.child === null) && (Of(i) ? i.flags |= 4 : r === null || r.memoizedState.isDehydrated && !(i.flags & 256) || (i.flags |= 1024, ga !== null && (yl(ga), ga = null))), Sr(r, i), jr(i), null;
      case 5:
        Df(i);
        var g = sl(lc.current);
        if (c = i.type, r !== null && i.stateNode != null) Uv(r, i, c, h, g), r.ref !== i.ref && (i.flags |= 512, i.flags |= 2097152);
        else {
          if (!h) {
            if (i.stateNode === null) throw Error(s(166));
            return jr(i), null;
          }
          if (r = sl(cs.current), Of(i)) {
            h = i.stateNode, c = i.type;
            var b = i.memoizedProps;
            switch (h[as] = i, h[tc] = b, r = (i.mode & 1) !== 0, c) {
              case "dialog":
                yn("cancel", h), yn("close", h);
                break;
              case "iframe":
              case "object":
              case "embed":
                yn("load", h);
                break;
              case "video":
              case "audio":
                for (g = 0; g < Xu.length; g++) yn(Xu[g], h);
                break;
              case "source":
                yn("error", h);
                break;
              case "img":
              case "image":
              case "link":
                yn(
                  "error",
                  h
                ), yn("load", h);
                break;
              case "details":
                yn("toggle", h);
                break;
              case "input":
                Fn(h, b), yn("invalid", h);
                break;
              case "select":
                h._wrapperState = { wasMultiple: !!b.multiple }, yn("invalid", h);
                break;
              case "textarea":
                qn(h, b), yn("invalid", h);
            }
            xn(c, b), g = null;
            for (var R in b) if (b.hasOwnProperty(R)) {
              var L = b[R];
              R === "children" ? typeof L == "string" ? h.textContent !== L && (b.suppressHydrationWarning !== !0 && Ef(h.textContent, L, r), g = ["children", L]) : typeof L == "number" && h.textContent !== "" + L && (b.suppressHydrationWarning !== !0 && Ef(
                h.textContent,
                L,
                r
              ), g = ["children", "" + L]) : d.hasOwnProperty(R) && L != null && R === "onScroll" && yn("scroll", h);
            }
            switch (c) {
              case "input":
                Un(h), wi(h, b, !0);
                break;
              case "textarea":
                Un(h), Tt(h);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof b.onClick == "function" && (h.onclick = po);
            }
            h = g, i.updateQueue = h, h !== null && (i.flags |= 4);
          } else {
            R = g.nodeType === 9 ? g : g.ownerDocument, r === "http://www.w3.org/1999/xhtml" && (r = hr(c)), r === "http://www.w3.org/1999/xhtml" ? c === "script" ? (r = R.createElement("div"), r.innerHTML = "<script><\/script>", r = r.removeChild(r.firstChild)) : typeof h.is == "string" ? r = R.createElement(c, { is: h.is }) : (r = R.createElement(c), c === "select" && (R = r, h.multiple ? R.multiple = !0 : h.size && (R.size = h.size))) : r = R.createElementNS(r, c), r[as] = i, r[tc] = h, Ea(r, i, !1, !1), i.stateNode = r;
            e: {
              switch (R = Xn(c, h), c) {
                case "dialog":
                  yn("cancel", r), yn("close", r), g = h;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  yn("load", r), g = h;
                  break;
                case "video":
                case "audio":
                  for (g = 0; g < Xu.length; g++) yn(Xu[g], r);
                  g = h;
                  break;
                case "source":
                  yn("error", r), g = h;
                  break;
                case "img":
                case "image":
                case "link":
                  yn(
                    "error",
                    r
                  ), yn("load", r), g = h;
                  break;
                case "details":
                  yn("toggle", r), g = h;
                  break;
                case "input":
                  Fn(r, h), g = $n(r, h), yn("invalid", r);
                  break;
                case "option":
                  g = h;
                  break;
                case "select":
                  r._wrapperState = { wasMultiple: !!h.multiple }, g = ke({}, h, { value: void 0 }), yn("invalid", r);
                  break;
                case "textarea":
                  qn(r, h), g = Bn(r, h), yn("invalid", r);
                  break;
                default:
                  g = h;
              }
              xn(c, g), L = g;
              for (b in L) if (L.hasOwnProperty(b)) {
                var $ = L[b];
                b === "style" ? nn(r, $) : b === "dangerouslySetInnerHTML" ? ($ = $ ? $.__html : void 0, $ != null && oa(r, $)) : b === "children" ? typeof $ == "string" ? (c !== "textarea" || $ !== "") && Me(r, $) : typeof $ == "number" && Me(r, "" + $) : b !== "suppressContentEditableWarning" && b !== "suppressHydrationWarning" && b !== "autoFocus" && (d.hasOwnProperty(b) ? $ != null && b === "onScroll" && yn("scroll", r) : $ != null && ve(r, b, $, R));
              }
              switch (c) {
                case "input":
                  Un(r), wi(r, h, !1);
                  break;
                case "textarea":
                  Un(r), Tt(r);
                  break;
                case "option":
                  h.value != null && r.setAttribute("value", "" + ht(h.value));
                  break;
                case "select":
                  r.multiple = !!h.multiple, b = h.value, b != null ? Sn(r, !!h.multiple, b, !1) : h.defaultValue != null && Sn(
                    r,
                    !!h.multiple,
                    h.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof g.onClick == "function" && (r.onclick = po);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  h = !!h.autoFocus;
                  break e;
                case "img":
                  h = !0;
                  break e;
                default:
                  h = !1;
              }
            }
            h && (i.flags |= 4);
          }
          i.ref !== null && (i.flags |= 512, i.flags |= 2097152);
        }
        return jr(i), null;
      case 6:
        if (r && i.stateNode != null) Fv(r, i, r.memoizedProps, h);
        else {
          if (typeof h != "string" && i.stateNode === null) throw Error(s(166));
          if (c = sl(lc.current), sl(cs.current), Of(i)) {
            if (h = i.stateNode, c = i.memoizedProps, h[as] = i, (b = h.nodeValue !== c) && (r = ki, r !== null)) switch (r.tag) {
              case 3:
                Ef(h.nodeValue, c, (r.mode & 1) !== 0);
                break;
              case 5:
                r.memoizedProps.suppressHydrationWarning !== !0 && Ef(h.nodeValue, c, (r.mode & 1) !== 0);
            }
            b && (i.flags |= 4);
          } else h = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(h), h[as] = i, i.stateNode = h;
        }
        return jr(i), null;
      case 13:
        if (Pn(Jn), h = i.memoizedState, r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
          if (Hn && Oi !== null && i.mode & 1 && !(i.flags & 128)) ic(), So(), i.flags |= 98560, b = !1;
          else if (b = Of(i), h !== null && h.dehydrated !== null) {
            if (r === null) {
              if (!b) throw Error(s(318));
              if (b = i.memoizedState, b = b !== null ? b.dehydrated : null, !b) throw Error(s(317));
              b[as] = i;
            } else So(), !(i.flags & 128) && (i.memoizedState = null), i.flags |= 4;
            jr(i), b = !1;
          } else ga !== null && (yl(ga), ga = null), b = !0;
          if (!b) return i.flags & 65536 ? i : null;
        }
        return i.flags & 128 ? (i.lanes = c, i) : (h = h !== null, h !== (r !== null && r.memoizedState !== null) && h && (i.child.flags |= 8192, i.mode & 1 && (r === null || Jn.current & 1 ? lr === 0 && (lr = 3) : lp())), i.updateQueue !== null && (i.flags |= 4), jr(i), null);
      case 4:
        return ol(), Sr(r, i), r === null && Xl(i.stateNode.containerInfo), jr(i), null;
      case 10:
        return Ph(i.type._context), jr(i), null;
      case 17:
        return vr(i.type) && ru(), jr(i), null;
      case 19:
        if (Pn(Jn), b = i.memoizedState, b === null) return jr(i), null;
        if (h = (i.flags & 128) !== 0, R = b.rendering, R === null) if (h) _c(b, !1);
        else {
          if (lr !== 0 || r !== null && r.flags & 128) for (r = i.child; r !== null; ) {
            if (R = Mf(r), R !== null) {
              for (i.flags |= 128, _c(b, !1), h = R.updateQueue, h !== null && (i.updateQueue = h, i.flags |= 4), i.subtreeFlags = 0, h = c, c = i.child; c !== null; ) b = c, r = h, b.flags &= 14680066, R = b.alternate, R === null ? (b.childLanes = 0, b.lanes = r, b.child = null, b.subtreeFlags = 0, b.memoizedProps = null, b.memoizedState = null, b.updateQueue = null, b.dependencies = null, b.stateNode = null) : (b.childLanes = R.childLanes, b.lanes = R.lanes, b.child = R.child, b.subtreeFlags = 0, b.deletions = null, b.memoizedProps = R.memoizedProps, b.memoizedState = R.memoizedState, b.updateQueue = R.updateQueue, b.type = R.type, r = R.dependencies, b.dependencies = r === null ? null : { lanes: r.lanes, firstContext: r.firstContext }), c = c.sibling;
              return ft(Jn, Jn.current & 1 | 2), i.child;
            }
            r = r.sibling;
          }
          b.tail !== null && D() > du && (i.flags |= 128, h = !0, _c(b, !1), i.lanes = 4194304);
        }
        else {
          if (!h) if (r = Mf(R), r !== null) {
            if (i.flags |= 128, h = !0, c = r.updateQueue, c !== null && (i.updateQueue = c, i.flags |= 4), _c(b, !0), b.tail === null && b.tailMode === "hidden" && !R.alternate && !Hn) return jr(i), null;
          } else 2 * D() - b.renderingStartTime > du && c !== 1073741824 && (i.flags |= 128, h = !0, _c(b, !1), i.lanes = 4194304);
          b.isBackwards ? (R.sibling = i.child, i.child = R) : (c = b.last, c !== null ? c.sibling = R : i.child = R, b.last = R);
        }
        return b.tail !== null ? (i = b.tail, b.rendering = i, b.tail = i.sibling, b.renderingStartTime = D(), i.sibling = null, c = Jn.current, ft(Jn, h ? c & 1 | 2 : c & 1), i) : (jr(i), null);
      case 22:
      case 23:
        return op(), h = i.memoizedState !== null, r !== null && r.memoizedState !== null !== h && (i.flags |= 8192), h && i.mode & 1 ? Ki & 1073741824 && (jr(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : jr(i), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(s(156, i.tag));
  }
  function nd(r, i) {
    switch (kf(i), i.tag) {
      case 1:
        return vr(i.type) && ru(), r = i.flags, r & 65536 ? (i.flags = r & -65537 | 128, i) : null;
      case 3:
        return ol(), Pn(Rr), Pn(tr), mt(), r = i.flags, r & 65536 && !(r & 128) ? (i.flags = r & -65537 | 128, i) : null;
      case 5:
        return Df(i), null;
      case 13:
        if (Pn(Jn), r = i.memoizedState, r !== null && r.dehydrated !== null) {
          if (i.alternate === null) throw Error(s(340));
          So();
        }
        return r = i.flags, r & 65536 ? (i.flags = r & -65537 | 128, i) : null;
      case 19:
        return Pn(Jn), null;
      case 4:
        return ol(), null;
      case 10:
        return Ph(i.type._context), null;
      case 22:
      case 23:
        return op(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var xc = !1, ni = !1, M0 = typeof WeakSet == "function" ? WeakSet : Set, Xe = null;
  function uu(r, i) {
    var c = r.ref;
    if (c !== null) if (typeof c == "function") try {
      c(null);
    } catch (h) {
      Vn(r, i, h);
    }
    else c.current = null;
  }
  function rd(r, i, c) {
    try {
      c();
    } catch (h) {
      Vn(r, i, h);
    }
  }
  var zv = !1;
  function $v(r, i) {
    if (ec = da, r = Qu(), hf(r)) {
      if ("selectionStart" in r) var c = { start: r.selectionStart, end: r.selectionEnd };
      else e: {
        c = (c = r.ownerDocument) && c.defaultView || window;
        var h = c.getSelection && c.getSelection();
        if (h && h.rangeCount !== 0) {
          c = h.anchorNode;
          var g = h.anchorOffset, b = h.focusNode;
          h = h.focusOffset;
          try {
            c.nodeType, b.nodeType;
          } catch {
            c = null;
            break e;
          }
          var R = 0, L = -1, $ = -1, ne = 0, we = 0, _e = r, Ee = null;
          t: for (; ; ) {
            for (var Ge; _e !== c || g !== 0 && _e.nodeType !== 3 || (L = R + g), _e !== b || h !== 0 && _e.nodeType !== 3 || ($ = R + h), _e.nodeType === 3 && (R += _e.nodeValue.length), (Ge = _e.firstChild) !== null; )
              Ee = _e, _e = Ge;
            for (; ; ) {
              if (_e === r) break t;
              if (Ee === c && ++ne === g && (L = R), Ee === b && ++we === h && ($ = R), (Ge = _e.nextSibling) !== null) break;
              _e = Ee, Ee = _e.parentNode;
            }
            _e = Ge;
          }
          c = L === -1 || $ === -1 ? null : { start: L, end: $ };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (el = { focusedElem: r, selectionRange: c }, da = !1, Xe = i; Xe !== null; ) if (i = Xe, r = i.child, (i.subtreeFlags & 1028) !== 0 && r !== null) r.return = i, Xe = r;
    else for (; Xe !== null; ) {
      i = Xe;
      try {
        var et = i.alternate;
        if (i.flags & 1024) switch (i.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (et !== null) {
              var rt = et.memoizedProps, ur = et.memoizedState, G = i.stateNode, V = G.getSnapshotBeforeUpdate(i.elementType === i.type ? rt : $a(i.type, rt), ur);
              G.__reactInternalSnapshotBeforeUpdate = V;
            }
            break;
          case 3:
            var X = i.stateNode.containerInfo;
            X.nodeType === 1 ? X.textContent = "" : X.nodeType === 9 && X.documentElement && X.removeChild(X.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(s(163));
        }
      } catch (Oe) {
        Vn(i, i.return, Oe);
      }
      if (r = i.sibling, r !== null) {
        r.return = i.return, Xe = r;
        break;
      }
      Xe = i.return;
    }
    return et = zv, zv = !1, et;
  }
  function Cc(r, i, c) {
    var h = i.updateQueue;
    if (h = h !== null ? h.lastEffect : null, h !== null) {
      var g = h = h.next;
      do {
        if ((g.tag & r) === r) {
          var b = g.destroy;
          g.destroy = void 0, b !== void 0 && rd(i, c, b);
        }
        g = g.next;
      } while (g !== h);
    }
  }
  function Rc(r, i) {
    if (i = i.updateQueue, i = i !== null ? i.lastEffect : null, i !== null) {
      var c = i = i.next;
      do {
        if ((c.tag & r) === r) {
          var h = c.create;
          c.destroy = h();
        }
        c = c.next;
      } while (c !== i);
    }
  }
  function ep(r) {
    var i = r.ref;
    if (i !== null) {
      var c = r.stateNode;
      switch (r.tag) {
        case 5:
          r = c;
          break;
        default:
          r = c;
      }
      typeof i == "function" ? i(r) : i.current = r;
    }
  }
  function id(r) {
    var i = r.alternate;
    i !== null && (r.alternate = null, id(i)), r.child = null, r.deletions = null, r.sibling = null, r.tag === 5 && (i = r.stateNode, i !== null && (delete i[as], delete i[tc], delete i[nc], delete i[nu], delete i[A0])), r.stateNode = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
  }
  function Tc(r) {
    return r.tag === 5 || r.tag === 3 || r.tag === 4;
  }
  function Is(r) {
    e: for (; ; ) {
      for (; r.sibling === null; ) {
        if (r.return === null || Tc(r.return)) return null;
        r = r.return;
      }
      for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
        if (r.flags & 2 || r.child === null || r.tag === 4) continue e;
        r.child.return = r, r = r.child;
      }
      if (!(r.flags & 2)) return r.stateNode;
    }
  }
  function ds(r, i, c) {
    var h = r.tag;
    if (h === 5 || h === 6) r = r.stateNode, i ? c.nodeType === 8 ? c.parentNode.insertBefore(r, i) : c.insertBefore(r, i) : (c.nodeType === 8 ? (i = c.parentNode, i.insertBefore(r, c)) : (i = c, i.appendChild(r)), c = c._reactRootContainer, c != null || i.onclick !== null || (i.onclick = po));
    else if (h !== 4 && (r = r.child, r !== null)) for (ds(r, i, c), r = r.sibling; r !== null; ) ds(r, i, c), r = r.sibling;
  }
  function hs(r, i, c) {
    var h = r.tag;
    if (h === 5 || h === 6) r = r.stateNode, i ? c.insertBefore(r, i) : c.appendChild(r);
    else if (h !== 4 && (r = r.child, r !== null)) for (hs(r, i, c), r = r.sibling; r !== null; ) hs(r, i, c), r = r.sibling;
  }
  var or = null, ui = !1;
  function ci(r, i, c) {
    for (c = c.child; c !== null; ) Bv(r, i, c), c = c.sibling;
  }
  function Bv(r, i, c) {
    if (xt && typeof xt.onCommitFiberUnmount == "function") try {
      xt.onCommitFiberUnmount(qe, c);
    } catch {
    }
    switch (c.tag) {
      case 5:
        ni || uu(c, i);
      case 6:
        var h = or, g = ui;
        or = null, ci(r, i, c), or = h, ui = g, or !== null && (ui ? (r = or, c = c.stateNode, r.nodeType === 8 ? r.parentNode.removeChild(c) : r.removeChild(c)) : or.removeChild(c.stateNode));
        break;
      case 18:
        or !== null && (ui ? (r = or, c = c.stateNode, r.nodeType === 8 ? tu(r.parentNode, c) : r.nodeType === 1 && tu(r, c), La(r)) : tu(or, c.stateNode));
        break;
      case 4:
        h = or, g = ui, or = c.stateNode.containerInfo, ui = !0, ci(r, i, c), or = h, ui = g;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!ni && (h = c.updateQueue, h !== null && (h = h.lastEffect, h !== null))) {
          g = h = h.next;
          do {
            var b = g, R = b.destroy;
            b = b.tag, R !== void 0 && (b & 2 || b & 4) && rd(c, i, R), g = g.next;
          } while (g !== h);
        }
        ci(r, i, c);
        break;
      case 1:
        if (!ni && (uu(c, i), h = c.stateNode, typeof h.componentWillUnmount == "function")) try {
          h.props = c.memoizedProps, h.state = c.memoizedState, h.componentWillUnmount();
        } catch (L) {
          Vn(c, i, L);
        }
        ci(r, i, c);
        break;
      case 21:
        ci(r, i, c);
        break;
      case 22:
        c.mode & 1 ? (ni = (h = ni) || c.memoizedState !== null, ci(r, i, c), ni = h) : ci(r, i, c);
        break;
      default:
        ci(r, i, c);
    }
  }
  function Hv(r) {
    var i = r.updateQueue;
    if (i !== null) {
      r.updateQueue = null;
      var c = r.stateNode;
      c === null && (c = r.stateNode = new M0()), i.forEach(function(h) {
        var g = Xv.bind(null, r, h);
        c.has(h) || (c.add(h), h.then(g, g));
      });
    }
  }
  function Ba(r, i) {
    var c = i.deletions;
    if (c !== null) for (var h = 0; h < c.length; h++) {
      var g = c[h];
      try {
        var b = r, R = i, L = R;
        e: for (; L !== null; ) {
          switch (L.tag) {
            case 5:
              or = L.stateNode, ui = !1;
              break e;
            case 3:
              or = L.stateNode.containerInfo, ui = !0;
              break e;
            case 4:
              or = L.stateNode.containerInfo, ui = !0;
              break e;
          }
          L = L.return;
        }
        if (or === null) throw Error(s(160));
        Bv(b, R, g), or = null, ui = !1;
        var $ = g.alternate;
        $ !== null && ($.return = null), g.return = null;
      } catch (ne) {
        Vn(g, i, ne);
      }
    }
    if (i.subtreeFlags & 12854) for (i = i.child; i !== null; ) tp(i, r), i = i.sibling;
  }
  function tp(r, i) {
    var c = r.alternate, h = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Ba(i, r), Di(r), h & 4) {
          try {
            Cc(3, r, r.return), Rc(3, r);
          } catch (rt) {
            Vn(r, r.return, rt);
          }
          try {
            Cc(5, r, r.return);
          } catch (rt) {
            Vn(r, r.return, rt);
          }
        }
        break;
      case 1:
        Ba(i, r), Di(r), h & 512 && c !== null && uu(c, c.return);
        break;
      case 5:
        if (Ba(i, r), Di(r), h & 512 && c !== null && uu(c, c.return), r.flags & 32) {
          var g = r.stateNode;
          try {
            Me(g, "");
          } catch (rt) {
            Vn(r, r.return, rt);
          }
        }
        if (h & 4 && (g = r.stateNode, g != null)) {
          var b = r.memoizedProps, R = c !== null ? c.memoizedProps : b, L = r.type, $ = r.updateQueue;
          if (r.updateQueue = null, $ !== null) try {
            L === "input" && b.type === "radio" && b.name != null && jn(g, b), Xn(L, R);
            var ne = Xn(L, b);
            for (R = 0; R < $.length; R += 2) {
              var we = $[R], _e = $[R + 1];
              we === "style" ? nn(g, _e) : we === "dangerouslySetInnerHTML" ? oa(g, _e) : we === "children" ? Me(g, _e) : ve(g, we, _e, ne);
            }
            switch (L) {
              case "input":
                xr(g, b);
                break;
              case "textarea":
                We(g, b);
                break;
              case "select":
                var Ee = g._wrapperState.wasMultiple;
                g._wrapperState.wasMultiple = !!b.multiple;
                var Ge = b.value;
                Ge != null ? Sn(g, !!b.multiple, Ge, !1) : Ee !== !!b.multiple && (b.defaultValue != null ? Sn(
                  g,
                  !!b.multiple,
                  b.defaultValue,
                  !0
                ) : Sn(g, !!b.multiple, b.multiple ? [] : "", !1));
            }
            g[tc] = b;
          } catch (rt) {
            Vn(r, r.return, rt);
          }
        }
        break;
      case 6:
        if (Ba(i, r), Di(r), h & 4) {
          if (r.stateNode === null) throw Error(s(162));
          g = r.stateNode, b = r.memoizedProps;
          try {
            g.nodeValue = b;
          } catch (rt) {
            Vn(r, r.return, rt);
          }
        }
        break;
      case 3:
        if (Ba(i, r), Di(r), h & 4 && c !== null && c.memoizedState.isDehydrated) try {
          La(i.containerInfo);
        } catch (rt) {
          Vn(r, r.return, rt);
        }
        break;
      case 4:
        Ba(i, r), Di(r);
        break;
      case 13:
        Ba(i, r), Di(r), g = r.child, g.flags & 8192 && (b = g.memoizedState !== null, g.stateNode.isHidden = b, !b || g.alternate !== null && g.alternate.memoizedState !== null || (ip = D())), h & 4 && Hv(r);
        break;
      case 22:
        if (we = c !== null && c.memoizedState !== null, r.mode & 1 ? (ni = (ne = ni) || we, Ba(i, r), ni = ne) : Ba(i, r), Di(r), h & 8192) {
          if (ne = r.memoizedState !== null, (r.stateNode.isHidden = ne) && !we && r.mode & 1) for (Xe = r, we = r.child; we !== null; ) {
            for (_e = Xe = we; Xe !== null; ) {
              switch (Ee = Xe, Ge = Ee.child, Ee.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Cc(4, Ee, Ee.return);
                  break;
                case 1:
                  uu(Ee, Ee.return);
                  var et = Ee.stateNode;
                  if (typeof et.componentWillUnmount == "function") {
                    h = Ee, c = Ee.return;
                    try {
                      i = h, et.props = i.memoizedProps, et.state = i.memoizedState, et.componentWillUnmount();
                    } catch (rt) {
                      Vn(h, c, rt);
                    }
                  }
                  break;
                case 5:
                  uu(Ee, Ee.return);
                  break;
                case 22:
                  if (Ee.memoizedState !== null) {
                    kc(_e);
                    continue;
                  }
              }
              Ge !== null ? (Ge.return = Ee, Xe = Ge) : kc(_e);
            }
            we = we.sibling;
          }
          e: for (we = null, _e = r; ; ) {
            if (_e.tag === 5) {
              if (we === null) {
                we = _e;
                try {
                  g = _e.stateNode, ne ? (b = g.style, typeof b.setProperty == "function" ? b.setProperty("display", "none", "important") : b.display = "none") : (L = _e.stateNode, $ = _e.memoizedProps.style, R = $ != null && $.hasOwnProperty("display") ? $.display : null, L.style.display = sn("display", R));
                } catch (rt) {
                  Vn(r, r.return, rt);
                }
              }
            } else if (_e.tag === 6) {
              if (we === null) try {
                _e.stateNode.nodeValue = ne ? "" : _e.memoizedProps;
              } catch (rt) {
                Vn(r, r.return, rt);
              }
            } else if ((_e.tag !== 22 && _e.tag !== 23 || _e.memoizedState === null || _e === r) && _e.child !== null) {
              _e.child.return = _e, _e = _e.child;
              continue;
            }
            if (_e === r) break e;
            for (; _e.sibling === null; ) {
              if (_e.return === null || _e.return === r) break e;
              we === _e && (we = null), _e = _e.return;
            }
            we === _e && (we = null), _e.sibling.return = _e.return, _e = _e.sibling;
          }
        }
        break;
      case 19:
        Ba(i, r), Di(r), h & 4 && Hv(r);
        break;
      case 21:
        break;
      default:
        Ba(
          i,
          r
        ), Di(r);
    }
  }
  function Di(r) {
    var i = r.flags;
    if (i & 2) {
      try {
        e: {
          for (var c = r.return; c !== null; ) {
            if (Tc(c)) {
              var h = c;
              break e;
            }
            c = c.return;
          }
          throw Error(s(160));
        }
        switch (h.tag) {
          case 5:
            var g = h.stateNode;
            h.flags & 32 && (Me(g, ""), h.flags &= -33);
            var b = Is(r);
            hs(r, b, g);
            break;
          case 3:
          case 4:
            var R = h.stateNode.containerInfo, L = Is(r);
            ds(r, L, R);
            break;
          default:
            throw Error(s(161));
        }
      } catch ($) {
        Vn(r, r.return, $);
      }
      r.flags &= -3;
    }
    i & 4096 && (r.flags &= -4097);
  }
  function j0(r, i, c) {
    Xe = r, np(r);
  }
  function np(r, i, c) {
    for (var h = (r.mode & 1) !== 0; Xe !== null; ) {
      var g = Xe, b = g.child;
      if (g.tag === 22 && h) {
        var R = g.memoizedState !== null || xc;
        if (!R) {
          var L = g.alternate, $ = L !== null && L.memoizedState !== null || ni;
          L = xc;
          var ne = ni;
          if (xc = R, (ni = $) && !ne) for (Xe = g; Xe !== null; ) R = Xe, $ = R.child, R.tag === 22 && R.memoizedState !== null ? rp(g) : $ !== null ? ($.return = R, Xe = $) : rp(g);
          for (; b !== null; ) Xe = b, np(b), b = b.sibling;
          Xe = g, xc = L, ni = ne;
        }
        Vv(r);
      } else g.subtreeFlags & 8772 && b !== null ? (b.return = g, Xe = b) : Vv(r);
    }
  }
  function Vv(r) {
    for (; Xe !== null; ) {
      var i = Xe;
      if (i.flags & 8772) {
        var c = i.alternate;
        try {
          if (i.flags & 8772) switch (i.tag) {
            case 0:
            case 11:
            case 15:
              ni || Rc(5, i);
              break;
            case 1:
              var h = i.stateNode;
              if (i.flags & 4 && !ni) if (c === null) h.componentDidMount();
              else {
                var g = i.elementType === i.type ? c.memoizedProps : $a(i.type, c.memoizedProps);
                h.componentDidUpdate(g, c.memoizedState, h.__reactInternalSnapshotBeforeUpdate);
              }
              var b = i.updateQueue;
              b !== null && $h(i, b, h);
              break;
            case 3:
              var R = i.updateQueue;
              if (R !== null) {
                if (c = null, i.child !== null) switch (i.child.tag) {
                  case 5:
                    c = i.child.stateNode;
                    break;
                  case 1:
                    c = i.child.stateNode;
                }
                $h(i, R, c);
              }
              break;
            case 5:
              var L = i.stateNode;
              if (c === null && i.flags & 4) {
                c = L;
                var $ = i.memoizedProps;
                switch (i.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    $.autoFocus && c.focus();
                    break;
                  case "img":
                    $.src && (c.src = $.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (i.memoizedState === null) {
                var ne = i.alternate;
                if (ne !== null) {
                  var we = ne.memoizedState;
                  if (we !== null) {
                    var _e = we.dehydrated;
                    _e !== null && La(_e);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(s(163));
          }
          ni || i.flags & 512 && ep(i);
        } catch (Ee) {
          Vn(i, i.return, Ee);
        }
      }
      if (i === r) {
        Xe = null;
        break;
      }
      if (c = i.sibling, c !== null) {
        c.return = i.return, Xe = c;
        break;
      }
      Xe = i.return;
    }
  }
  function kc(r) {
    for (; Xe !== null; ) {
      var i = Xe;
      if (i === r) {
        Xe = null;
        break;
      }
      var c = i.sibling;
      if (c !== null) {
        c.return = i.return, Xe = c;
        break;
      }
      Xe = i.return;
    }
  }
  function rp(r) {
    for (; Xe !== null; ) {
      var i = Xe;
      try {
        switch (i.tag) {
          case 0:
          case 11:
          case 15:
            var c = i.return;
            try {
              Rc(4, i);
            } catch ($) {
              Vn(i, c, $);
            }
            break;
          case 1:
            var h = i.stateNode;
            if (typeof h.componentDidMount == "function") {
              var g = i.return;
              try {
                h.componentDidMount();
              } catch ($) {
                Vn(i, g, $);
              }
            }
            var b = i.return;
            try {
              ep(i);
            } catch ($) {
              Vn(i, b, $);
            }
            break;
          case 5:
            var R = i.return;
            try {
              ep(i);
            } catch ($) {
              Vn(i, R, $);
            }
        }
      } catch ($) {
        Vn(i, i.return, $);
      }
      if (i === r) {
        Xe = null;
        break;
      }
      var L = i.sibling;
      if (L !== null) {
        L.return = i.return, Xe = L;
        break;
      }
      Xe = i.return;
    }
  }
  var L0 = Math.ceil, Co = De.ReactCurrentDispatcher, vl = De.ReactCurrentOwner, Hr = De.ReactCurrentBatchConfig, Zt = 0, kr = null, Er = null, Vr = 0, Ki = 0, cu = Ia(0), lr = 0, Oc = null, ps = 0, fu = 0, ad = 0, Nc = null, Mi = null, ip = 0, du = 1 / 0, Xi = null, hu = !1, gl = null, Ro = null, sd = !1, zs = null, Ac = 0, To = 0, pu = null, Dc = -1, ri = 0;
  function wr() {
    return Zt & 6 ? D() : Dc !== -1 ? Dc : Dc = D();
  }
  function ms(r) {
    return r.mode & 1 ? Zt & 2 && Vr !== 0 ? Vr & -Vr : D0.transition !== null ? (ri === 0 && (ri = zl()), ri) : (r = cn, r !== 0 || (r = window.event, r = r === void 0 ? 16 : Wl(r.type)), r) : 1;
  }
  function fi(r, i, c, h) {
    if (50 < To) throw To = 0, pu = null, Error(s(185));
    Ts(r, c, h), (!(Zt & 2) || r !== kr) && (r === kr && (!(Zt & 2) && (fu |= c), lr === 4 && Ha(r, Vr)), ji(r, h), c === 1 && Zt === 0 && !(i.mode & 1) && (du = D() + 500, iu && os()));
  }
  function ji(r, i) {
    var c = r.callbackNode;
    qo(r, i);
    var h = ja(r, r === kr ? Vr : 0);
    if (h === 0) c !== null && T(c), r.callbackNode = null, r.callbackPriority = 0;
    else if (i = h & -h, r.callbackPriority !== i) {
      if (c != null && T(c), i === 1) r.tag === 0 ? vo(ap.bind(null, r)) : Rf(ap.bind(null, r)), eu(function() {
        !(Zt & 6) && os();
      }), c = null;
      else {
        switch (Bl(h)) {
          case 1:
            c = W;
            break;
          case 4:
            c = he;
            break;
          case 16:
            c = ge;
            break;
          case 536870912:
            c = de;
            break;
          default:
            c = ge;
        }
        c = eg(c, od.bind(null, r));
      }
      r.callbackPriority = i, r.callbackNode = c;
    }
  }
  function od(r, i) {
    if (Dc = -1, ri = 0, Zt & 6) throw Error(s(327));
    var c = r.callbackNode;
    if (mu() && r.callbackNode !== c) return null;
    var h = ja(r, r === kr ? Vr : 0);
    if (h === 0) return null;
    if (h & 30 || h & r.expiredLanes || i) i = ld(r, h);
    else {
      i = h;
      var g = Zt;
      Zt |= 2;
      var b = Yv();
      (kr !== r || Vr !== i) && (Xi = null, du = D() + 500, $s(r, i));
      do
        try {
          Wv();
          break;
        } catch (L) {
          qv(r, L);
        }
      while (!0);
      Lh(), Co.current = b, Zt = g, Er !== null ? i = 0 : (kr = null, Vr = 0, i = lr);
    }
    if (i !== 0) {
      if (i === 2 && (g = so(r), g !== 0 && (h = g, i = Mc(r, g))), i === 1) throw c = Oc, $s(r, 0), Ha(r, h), ji(r, D()), c;
      if (i === 6) Ha(r, h);
      else {
        if (g = r.current.alternate, !(h & 30) && !P0(g) && (i = ld(r, h), i === 2 && (b = so(r), b !== 0 && (h = b, i = Mc(r, b))), i === 1)) throw c = Oc, $s(r, 0), Ha(r, h), ji(r, D()), c;
        switch (r.finishedWork = g, r.finishedLanes = h, i) {
          case 0:
          case 1:
            throw Error(s(345));
          case 2:
            Sl(r, Mi, Xi);
            break;
          case 3:
            if (Ha(r, h), (h & 130023424) === h && (i = ip + 500 - D(), 10 < i)) {
              if (ja(r, 0) !== 0) break;
              if (g = r.suspendedLanes, (g & h) !== h) {
                wr(), r.pingedLanes |= r.suspendedLanes & g;
                break;
              }
              r.timeoutHandle = _f(Sl.bind(null, r, Mi, Xi), i);
              break;
            }
            Sl(r, Mi, Xi);
            break;
          case 4:
            if (Ha(r, h), (h & 4194240) === h) break;
            for (i = r.eventTimes, g = -1; 0 < h; ) {
              var R = 31 - Dn(h);
              b = 1 << R, R = i[R], R > g && (g = R), h &= ~b;
            }
            if (h = g, h = D() - h, h = (120 > h ? 120 : 480 > h ? 480 : 1080 > h ? 1080 : 1920 > h ? 1920 : 3e3 > h ? 3e3 : 4320 > h ? 4320 : 1960 * L0(h / 1960)) - h, 10 < h) {
              r.timeoutHandle = _f(Sl.bind(null, r, Mi, Xi), h);
              break;
            }
            Sl(r, Mi, Xi);
            break;
          case 5:
            Sl(r, Mi, Xi);
            break;
          default:
            throw Error(s(329));
        }
      }
    }
    return ji(r, D()), r.callbackNode === c ? od.bind(null, r) : null;
  }
  function Mc(r, i) {
    var c = Nc;
    return r.current.memoizedState.isDehydrated && ($s(r, i).flags |= 256), r = ld(r, i), r !== 2 && (i = Mi, Mi = c, i !== null && yl(i)), r;
  }
  function yl(r) {
    Mi === null ? Mi = r : Mi.push.apply(Mi, r);
  }
  function P0(r) {
    for (var i = r; ; ) {
      if (i.flags & 16384) {
        var c = i.updateQueue;
        if (c !== null && (c = c.stores, c !== null)) for (var h = 0; h < c.length; h++) {
          var g = c[h], b = g.getSnapshot;
          g = g.value;
          try {
            if (!Ua(b(), g)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (c = i.child, i.subtreeFlags & 16384 && c !== null) c.return = i, i = c;
      else {
        if (i === r) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === r) return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function Ha(r, i) {
    for (i &= ~ad, i &= ~fu, r.suspendedLanes |= i, r.pingedLanes &= ~i, r = r.expirationTimes; 0 < i; ) {
      var c = 31 - Dn(i), h = 1 << c;
      r[c] = -1, i &= ~h;
    }
  }
  function ap(r) {
    if (Zt & 6) throw Error(s(327));
    mu();
    var i = ja(r, 0);
    if (!(i & 1)) return ji(r, D()), null;
    var c = ld(r, i);
    if (r.tag !== 0 && c === 2) {
      var h = so(r);
      h !== 0 && (i = h, c = Mc(r, h));
    }
    if (c === 1) throw c = Oc, $s(r, 0), Ha(r, i), ji(r, D()), c;
    if (c === 6) throw Error(s(345));
    return r.finishedWork = r.current.alternate, r.finishedLanes = i, Sl(r, Mi, Xi), ji(r, D()), null;
  }
  function sp(r, i) {
    var c = Zt;
    Zt |= 1;
    try {
      return r(i);
    } finally {
      Zt = c, Zt === 0 && (du = D() + 500, iu && os());
    }
  }
  function bl(r) {
    zs !== null && zs.tag === 0 && !(Zt & 6) && mu();
    var i = Zt;
    Zt |= 1;
    var c = Hr.transition, h = cn;
    try {
      if (Hr.transition = null, cn = 1, r) return r();
    } finally {
      cn = h, Hr.transition = c, Zt = i, !(Zt & 6) && os();
    }
  }
  function op() {
    Ki = cu.current, Pn(cu);
  }
  function $s(r, i) {
    r.finishedWork = null, r.finishedLanes = 0;
    var c = r.timeoutHandle;
    if (c !== -1 && (r.timeoutHandle = -1, Nh(c)), Er !== null) for (c = Er.return; c !== null; ) {
      var h = c;
      switch (kf(h), h.tag) {
        case 1:
          h = h.type.childContextTypes, h != null && ru();
          break;
        case 3:
          ol(), Pn(Rr), Pn(tr), mt();
          break;
        case 5:
          Df(h);
          break;
        case 4:
          ol();
          break;
        case 13:
          Pn(Jn);
          break;
        case 19:
          Pn(Jn);
          break;
        case 10:
          Ph(h.type._context);
          break;
        case 22:
        case 23:
          op();
      }
      c = c.return;
    }
    if (kr = r, Er = r = ko(r.current, null), Vr = Ki = i, lr = 0, Oc = null, ad = fu = ps = 0, Mi = Nc = null, al !== null) {
      for (i = 0; i < al.length; i++) if (c = al[i], h = c.interleaved, h !== null) {
        c.interleaved = null;
        var g = h.next, b = c.pending;
        if (b !== null) {
          var R = b.next;
          b.next = g, h.next = R;
        }
        c.pending = h;
      }
      al = null;
    }
    return r;
  }
  function qv(r, i) {
    do {
      var c = Er;
      try {
        if (Lh(), qt.current = hl, jf) {
          for (var h = dn.memoizedState; h !== null; ) {
            var g = h.queue;
            g !== null && (g.pending = null), h = h.next;
          }
          jf = !1;
        }
        if (On = 0, Mr = yr = dn = null, cc = !1, ll = 0, vl.current = null, c === null || c.return === null) {
          lr = 1, Oc = i, Er = null;
          break;
        }
        e: {
          var b = r, R = c.return, L = c, $ = i;
          if (i = Vr, L.flags |= 32768, $ !== null && typeof $ == "object" && typeof $.then == "function") {
            var ne = $, we = L, _e = we.tag;
            if (!(we.mode & 1) && (_e === 0 || _e === 11 || _e === 15)) {
              var Ee = we.alternate;
              Ee ? (we.updateQueue = Ee.updateQueue, we.memoizedState = Ee.memoizedState, we.lanes = Ee.lanes) : (we.updateQueue = null, we.memoizedState = null);
            }
            var Ge = Dv(R);
            if (Ge !== null) {
              Ge.flags &= -257, xo(Ge, R, L, b, i), Ge.mode & 1 && Jh(b, ne, i), i = Ge, $ = ne;
              var et = i.updateQueue;
              if (et === null) {
                var rt = /* @__PURE__ */ new Set();
                rt.add($), i.updateQueue = rt;
              } else et.add($);
              break e;
            } else {
              if (!(i & 1)) {
                Jh(b, ne, i), lp();
                break e;
              }
              $ = Error(s(426));
            }
          } else if (Hn && L.mode & 1) {
            var ur = Dv(R);
            if (ur !== null) {
              !(ur.flags & 65536) && (ur.flags |= 256), xo(ur, R, L, b, i), Ps(pl($, L));
              break e;
            }
          }
          b = $ = pl($, L), lr !== 4 && (lr = 2), Nc === null ? Nc = [b] : Nc.push(b), b = R;
          do {
            switch (b.tag) {
              case 3:
                b.flags |= 65536, i &= -i, b.lanes |= i;
                var G = Av(b, $, i);
                Rv(b, G);
                break e;
              case 1:
                L = $;
                var V = b.type, X = b.stateNode;
                if (!(b.flags & 128) && (typeof V.getDerivedStateFromError == "function" || X !== null && typeof X.componentDidCatch == "function" && (Ro === null || !Ro.has(X)))) {
                  b.flags |= 65536, i &= -i, b.lanes |= i;
                  var Oe = Gh(b, L, i);
                  Rv(b, Oe);
                  break e;
                }
            }
            b = b.return;
          } while (b !== null);
        }
        Jv(c);
      } catch (Be) {
        i = Be, Er === c && c !== null && (Er = c = c.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Yv() {
    var r = Co.current;
    return Co.current = hl, r === null ? hl : r;
  }
  function lp() {
    (lr === 0 || lr === 3 || lr === 2) && (lr = 4), kr === null || !(ps & 268435455) && !(fu & 268435455) || Ha(kr, Vr);
  }
  function ld(r, i) {
    var c = Zt;
    Zt |= 2;
    var h = Yv();
    (kr !== r || Vr !== i) && (Xi = null, $s(r, i));
    do
      try {
        U0();
        break;
      } catch (g) {
        qv(r, g);
      }
    while (!0);
    if (Lh(), Zt = c, Co.current = h, Er !== null) throw Error(s(261));
    return kr = null, Vr = 0, lr;
  }
  function U0() {
    for (; Er !== null; ) Gv(Er);
  }
  function Wv() {
    for (; Er !== null && !j(); ) Gv(Er);
  }
  function Gv(r) {
    var i = Zv(r.alternate, r, Ki);
    r.memoizedProps = r.pendingProps, i === null ? Jv(r) : Er = i, vl.current = null;
  }
  function Jv(r) {
    var i = r;
    do {
      var c = i.alternate;
      if (r = i.return, i.flags & 32768) {
        if (c = nd(c, i), c !== null) {
          c.flags &= 32767, Er = c;
          return;
        }
        if (r !== null) r.flags |= 32768, r.subtreeFlags = 0, r.deletions = null;
        else {
          lr = 6, Er = null;
          return;
        }
      } else if (c = Iv(c, i, Ki), c !== null) {
        Er = c;
        return;
      }
      if (i = i.sibling, i !== null) {
        Er = i;
        return;
      }
      Er = i = r;
    } while (i !== null);
    lr === 0 && (lr = 5);
  }
  function Sl(r, i, c) {
    var h = cn, g = Hr.transition;
    try {
      Hr.transition = null, cn = 1, F0(r, i, c, h);
    } finally {
      Hr.transition = g, cn = h;
    }
    return null;
  }
  function F0(r, i, c, h) {
    do
      mu();
    while (zs !== null);
    if (Zt & 6) throw Error(s(327));
    c = r.finishedWork;
    var g = r.finishedLanes;
    if (c === null) return null;
    if (r.finishedWork = null, r.finishedLanes = 0, c === r.current) throw Error(s(177));
    r.callbackNode = null, r.callbackPriority = 0;
    var b = c.lanes | c.childLanes;
    if (uh(r, b), r === kr && (Er = kr = null, Vr = 0), !(c.subtreeFlags & 2064) && !(c.flags & 2064) || sd || (sd = !0, eg(ge, function() {
      return mu(), null;
    })), b = (c.flags & 15990) !== 0, c.subtreeFlags & 15990 || b) {
      b = Hr.transition, Hr.transition = null;
      var R = cn;
      cn = 1;
      var L = Zt;
      Zt |= 4, vl.current = null, $v(r, c), tp(c, r), Ql(el), da = !!ec, el = ec = null, r.current = c, j0(c), A(), Zt = L, cn = R, Hr.transition = b;
    } else r.current = c;
    if (sd && (sd = !1, zs = r, Ac = g), b = r.pendingLanes, b === 0 && (Ro = null), En(c.stateNode), ji(r, D()), i !== null) for (h = r.onRecoverableError, c = 0; c < i.length; c++) g = i[c], h(g.value, { componentStack: g.stack, digest: g.digest });
    if (hu) throw hu = !1, r = gl, gl = null, r;
    return Ac & 1 && r.tag !== 0 && mu(), b = r.pendingLanes, b & 1 ? r === pu ? To++ : (To = 0, pu = r) : To = 0, os(), null;
  }
  function mu() {
    if (zs !== null) {
      var r = Bl(Ac), i = Hr.transition, c = cn;
      try {
        if (Hr.transition = null, cn = 16 > r ? 16 : r, zs === null) var h = !1;
        else {
          if (r = zs, zs = null, Ac = 0, Zt & 6) throw Error(s(331));
          var g = Zt;
          for (Zt |= 4, Xe = r.current; Xe !== null; ) {
            var b = Xe, R = b.child;
            if (Xe.flags & 16) {
              var L = b.deletions;
              if (L !== null) {
                for (var $ = 0; $ < L.length; $++) {
                  var ne = L[$];
                  for (Xe = ne; Xe !== null; ) {
                    var we = Xe;
                    switch (we.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Cc(8, we, b);
                    }
                    var _e = we.child;
                    if (_e !== null) _e.return = we, Xe = _e;
                    else for (; Xe !== null; ) {
                      we = Xe;
                      var Ee = we.sibling, Ge = we.return;
                      if (id(we), we === ne) {
                        Xe = null;
                        break;
                      }
                      if (Ee !== null) {
                        Ee.return = Ge, Xe = Ee;
                        break;
                      }
                      Xe = Ge;
                    }
                  }
                }
                var et = b.alternate;
                if (et !== null) {
                  var rt = et.child;
                  if (rt !== null) {
                    et.child = null;
                    do {
                      var ur = rt.sibling;
                      rt.sibling = null, rt = ur;
                    } while (rt !== null);
                  }
                }
                Xe = b;
              }
            }
            if (b.subtreeFlags & 2064 && R !== null) R.return = b, Xe = R;
            else e: for (; Xe !== null; ) {
              if (b = Xe, b.flags & 2048) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  Cc(9, b, b.return);
              }
              var G = b.sibling;
              if (G !== null) {
                G.return = b.return, Xe = G;
                break e;
              }
              Xe = b.return;
            }
          }
          var V = r.current;
          for (Xe = V; Xe !== null; ) {
            R = Xe;
            var X = R.child;
            if (R.subtreeFlags & 2064 && X !== null) X.return = R, Xe = X;
            else e: for (R = V; Xe !== null; ) {
              if (L = Xe, L.flags & 2048) try {
                switch (L.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Rc(9, L);
                }
              } catch (Be) {
                Vn(L, L.return, Be);
              }
              if (L === R) {
                Xe = null;
                break e;
              }
              var Oe = L.sibling;
              if (Oe !== null) {
                Oe.return = L.return, Xe = Oe;
                break e;
              }
              Xe = L.return;
            }
          }
          if (Zt = g, os(), xt && typeof xt.onPostCommitFiberRoot == "function") try {
            xt.onPostCommitFiberRoot(qe, r);
          } catch {
          }
          h = !0;
        }
        return h;
      } finally {
        cn = c, Hr.transition = i;
      }
    }
    return !1;
  }
  function Qv(r, i, c) {
    i = pl(c, i), i = Av(r, i, 1), r = Eo(r, i, 1), i = wr(), r !== null && (Ts(r, 1, i), ji(r, i));
  }
  function Vn(r, i, c) {
    if (r.tag === 3) Qv(r, r, c);
    else for (; i !== null; ) {
      if (i.tag === 3) {
        Qv(i, r, c);
        break;
      } else if (i.tag === 1) {
        var h = i.stateNode;
        if (typeof i.type.getDerivedStateFromError == "function" || typeof h.componentDidCatch == "function" && (Ro === null || !Ro.has(h))) {
          r = pl(c, r), r = Gh(i, r, 1), i = Eo(i, r, 1), r = wr(), i !== null && (Ts(i, 1, r), ji(i, r));
          break;
        }
      }
      i = i.return;
    }
  }
  function I0(r, i, c) {
    var h = r.pingCache;
    h !== null && h.delete(i), i = wr(), r.pingedLanes |= r.suspendedLanes & c, kr === r && (Vr & c) === c && (lr === 4 || lr === 3 && (Vr & 130023424) === Vr && 500 > D() - ip ? $s(r, 0) : ad |= c), ji(r, i);
  }
  function Kv(r, i) {
    i === 0 && (r.mode & 1 ? (i = qi, qi <<= 1, !(qi & 130023424) && (qi = 4194304)) : i = 1);
    var c = wr();
    r = Gi(r, i), r !== null && (Ts(r, i, c), ji(r, c));
  }
  function z0(r) {
    var i = r.memoizedState, c = 0;
    i !== null && (c = i.retryLane), Kv(r, c);
  }
  function Xv(r, i) {
    var c = 0;
    switch (r.tag) {
      case 13:
        var h = r.stateNode, g = r.memoizedState;
        g !== null && (c = g.retryLane);
        break;
      case 19:
        h = r.stateNode;
        break;
      default:
        throw Error(s(314));
    }
    h !== null && h.delete(i), Kv(r, c);
  }
  var Zv;
  Zv = function(r, i, c) {
    if (r !== null) if (r.memoizedProps !== i.pendingProps || Rr.current) br = !0;
    else {
      if (!(r.lanes & c) && !(i.flags & 128)) return br = !1, wc(r, i, c);
      br = !!(r.flags & 131072);
    }
    else br = !1, Hn && i.flags & 1048576 && wv(i, Ls, i.index);
    switch (i.lanes = 0, i.tag) {
      case 2:
        var h = i.type;
        ba(r, i), r = i.pendingProps;
        var g = ma(i, tr.current);
        Gn(i, c), g = wo(null, i, h, r, g, c);
        var b = za();
        return i.flags |= 1, typeof g == "object" && g !== null && typeof g.render == "function" && g.$$typeof === void 0 ? (i.tag = 1, i.memoizedState = null, i.updateQueue = null, vr(h) ? (b = !0, Ti(i)) : b = !1, i.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, zh(i), g.updater = Kf, i.stateNode = g, g._reactInternals = i, gc(i, h, r, c), i = Sc(null, i, h, !0, b, c)) : (i.tag = 0, Hn && b && Tf(i), Br(null, i, g, c), i = i.child), i;
      case 16:
        h = i.elementType;
        e: {
          switch (ba(r, i), r = i.pendingProps, g = h._init, h = g(h._payload), i.type = h, g = i.tag = B0(h), r = $a(h, r), g) {
            case 0:
              i = Mv(null, i, h, r, c);
              break e;
            case 1:
              i = jv(null, i, h, r, c);
              break e;
            case 11:
              i = Ai(null, i, h, r, c);
              break e;
            case 14:
              i = ml(null, i, h, $a(h.type, r), c);
              break e;
          }
          throw Error(s(
            306,
            h,
            ""
          ));
        }
        return i;
      case 0:
        return h = i.type, g = i.pendingProps, g = i.elementType === h ? g : $a(h, g), Mv(r, i, h, g, c);
      case 1:
        return h = i.type, g = i.pendingProps, g = i.elementType === h ? g : $a(h, g), jv(r, i, h, g, c);
      case 3:
        e: {
          if (lu(i), r === null) throw Error(s(387));
          h = i.pendingProps, b = i.memoizedState, g = b.element, Cv(r, i), ac(i, h, null, c);
          var R = i.memoizedState;
          if (h = R.element, b.isDehydrated) if (b = { element: h, isDehydrated: !1, cache: R.cache, pendingSuspenseBoundaries: R.pendingSuspenseBoundaries, transitions: R.transitions }, i.updateQueue.baseState = b, i.memoizedState = b, i.flags & 256) {
            g = pl(Error(s(423)), i), i = Lv(r, i, h, c, g);
            break e;
          } else if (h !== g) {
            g = pl(Error(s(424)), i), i = Lv(r, i, h, c, g);
            break e;
          } else for (Oi = is(i.stateNode.containerInfo.firstChild), ki = i, Hn = !0, ga = null, c = Fe(i, null, h, c), i.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            if (So(), h === g) {
              i = Sa(r, i, c);
              break e;
            }
            Br(r, i, h, c);
          }
          i = i.child;
        }
        return i;
      case 5:
        return Tv(i), r === null && Mh(i), h = i.type, g = i.pendingProps, b = r !== null ? r.memoizedProps : null, R = g.children, wf(h, g) ? R = null : b !== null && wf(h, b) && (i.flags |= 32), Qh(r, i), Br(r, i, R, c), i.child;
      case 6:
        return r === null && Mh(i), null;
      case 13:
        return td(r, i, c);
      case 4:
        return Bh(i, i.stateNode.containerInfo), h = i.pendingProps, r === null ? i.child = ar(i, null, h, c) : Br(r, i, h, c), i.child;
      case 11:
        return h = i.type, g = i.pendingProps, g = i.elementType === h ? g : $a(h, g), Ai(r, i, h, g, c);
      case 7:
        return Br(r, i, i.pendingProps, c), i.child;
      case 8:
        return Br(r, i, i.pendingProps.children, c), i.child;
      case 12:
        return Br(r, i, i.pendingProps.children, c), i.child;
      case 10:
        e: {
          if (h = i.type._context, g = i.pendingProps, b = i.memoizedProps, R = g.value, ft(Wi, h._currentValue), h._currentValue = R, b !== null) if (Ua(b.value, R)) {
            if (b.children === g.children && !Rr.current) {
              i = Sa(r, i, c);
              break e;
            }
          } else for (b = i.child, b !== null && (b.return = i); b !== null; ) {
            var L = b.dependencies;
            if (L !== null) {
              R = b.child;
              for (var $ = L.firstContext; $ !== null; ) {
                if ($.context === h) {
                  if (b.tag === 1) {
                    $ = Us(-1, c & -c), $.tag = 2;
                    var ne = b.updateQueue;
                    if (ne !== null) {
                      ne = ne.shared;
                      var we = ne.pending;
                      we === null ? $.next = $ : ($.next = we.next, we.next = $), ne.pending = $;
                    }
                  }
                  b.lanes |= c, $ = b.alternate, $ !== null && ($.lanes |= c), Uh(
                    b.return,
                    c,
                    i
                  ), L.lanes |= c;
                  break;
                }
                $ = $.next;
              }
            } else if (b.tag === 10) R = b.type === i.type ? null : b.child;
            else if (b.tag === 18) {
              if (R = b.return, R === null) throw Error(s(341));
              R.lanes |= c, L = R.alternate, L !== null && (L.lanes |= c), Uh(R, c, i), R = b.sibling;
            } else R = b.child;
            if (R !== null) R.return = b;
            else for (R = b; R !== null; ) {
              if (R === i) {
                R = null;
                break;
              }
              if (b = R.sibling, b !== null) {
                b.return = R.return, R = b;
                break;
              }
              R = R.return;
            }
            b = R;
          }
          Br(r, i, g.children, c), i = i.child;
        }
        return i;
      case 9:
        return g = i.type, h = i.pendingProps.children, Gn(i, c), g = ya(g), h = h(g), i.flags |= 1, Br(r, i, h, c), i.child;
      case 14:
        return h = i.type, g = $a(h, i.pendingProps), g = $a(h.type, g), ml(r, i, h, g, c);
      case 15:
        return It(r, i, i.type, i.pendingProps, c);
      case 17:
        return h = i.type, g = i.pendingProps, g = i.elementType === h ? g : $a(h, g), ba(r, i), i.tag = 1, vr(h) ? (r = !0, Ti(i)) : r = !1, Gn(i, c), Xf(i, h, g), gc(i, h, g, c), Sc(null, i, h, !0, r, c);
      case 19:
        return fs(r, i, c);
      case 22:
        return bc(r, i, c);
    }
    throw Error(s(156, i.tag));
  };
  function eg(r, i) {
    return Cn(r, i);
  }
  function $0(r, i, c, h) {
    this.tag = r, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = h, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function wa(r, i, c, h) {
    return new $0(r, i, c, h);
  }
  function up(r) {
    return r = r.prototype, !(!r || !r.isReactComponent);
  }
  function B0(r) {
    if (typeof r == "function") return up(r) ? 1 : 0;
    if (r != null) {
      if (r = r.$$typeof, r === Bt) return 11;
      if (r === jt) return 14;
    }
    return 2;
  }
  function ko(r, i) {
    var c = r.alternate;
    return c === null ? (c = wa(r.tag, i, r.key, r.mode), c.elementType = r.elementType, c.type = r.type, c.stateNode = r.stateNode, c.alternate = r, r.alternate = c) : (c.pendingProps = i, c.type = r.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = r.flags & 14680064, c.childLanes = r.childLanes, c.lanes = r.lanes, c.child = r.child, c.memoizedProps = r.memoizedProps, c.memoizedState = r.memoizedState, c.updateQueue = r.updateQueue, i = r.dependencies, c.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, c.sibling = r.sibling, c.index = r.index, c.ref = r.ref, c;
  }
  function jc(r, i, c, h, g, b) {
    var R = 2;
    if (h = r, typeof r == "function") up(r) && (R = 1);
    else if (typeof r == "string") R = 5;
    else e: switch (r) {
      case Ve:
        return Bs(c.children, g, b, i);
      case wt:
        R = 8, g |= 8;
        break;
      case Rt:
        return r = wa(12, c, i, g | 2), r.elementType = Rt, r.lanes = b, r;
      case Ke:
        return r = wa(13, c, i, g), r.elementType = Ke, r.lanes = b, r;
      case Jt:
        return r = wa(19, c, i, g), r.elementType = Jt, r.lanes = b, r;
      case Ye:
        return Oo(c, g, b, i);
      default:
        if (typeof r == "object" && r !== null) switch (r.$$typeof) {
          case zt:
            R = 10;
            break e;
          case it:
            R = 9;
            break e;
          case Bt:
            R = 11;
            break e;
          case jt:
            R = 14;
            break e;
          case Ht:
            R = 16, h = null;
            break e;
        }
        throw Error(s(130, r == null ? r : typeof r, ""));
    }
    return i = wa(R, c, i, g), i.elementType = r, i.type = h, i.lanes = b, i;
  }
  function Bs(r, i, c, h) {
    return r = wa(7, r, h, i), r.lanes = c, r;
  }
  function Oo(r, i, c, h) {
    return r = wa(22, r, h, i), r.elementType = Ye, r.lanes = c, r.stateNode = { isHidden: !1 }, r;
  }
  function cp(r, i, c) {
    return r = wa(6, r, null, i), r.lanes = c, r;
  }
  function ud(r, i, c) {
    return i = wa(4, r.children !== null ? r.children : [], r.key, i), i.lanes = c, i.stateNode = { containerInfo: r.containerInfo, pendingChildren: null, implementation: r.implementation }, i;
  }
  function tg(r, i, c, h, g) {
    this.tag = i, this.containerInfo = r, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = $l(0), this.expirationTimes = $l(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = $l(0), this.identifierPrefix = h, this.onRecoverableError = g, this.mutableSourceEagerHydrationData = null;
  }
  function cd(r, i, c, h, g, b, R, L, $) {
    return r = new tg(r, i, c, L, $), i === 1 ? (i = 1, b === !0 && (i |= 8)) : i = 0, b = wa(3, null, null, i), r.current = b, b.stateNode = r, b.memoizedState = { element: h, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null }, zh(b), r;
  }
  function H0(r, i, c) {
    var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: lt, key: h == null ? null : "" + h, children: r, containerInfo: i, implementation: c };
  }
  function fp(r) {
    if (!r) return Ci;
    r = r._reactInternals;
    e: {
      if (Et(r) !== r || r.tag !== 1) throw Error(s(170));
      var i = r;
      do {
        switch (i.tag) {
          case 3:
            i = i.stateNode.context;
            break e;
          case 1:
            if (vr(i.type)) {
              i = i.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        i = i.return;
      } while (i !== null);
      throw Error(s(171));
    }
    if (r.tag === 1) {
      var c = r.type;
      if (vr(c)) return rc(r, c, i);
    }
    return i;
  }
  function ng(r, i, c, h, g, b, R, L, $) {
    return r = cd(c, h, !0, r, g, b, R, L, $), r.context = fp(null), c = r.current, h = wr(), g = ms(c), b = Us(h, g), b.callback = i ?? null, Eo(c, b, g), r.current.lanes = g, Ts(r, g, h), ji(r, h), r;
  }
  function fd(r, i, c, h) {
    var g = i.current, b = wr(), R = ms(g);
    return c = fp(c), i.context === null ? i.context = c : i.pendingContext = c, i = Us(b, R), i.payload = { element: r }, h = h === void 0 ? null : h, h !== null && (i.callback = h), r = Eo(g, i, R), r !== null && (fi(r, g, R, b), Af(r, g, R)), R;
  }
  function dd(r) {
    if (r = r.current, !r.child) return null;
    switch (r.child.tag) {
      case 5:
        return r.child.stateNode;
      default:
        return r.child.stateNode;
    }
  }
  function dp(r, i) {
    if (r = r.memoizedState, r !== null && r.dehydrated !== null) {
      var c = r.retryLane;
      r.retryLane = c !== 0 && c < i ? c : i;
    }
  }
  function hd(r, i) {
    dp(r, i), (r = r.alternate) && dp(r, i);
  }
  var hp = typeof reportError == "function" ? reportError : function(r) {
    console.error(r);
  };
  function No(r) {
    this._internalRoot = r;
  }
  pd.prototype.render = No.prototype.render = function(r) {
    var i = this._internalRoot;
    if (i === null) throw Error(s(409));
    fd(r, i, null, null);
  }, pd.prototype.unmount = No.prototype.unmount = function() {
    var r = this._internalRoot;
    if (r !== null) {
      this._internalRoot = null;
      var i = r.containerInfo;
      bl(function() {
        fd(null, r, null, null);
      }), i[Ms] = null;
    }
  };
  function pd(r) {
    this._internalRoot = r;
  }
  pd.prototype.unstable_scheduleHydration = function(r) {
    if (r) {
      var i = Nt();
      r = { blockedOn: null, target: r, priority: i };
      for (var c = 0; c < Cr.length && i !== 0 && i < Cr[c].priority; c++) ;
      Cr.splice(c, 0, r), c === 0 && Hu(r);
    }
  };
  function pp(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11);
  }
  function md(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11 && (r.nodeType !== 8 || r.nodeValue !== " react-mount-point-unstable "));
  }
  function rg() {
  }
  function V0(r, i, c, h, g) {
    if (g) {
      if (typeof h == "function") {
        var b = h;
        h = function() {
          var ne = dd(R);
          b.call(ne);
        };
      }
      var R = ng(i, h, r, 0, null, !1, !1, "", rg);
      return r._reactRootContainer = R, r[Ms] = R.current, Xl(r.nodeType === 8 ? r.parentNode : r), bl(), R;
    }
    for (; g = r.lastChild; ) r.removeChild(g);
    if (typeof h == "function") {
      var L = h;
      h = function() {
        var ne = dd($);
        L.call(ne);
      };
    }
    var $ = cd(r, 0, !1, null, null, !1, !1, "", rg);
    return r._reactRootContainer = $, r[Ms] = $.current, Xl(r.nodeType === 8 ? r.parentNode : r), bl(function() {
      fd(i, $, c, h);
    }), $;
  }
  function vd(r, i, c, h, g) {
    var b = c._reactRootContainer;
    if (b) {
      var R = b;
      if (typeof g == "function") {
        var L = g;
        g = function() {
          var $ = dd(R);
          L.call($);
        };
      }
      fd(i, R, r, g);
    } else R = V0(c, i, r, g, h);
    return dd(R);
  }
  rn = function(r) {
    switch (r.tag) {
      case 3:
        var i = r.stateNode;
        if (i.current.memoizedState.isDehydrated) {
          var c = Ma(i.pendingLanes);
          c !== 0 && (ks(i, c | 1), ji(i, D()), !(Zt & 6) && (du = D() + 500, os()));
        }
        break;
      case 13:
        bl(function() {
          var h = Gi(r, 1);
          if (h !== null) {
            var g = wr();
            fi(h, r, 1, g);
          }
        }), hd(r, 1);
    }
  }, $u = function(r) {
    if (r.tag === 13) {
      var i = Gi(r, 134217728);
      if (i !== null) {
        var c = wr();
        fi(i, r, 134217728, c);
      }
      hd(r, 134217728);
    }
  }, Za = function(r) {
    if (r.tag === 13) {
      var i = ms(r), c = Gi(r, i);
      if (c !== null) {
        var h = wr();
        fi(c, r, i, h);
      }
      hd(r, i);
    }
  }, Nt = function() {
    return cn;
  }, Hl = function(r, i) {
    var c = cn;
    try {
      return cn = r, i();
    } finally {
      cn = c;
    }
  }, un = function(r, i, c) {
    switch (i) {
      case "input":
        if (xr(r, c), i = c.name, c.type === "radio" && i != null) {
          for (c = r; c.parentNode; ) c = c.parentNode;
          for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'), i = 0; i < c.length; i++) {
            var h = c[i];
            if (h !== r && h.form === r.form) {
              var g = ir(h);
              if (!g) throw Error(s(90));
              dr(h), xr(h, g);
            }
          }
        }
        break;
      case "textarea":
        We(r, c);
        break;
      case "select":
        i = c.value, i != null && Sn(r, !!c.multiple, i, !1);
    }
  }, Aa = sp, ua = bl;
  var ig = { usingClientEntryPoint: !1, Events: [pt, Fa, ir, la, Rs, sp] }, Lc = { findFiberByHostInstance: tl, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, q0 = { bundleType: Lc.bundleType, version: Lc.version, rendererPackageName: Lc.rendererPackageName, rendererConfig: Lc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: De.ReactCurrentDispatcher, findHostInstanceByFiber: function(r) {
    return r = Yn(r), r === null ? null : r.stateNode;
  }, findFiberByHostInstance: Lc.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Pc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Pc.isDisabled && Pc.supportsFiber) try {
      qe = Pc.inject(q0), xt = Pc;
    } catch {
    }
  }
  return ka.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ig, ka.createPortal = function(r, i) {
    var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!pp(i)) throw Error(s(200));
    return H0(r, i, null, c);
  }, ka.createRoot = function(r, i) {
    if (!pp(r)) throw Error(s(299));
    var c = !1, h = "", g = hp;
    return i != null && (i.unstable_strictMode === !0 && (c = !0), i.identifierPrefix !== void 0 && (h = i.identifierPrefix), i.onRecoverableError !== void 0 && (g = i.onRecoverableError)), i = cd(r, 1, !1, null, null, c, !1, h, g), r[Ms] = i.current, Xl(r.nodeType === 8 ? r.parentNode : r), new No(i);
  }, ka.findDOMNode = function(r) {
    if (r == null) return null;
    if (r.nodeType === 1) return r;
    var i = r._reactInternals;
    if (i === void 0)
      throw typeof r.render == "function" ? Error(s(188)) : (r = Object.keys(r).join(","), Error(s(268, r)));
    return r = Yn(i), r = r === null ? null : r.stateNode, r;
  }, ka.flushSync = function(r) {
    return bl(r);
  }, ka.hydrate = function(r, i, c) {
    if (!md(i)) throw Error(s(200));
    return vd(null, r, i, !0, c);
  }, ka.hydrateRoot = function(r, i, c) {
    if (!pp(r)) throw Error(s(405));
    var h = c != null && c.hydratedSources || null, g = !1, b = "", R = hp;
    if (c != null && (c.unstable_strictMode === !0 && (g = !0), c.identifierPrefix !== void 0 && (b = c.identifierPrefix), c.onRecoverableError !== void 0 && (R = c.onRecoverableError)), i = ng(i, null, r, 1, c ?? null, g, !1, b, R), r[Ms] = i.current, Xl(r), h) for (r = 0; r < h.length; r++) c = h[r], g = c._getVersion, g = g(c._source), i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [c, g] : i.mutableSourceEagerHydrationData.push(
      c,
      g
    );
    return new pd(i);
  }, ka.render = function(r, i, c) {
    if (!md(i)) throw Error(s(200));
    return vd(null, r, i, !1, c);
  }, ka.unmountComponentAtNode = function(r) {
    if (!md(r)) throw Error(s(40));
    return r._reactRootContainer ? (bl(function() {
      vd(null, null, r, !1, function() {
        r._reactRootContainer = null, r[Ms] = null;
      });
    }), !0) : !1;
  }, ka.unstable_batchedUpdates = sp, ka.unstable_renderSubtreeIntoContainer = function(r, i, c, h) {
    if (!md(c)) throw Error(s(200));
    if (r == null || r._reactInternals === void 0) throw Error(s(38));
    return vd(r, i, c, !1, h);
  }, ka.version = "18.3.1-next-f1338f8080-20240426", ka;
}
var Oa = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LR;
function BM() {
  return LR || (LR = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var o = Um(), n = F1(), s = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = !1;
    function d(e) {
      l = e;
    }
    function v(e) {
      if (!l) {
        for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), u = 1; u < t; u++)
          a[u - 1] = arguments[u];
        E("warn", e, a);
      }
    }
    function p(e) {
      if (!l) {
        for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), u = 1; u < t; u++)
          a[u - 1] = arguments[u];
        E("error", e, a);
      }
    }
    function E(e, t, a) {
      {
        var u = s.ReactDebugCurrentFrame, f = u.getStackAddendum();
        f !== "" && (t += "%s", a = a.concat([f]));
        var m = a.map(function(y) {
          return String(y);
        });
        m.unshift("Warning: " + t), Function.prototype.apply.call(console[e], console, m);
      }
    }
    var _ = 0, x = 1, N = 2, O = 3, P = 4, z = 5, B = 6, ie = 7, K = 8, be = 9, ae = 10, ve = 11, De = 12, Re = 13, lt = 14, Ve = 15, wt = 16, Rt = 17, zt = 18, it = 19, Bt = 21, Ke = 22, Jt = 23, jt = 24, Ht = 25, Ye = !0, Ce = !1, Ze = !1, ke = !1, Y = !1, ue = !0, st = !0, dt = !0, ot = !0, Ot = /* @__PURE__ */ new Set(), ct = {}, ht = {};
    function Ae(e, t) {
      Lt(e, t), Lt(e + "Capture", t);
    }
    function Lt(e, t) {
      ct[e] && p("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), ct[e] = t;
      {
        var a = e.toLowerCase();
        ht[a] = e, e === "onDoubleClick" && (ht.ondblclick = e);
      }
      for (var u = 0; u < t.length; u++)
        Ot.add(t[u]);
    }
    var Un = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", dr = Object.prototype.hasOwnProperty;
    function wn(e) {
      {
        var t = typeof Symbol == "function" && Symbol.toStringTag, a = t && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return a;
      }
    }
    function $n(e) {
      try {
        return Fn(e), !1;
      } catch {
        return !0;
      }
    }
    function Fn(e) {
      return "" + e;
    }
    function jn(e, t) {
      if ($n(e))
        return p("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", t, wn(e)), Fn(e);
    }
    function xr(e) {
      if ($n(e))
        return p("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", wn(e)), Fn(e);
    }
    function wi(e, t) {
      if ($n(e))
        return p("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", t, wn(e)), Fn(e);
    }
    function Fr(e, t) {
      if ($n(e))
        return p("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", t, wn(e)), Fn(e);
    }
    function Kn(e) {
      if ($n(e))
        return p("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", wn(e)), Fn(e);
    }
    function Sn(e) {
      if ($n(e))
        return p("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", wn(e)), Fn(e);
    }
    var Bn = 0, qn = 1, We = 2, Tt = 3, hr = 4, ai = 5, $i = 6, oa = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Me = oa + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", at = new RegExp("^[" + oa + "][" + Me + "]*$"), Pt = {}, sn = {};
    function nn(e) {
      return dr.call(sn, e) ? !0 : dr.call(Pt, e) ? !1 : at.test(e) ? (sn[e] = !0, !0) : (Pt[e] = !0, p("Invalid attribute name: `%s`", e), !1);
    }
    function _n(e, t, a) {
      return t !== null ? t.type === Bn : a ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function xn(e, t, a, u) {
      if (a !== null && a.type === Bn)
        return !1;
      switch (typeof t) {
        case "function":
        // $FlowIssue symbol is perfectly valid here
        case "symbol":
          return !0;
        case "boolean": {
          if (u)
            return !1;
          if (a !== null)
            return !a.acceptsBooleans;
          var f = e.toLowerCase().slice(0, 5);
          return f !== "data-" && f !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Xn(e, t, a, u) {
      if (t === null || typeof t > "u" || xn(e, t, a, u))
        return !0;
      if (u)
        return !1;
      if (a !== null)
        switch (a.type) {
          case Tt:
            return !t;
          case hr:
            return t === !1;
          case ai:
            return isNaN(t);
          case $i:
            return isNaN(t) || t < 1;
        }
      return !1;
    }
    function gn(e) {
      return un.hasOwnProperty(e) ? un[e] : null;
    }
    function on(e, t, a, u, f, m, y) {
      this.acceptsBooleans = t === We || t === Tt || t === hr, this.attributeName = u, this.attributeNamespace = f, this.mustUseProperty = a, this.propertyName = e, this.type = t, this.sanitizeURL = m, this.removeEmptyString = y;
    }
    var un = {}, Dr = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Dr.forEach(function(e) {
      un[e] = new on(
        e,
        Bn,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var t = e[0], a = e[1];
      un[t] = new on(
        t,
        qn,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      un[e] = new on(
        e,
        We,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      un[e] = new on(
        e,
        We,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      un[e] = new on(
        e,
        Tt,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      un[e] = new on(
        e,
        Tt,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      un[e] = new on(
        e,
        hr,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      un[e] = new on(
        e,
        $i,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      un[e] = new on(
        e,
        ai,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var pr = /[\-\:]([a-z])/g, Zr = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(pr, Zr);
      un[t] = new on(
        t,
        qn,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(pr, Zr);
      un[t] = new on(
        t,
        qn,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var t = e.replace(pr, Zr);
      un[t] = new on(
        t,
        qn,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      un[e] = new on(
        e,
        qn,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var la = "xlinkHref";
    un[la] = new on(
      "xlinkHref",
      qn,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      un[e] = new on(
        e,
        qn,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Rs = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Aa = !1;
    function ua(e) {
      !Aa && Rs.test(e) && (Aa = !0, p("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function Bi(e, t, a, u) {
      if (u.mustUseProperty) {
        var f = u.propertyName;
        return e[f];
      } else {
        jn(a, t), u.sanitizeURL && ua("" + a);
        var m = u.attributeName, y = null;
        if (u.type === hr) {
          if (e.hasAttribute(m)) {
            var S = e.getAttribute(m);
            return S === "" ? !0 : Xn(t, a, u, !1) ? S : S === "" + a ? a : S;
          }
        } else if (e.hasAttribute(m)) {
          if (Xn(t, a, u, !1))
            return e.getAttribute(m);
          if (u.type === Tt)
            return a;
          y = e.getAttribute(m);
        }
        return Xn(t, a, u, !1) ? y === null ? a : y : y === "" + a ? a : y;
      }
    }
    function Hi(e, t, a, u) {
      {
        if (!nn(t))
          return;
        if (!e.hasAttribute(t))
          return a === void 0 ? void 0 : null;
        var f = e.getAttribute(t);
        return jn(a, t), f === "" + a ? a : f;
      }
    }
    function Zn(e, t, a, u) {
      var f = gn(t);
      if (!_n(t, f, u)) {
        if (Xn(t, a, f, u) && (a = null), u || f === null) {
          if (nn(t)) {
            var m = t;
            a === null ? e.removeAttribute(m) : (jn(a, t), e.setAttribute(m, "" + a));
          }
          return;
        }
        var y = f.mustUseProperty;
        if (y) {
          var S = f.propertyName;
          if (a === null) {
            var w = f.type;
            e[S] = w === Tt ? !1 : "";
          } else
            e[S] = a;
          return;
        }
        var k = f.attributeName, M = f.attributeNamespace;
        if (a === null)
          e.removeAttribute(k);
        else {
          var q = f.type, H;
          q === Tt || q === hr && a === !0 ? H = "" : (jn(a, k), H = "" + a, f.sanitizeURL && ua(H.toString())), M ? e.setAttributeNS(M, k, H) : e.setAttribute(k, H);
        }
      }
    }
    var rr = Symbol.for("react.element"), er = Symbol.for("react.portal"), ei = Symbol.for("react.fragment"), Ir = Symbol.for("react.strict_mode"), _i = Symbol.for("react.profiler"), Vi = Symbol.for("react.provider"), I = Symbol.for("react.context"), ye = Symbol.for("react.forward_ref"), Ne = Symbol.for("react.suspense"), Ue = Symbol.for("react.suspense_list"), Et = Symbol.for("react.memo"), _t = Symbol.for("react.lazy"), Ut = Symbol.for("react.scope"), Ft = Symbol.for("react.debug_trace_mode"), Yn = Symbol.for("react.offscreen"), Vt = Symbol.for("react.legacy_hidden"), Cn = Symbol.for("react.cache"), T = Symbol.for("react.tracing_marker"), j = Symbol.iterator, A = "@@iterator";
    function D(e) {
      if (e === null || typeof e != "object")
        return null;
      var t = j && e[j] || e[A];
      return typeof t == "function" ? t : null;
    }
    var U = Object.assign, W = 0, he, ge, Z, de, qe, xt, En;
    function Dn() {
    }
    Dn.__reactDisabledLog = !0;
    function Da() {
      {
        if (W === 0) {
          he = console.log, ge = console.info, Z = console.warn, de = console.error, qe = console.group, xt = console.groupCollapsed, En = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: Dn,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        W++;
      }
    }
    function lf() {
      {
        if (W--, W === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: U({}, e, {
              value: he
            }),
            info: U({}, e, {
              value: ge
            }),
            warn: U({}, e, {
              value: Z
            }),
            error: U({}, e, {
              value: de
            }),
            group: U({}, e, {
              value: qe
            }),
            groupCollapsed: U({}, e, {
              value: xt
            }),
            groupEnd: U({}, e, {
              value: En
            })
          });
        }
        W < 0 && p("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Fl = s.ReactCurrentDispatcher, ao;
    function qi(e, t, a) {
      {
        if (ao === void 0)
          try {
            throw Error();
          } catch (f) {
            var u = f.stack.trim().match(/\n( *(at )?)/);
            ao = u && u[1] || "";
          }
        return `
` + ao + e;
      }
    }
    var Ma = !1, ja;
    {
      var Il = typeof WeakMap == "function" ? WeakMap : Map;
      ja = new Il();
    }
    function qo(e, t) {
      if (!e || Ma)
        return "";
      {
        var a = ja.get(e);
        if (a !== void 0)
          return a;
      }
      var u;
      Ma = !0;
      var f = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var m;
      m = Fl.current, Fl.current = null, Da();
      try {
        if (t) {
          var y = function() {
            throw Error();
          };
          if (Object.defineProperty(y.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(y, []);
            } catch (re) {
              u = re;
            }
            Reflect.construct(e, [], y);
          } else {
            try {
              y.call();
            } catch (re) {
              u = re;
            }
            e.call(y.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (re) {
            u = re;
          }
          e();
        }
      } catch (re) {
        if (re && u && typeof re.stack == "string") {
          for (var S = re.stack.split(`
`), w = u.stack.split(`
`), k = S.length - 1, M = w.length - 1; k >= 1 && M >= 0 && S[k] !== w[M]; )
            M--;
          for (; k >= 1 && M >= 0; k--, M--)
            if (S[k] !== w[M]) {
              if (k !== 1 || M !== 1)
                do
                  if (k--, M--, M < 0 || S[k] !== w[M]) {
                    var q = `
` + S[k].replace(" at new ", " at ");
                    return e.displayName && q.includes("<anonymous>") && (q = q.replace("<anonymous>", e.displayName)), typeof e == "function" && ja.set(e, q), q;
                  }
                while (k >= 1 && M >= 0);
              break;
            }
        }
      } finally {
        Ma = !1, Fl.current = m, lf(), Error.prepareStackTrace = f;
      }
      var H = e ? e.displayName || e.name : "", ee = H ? qi(H) : "";
      return typeof e == "function" && ja.set(e, ee), ee;
    }
    function so(e, t, a) {
      return qo(e, !0);
    }
    function zl(e, t, a) {
      return qo(e, !1);
    }
    function $l(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function Ts(e, t, a) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return qo(e, $l(e));
      if (typeof e == "string")
        return qi(e);
      switch (e) {
        case Ne:
          return qi("Suspense");
        case Ue:
          return qi("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case ye:
            return zl(e.render);
          case Et:
            return Ts(e.type, t, a);
          case _t: {
            var u = e, f = u._payload, m = u._init;
            try {
              return Ts(m(f), t, a);
            } catch {
            }
          }
        }
      return "";
    }
    function uh(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case z:
          return qi(e.type);
        case wt:
          return qi("Lazy");
        case Re:
          return qi("Suspense");
        case it:
          return qi("SuspenseList");
        case _:
        case N:
        case Ve:
          return zl(e.type);
        case ve:
          return zl(e.type.render);
        case x:
          return so(e.type);
        default:
          return "";
      }
    }
    function ks(e) {
      try {
        var t = "", a = e;
        do
          t += uh(a), a = a.return;
        while (a);
        return t;
      } catch (u) {
        return `
Error generating stack: ` + u.message + `
` + u.stack;
      }
    }
    function cn(e, t, a) {
      var u = e.displayName;
      if (u)
        return u;
      var f = t.displayName || t.name || "";
      return f !== "" ? a + "(" + f + ")" : a;
    }
    function Bl(e) {
      return e.displayName || "Context";
    }
    function rn(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && p("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case ei:
          return "Fragment";
        case er:
          return "Portal";
        case _i:
          return "Profiler";
        case Ir:
          return "StrictMode";
        case Ne:
          return "Suspense";
        case Ue:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case I:
            var t = e;
            return Bl(t) + ".Consumer";
          case Vi:
            var a = e;
            return Bl(a._context) + ".Provider";
          case ye:
            return cn(e, e.render, "ForwardRef");
          case Et:
            var u = e.displayName || null;
            return u !== null ? u : rn(e.type) || "Memo";
          case _t: {
            var f = e, m = f._payload, y = f._init;
            try {
              return rn(y(m));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function $u(e, t, a) {
      var u = t.displayName || t.name || "";
      return e.displayName || (u !== "" ? a + "(" + u + ")" : a);
    }
    function Za(e) {
      return e.displayName || "Context";
    }
    function Nt(e) {
      var t = e.tag, a = e.type;
      switch (t) {
        case jt:
          return "Cache";
        case be:
          var u = a;
          return Za(u) + ".Consumer";
        case ae:
          var f = a;
          return Za(f._context) + ".Provider";
        case zt:
          return "DehydratedFragment";
        case ve:
          return $u(a, a.render, "ForwardRef");
        case ie:
          return "Fragment";
        case z:
          return a;
        case P:
          return "Portal";
        case O:
          return "Root";
        case B:
          return "Text";
        case wt:
          return rn(a);
        case K:
          return a === Ir ? "StrictMode" : "Mode";
        case Ke:
          return "Offscreen";
        case De:
          return "Profiler";
        case Bt:
          return "Scope";
        case Re:
          return "Suspense";
        case it:
          return "SuspenseList";
        case Ht:
          return "TracingMarker";
        // The display name for this tags come from the user-provided type:
        case x:
        case _:
        case Rt:
        case N:
        case lt:
        case Ve:
          if (typeof a == "function")
            return a.displayName || a.name || null;
          if (typeof a == "string")
            return a;
          break;
      }
      return null;
    }
    var Hl = s.ReactDebugCurrentFrame, zr = null, es = !1;
    function si() {
      {
        if (zr === null)
          return null;
        var e = zr._debugOwner;
        if (e !== null && typeof e < "u")
          return Nt(e);
      }
      return null;
    }
    function ts() {
      return zr === null ? "" : ks(zr);
    }
    function In() {
      Hl.getCurrentStack = null, zr = null, es = !1;
    }
    function Rn(e) {
      Hl.getCurrentStack = e === null ? null : ts, zr = e, es = !1;
    }
    function oo() {
      return zr;
    }
    function Cr(e) {
      es = e;
    }
    function oi(e) {
      return "" + e;
    }
    function ca(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return Sn(e), e;
        default:
          return "";
      }
    }
    var Yo = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Bu(e, t) {
      Yo[t.type] || t.onChange || t.onInput || t.readOnly || t.disabled || t.value == null || p("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), t.onChange || t.readOnly || t.disabled || t.checked == null || p("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Hu(e) {
      var t = e.type, a = e.nodeName;
      return a && a.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
    }
    function lo(e) {
      return e._valueTracker;
    }
    function Wo(e) {
      e._valueTracker = null;
    }
    function ch(e) {
      var t = "";
      return e && (Hu(e) ? t = e.checked ? "true" : "false" : t = e.value), t;
    }
    function fa(e) {
      var t = Hu(e) ? "checked" : "value", a = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);
      Sn(e[t]);
      var u = "" + e[t];
      if (!(e.hasOwnProperty(t) || typeof a > "u" || typeof a.get != "function" || typeof a.set != "function")) {
        var f = a.get, m = a.set;
        Object.defineProperty(e, t, {
          configurable: !0,
          get: function() {
            return f.call(this);
          },
          set: function(S) {
            Sn(S), u = "" + S, m.call(this, S);
          }
        }), Object.defineProperty(e, t, {
          enumerable: a.enumerable
        });
        var y = {
          getValue: function() {
            return u;
          },
          setValue: function(S) {
            Sn(S), u = "" + S;
          },
          stopTracking: function() {
            Wo(e), delete e[t];
          }
        };
        return y;
      }
    }
    function La(e) {
      lo(e) || (e._valueTracker = fa(e));
    }
    function ns(e) {
      if (!e)
        return !1;
      var t = lo(e);
      if (!t)
        return !0;
      var a = t.getValue(), u = ch(e);
      return u !== a ? (t.setValue(u), !0) : !1;
    }
    function da(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var Vl = !1, ql = !1, uo = !1, Go = !1;
    function Yl(e) {
      var t = e.type === "checkbox" || e.type === "radio";
      return t ? e.checked != null : e.value != null;
    }
    function Wl(e, t) {
      var a = e, u = t.checked, f = U({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: u ?? a._wrapperState.initialChecked
      });
      return f;
    }
    function Pa(e, t) {
      Bu("input", t), t.checked !== void 0 && t.defaultChecked !== void 0 && !ql && (p("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component", t.type), ql = !0), t.value !== void 0 && t.defaultValue !== void 0 && !Vl && (p("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component", t.type), Vl = !0);
      var a = e, u = t.defaultValue == null ? "" : t.defaultValue;
      a._wrapperState = {
        initialChecked: t.checked != null ? t.checked : t.defaultChecked,
        initialValue: ca(t.value != null ? t.value : u),
        controlled: Yl(t)
      };
    }
    function C(e, t) {
      var a = e, u = t.checked;
      u != null && Zn(a, "checked", u, !1);
    }
    function F(e, t) {
      var a = e;
      {
        var u = Yl(t);
        !a._wrapperState.controlled && u && !Go && (p("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Go = !0), a._wrapperState.controlled && !u && !uo && (p("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), uo = !0);
      }
      C(e, t);
      var f = ca(t.value), m = t.type;
      if (f != null)
        m === "number" ? (f === 0 && a.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        a.value != f) && (a.value = oi(f)) : a.value !== oi(f) && (a.value = oi(f));
      else if (m === "submit" || m === "reset") {
        a.removeAttribute("value");
        return;
      }
      t.hasOwnProperty("value") ? gt(a, t.type, f) : t.hasOwnProperty("defaultValue") && gt(a, t.type, ca(t.defaultValue)), t.checked == null && t.defaultChecked != null && (a.defaultChecked = !!t.defaultChecked);
    }
    function te(e, t, a) {
      var u = e;
      if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var f = t.type, m = f === "submit" || f === "reset";
        if (m && (t.value === void 0 || t.value === null))
          return;
        var y = oi(u._wrapperState.initialValue);
        a || y !== u.value && (u.value = y), u.defaultValue = y;
      }
      var S = u.name;
      S !== "" && (u.name = ""), u.defaultChecked = !u.defaultChecked, u.defaultChecked = !!u._wrapperState.initialChecked, S !== "" && (u.name = S);
    }
    function oe(e, t) {
      var a = e;
      F(a, t), Te(a, t);
    }
    function Te(e, t) {
      var a = t.name;
      if (t.type === "radio" && a != null) {
        for (var u = e; u.parentNode; )
          u = u.parentNode;
        jn(a, "name");
        for (var f = u.querySelectorAll("input[name=" + JSON.stringify("" + a) + '][type="radio"]'), m = 0; m < f.length; m++) {
          var y = f[m];
          if (!(y === e || y.form !== e.form)) {
            var S = Eg(y);
            if (!S)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            ns(y), F(y, S);
          }
        }
      }
    }
    function gt(e, t, a) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (t !== "number" || da(e.ownerDocument) !== e) && (a == null ? e.defaultValue = oi(e._wrapperState.initialValue) : e.defaultValue !== oi(a) && (e.defaultValue = oi(a)));
    }
    var Pe = !1, St = !1, Gt = !1;
    function an(e, t) {
      t.value == null && (typeof t.children == "object" && t.children !== null ? o.Children.forEach(t.children, function(a) {
        a != null && (typeof a == "string" || typeof a == "number" || St || (St = !0, p("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : t.dangerouslySetInnerHTML != null && (Gt || (Gt = !0, p("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), t.selected != null && !Pe && (p("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Pe = !0);
    }
    function Ln(e, t) {
      t.value != null && e.setAttribute("value", oi(ca(t.value)));
    }
    var Tn = Array.isArray;
    function $t(e) {
      return Tn(e);
    }
    var kn;
    kn = !1;
    function Wn() {
      var e = si();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var co = ["value", "defaultValue"];
    function Vu(e) {
      {
        Bu("select", e);
        for (var t = 0; t < co.length; t++) {
          var a = co[t];
          if (e[a] != null) {
            var u = $t(e[a]);
            e.multiple && !u ? p("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", a, Wn()) : !e.multiple && u && p("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", a, Wn());
          }
        }
      }
    }
    function Os(e, t, a, u) {
      var f = e.options;
      if (t) {
        for (var m = a, y = {}, S = 0; S < m.length; S++)
          y["$" + m[S]] = !0;
        for (var w = 0; w < f.length; w++) {
          var k = y.hasOwnProperty("$" + f[w].value);
          f[w].selected !== k && (f[w].selected = k), k && u && (f[w].defaultSelected = !0);
        }
      } else {
        for (var M = oi(ca(a)), q = null, H = 0; H < f.length; H++) {
          if (f[H].value === M) {
            f[H].selected = !0, u && (f[H].defaultSelected = !0);
            return;
          }
          q === null && !f[H].disabled && (q = f[H]);
        }
        q !== null && (q.selected = !0);
      }
    }
    function qu(e, t) {
      return U({}, t, {
        value: void 0
      });
    }
    function Jo(e, t) {
      var a = e;
      Vu(t), a._wrapperState = {
        wasMultiple: !!t.multiple
      }, t.value !== void 0 && t.defaultValue !== void 0 && !kn && (p("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), kn = !0);
    }
    function fh(e, t) {
      var a = e;
      a.multiple = !!t.multiple;
      var u = t.value;
      u != null ? Os(a, !!t.multiple, u, !1) : t.defaultValue != null && Os(a, !!t.multiple, t.defaultValue, !0);
    }
    function uf(e, t) {
      var a = e, u = a._wrapperState.wasMultiple;
      a._wrapperState.wasMultiple = !!t.multiple;
      var f = t.value;
      f != null ? Os(a, !!t.multiple, f, !1) : u !== !!t.multiple && (t.defaultValue != null ? Os(a, !!t.multiple, t.defaultValue, !0) : Os(a, !!t.multiple, t.multiple ? [] : "", !1));
    }
    function dh(e, t) {
      var a = e, u = t.value;
      u != null && Os(a, !!t.multiple, u, !1);
    }
    var Ym = !1;
    function hh(e, t) {
      var a = e;
      if (t.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var u = U({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: oi(a._wrapperState.initialValue)
      });
      return u;
    }
    function ph(e, t) {
      var a = e;
      Bu("textarea", t), t.value !== void 0 && t.defaultValue !== void 0 && !Ym && (p("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component"), Ym = !0);
      var u = t.value;
      if (u == null) {
        var f = t.children, m = t.defaultValue;
        if (f != null) {
          p("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (m != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if ($t(f)) {
              if (f.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              f = f[0];
            }
            m = f;
          }
        }
        m == null && (m = ""), u = m;
      }
      a._wrapperState = {
        initialValue: ca(u)
      };
    }
    function Wm(e, t) {
      var a = e, u = ca(t.value), f = ca(t.defaultValue);
      if (u != null) {
        var m = oi(u);
        m !== a.value && (a.value = m), t.defaultValue == null && a.defaultValue !== m && (a.defaultValue = m);
      }
      f != null && (a.defaultValue = oi(f));
    }
    function Gm(e, t) {
      var a = e, u = a.textContent;
      u === a._wrapperState.initialValue && u !== "" && u !== null && (a.value = u);
    }
    function S0(e, t) {
      Wm(e, t);
    }
    var Ns = "http://www.w3.org/1999/xhtml", mh = "http://www.w3.org/1998/Math/MathML", vh = "http://www.w3.org/2000/svg";
    function gh(e) {
      switch (e) {
        case "svg":
          return vh;
        case "math":
          return mh;
        default:
          return Ns;
      }
    }
    function yh(e, t) {
      return e == null || e === Ns ? gh(t) : e === vh && t === "foreignObject" ? Ns : e;
    }
    var Jm = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, a, u, f) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(t, a, u, f);
        });
      } : e;
    }, cf, Qm = Jm(function(e, t) {
      if (e.namespaceURI === vh && !("innerHTML" in e)) {
        cf = cf || document.createElement("div"), cf.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>";
        for (var a = cf.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; a.firstChild; )
          e.appendChild(a.firstChild);
        return;
      }
      e.innerHTML = t;
    }), xi = 1, As = 3, mr = 8, Ds = 9, bh = 11, Gl = function(e, t) {
      if (t) {
        var a = e.firstChild;
        if (a && a === e.lastChild && a.nodeType === As) {
          a.nodeValue = t;
          return;
        }
      }
      e.textContent = t;
    }, Yu = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Wu = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Km(e, t) {
      return e + t.charAt(0).toUpperCase() + t.substring(1);
    }
    var Xm = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Wu).forEach(function(e) {
      Xm.forEach(function(t) {
        Wu[Km(t, e)] = Wu[e];
      });
    });
    function ff(e, t, a) {
      var u = t == null || typeof t == "boolean" || t === "";
      return u ? "" : !a && typeof t == "number" && t !== 0 && !(Wu.hasOwnProperty(e) && Wu[e]) ? t + "px" : (Fr(t, e), ("" + t).trim());
    }
    var Zm = /([A-Z])/g, ev = /^ms-/;
    function Jl(e) {
      return e.replace(Zm, "-$1").toLowerCase().replace(ev, "-ms-");
    }
    var tv = function() {
    };
    {
      var E0 = /^(?:webkit|moz|o)[A-Z]/, w0 = /^-ms-/, nv = /-(.)/g, Sh = /;\s*$/, rs = {}, Qo = {}, rv = !1, Gu = !1, _0 = function(e) {
        return e.replace(nv, function(t, a) {
          return a.toUpperCase();
        });
      }, iv = function(e) {
        rs.hasOwnProperty(e) && rs[e] || (rs[e] = !0, p(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          _0(e.replace(w0, "ms-"))
        ));
      }, Eh = function(e) {
        rs.hasOwnProperty(e) && rs[e] || (rs[e] = !0, p("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, wh = function(e, t) {
        Qo.hasOwnProperty(t) && Qo[t] || (Qo[t] = !0, p(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, t.replace(Sh, "")));
      }, av = function(e, t) {
        rv || (rv = !0, p("`NaN` is an invalid value for the `%s` css style property.", e));
      }, sv = function(e, t) {
        Gu || (Gu = !0, p("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      tv = function(e, t) {
        e.indexOf("-") > -1 ? iv(e) : E0.test(e) ? Eh(e) : Sh.test(t) && wh(e, t), typeof t == "number" && (isNaN(t) ? av(e, t) : isFinite(t) || sv(e, t));
      };
    }
    var ov = tv;
    function x0(e) {
      {
        var t = "", a = "";
        for (var u in e)
          if (e.hasOwnProperty(u)) {
            var f = e[u];
            if (f != null) {
              var m = u.indexOf("--") === 0;
              t += a + (m ? u : Jl(u)) + ":", t += ff(u, f, m), a = ";";
            }
          }
        return t || null;
      }
    }
    function lv(e, t) {
      var a = e.style;
      for (var u in t)
        if (t.hasOwnProperty(u)) {
          var f = u.indexOf("--") === 0;
          f || ov(u, t[u]);
          var m = ff(u, t[u], f);
          u === "float" && (u = "cssFloat"), f ? a.setProperty(u, m) : a[u] = m;
        }
    }
    function C0(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function uv(e) {
      var t = {};
      for (var a in e)
        for (var u = Yu[a] || [a], f = 0; f < u.length; f++)
          t[u[f]] = a;
      return t;
    }
    function R0(e, t) {
      {
        if (!t)
          return;
        var a = uv(e), u = uv(t), f = {};
        for (var m in a) {
          var y = a[m], S = u[m];
          if (S && y !== S) {
            var w = y + "," + S;
            if (f[w])
              continue;
            f[w] = !0, p("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", C0(e[y]) ? "Removing" : "Updating", y, S);
          }
        }
      }
    }
    var Ua = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Ju = U({
      menuitem: !0
    }, Ua), cv = "__html";
    function df(e, t) {
      if (t) {
        if (Ju[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (t.dangerouslySetInnerHTML != null) {
          if (t.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof t.dangerouslySetInnerHTML != "object" || !(cv in t.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!t.suppressContentEditableWarning && t.contentEditable && t.children != null && p("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), t.style != null && typeof t.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function fo(e, t) {
      if (e.indexOf("-") === -1)
        return typeof t.is == "string";
      switch (e) {
        // These are reserved SVG and MathML elements.
        // We don't mind this list too much because we expect it to never grow.
        // The alternative is to track the namespace in a few places which is convoluted.
        // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Qu = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, hf = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ql = {}, T0 = new RegExp("^(aria)-[" + Me + "]*$"), Kl = new RegExp("^(aria)[A-Z][" + Me + "]*$");
    function _h(e, t) {
      {
        if (dr.call(Ql, t) && Ql[t])
          return !0;
        if (Kl.test(t)) {
          var a = "aria-" + t.slice(4).toLowerCase(), u = hf.hasOwnProperty(a) ? a : null;
          if (u == null)
            return p("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", t), Ql[t] = !0, !0;
          if (t !== u)
            return p("Invalid ARIA attribute `%s`. Did you mean `%s`?", t, u), Ql[t] = !0, !0;
        }
        if (T0.test(t)) {
          var f = t.toLowerCase(), m = hf.hasOwnProperty(f) ? f : null;
          if (m == null)
            return Ql[t] = !0, !1;
          if (t !== m)
            return p("Unknown ARIA attribute `%s`. Did you mean `%s`?", t, m), Ql[t] = !0, !0;
        }
      }
      return !0;
    }
    function Ku(e, t) {
      {
        var a = [];
        for (var u in t) {
          var f = _h(e, u);
          f || a.push(u);
        }
        var m = a.map(function(y) {
          return "`" + y + "`";
        }).join(", ");
        a.length === 1 ? p("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", m, e) : a.length > 1 && p("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", m, e);
      }
    }
    function xh(e, t) {
      fo(e, t) || Ku(e, t);
    }
    var Ch = !1;
    function pf(e, t) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        t != null && t.value === null && !Ch && (Ch = !0, e === "select" && t.multiple ? p("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : p("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var Ko = function() {
    };
    {
      var $r = {}, Rh = /^on./, mf = /^on[^A-Z]/, fv = new RegExp("^(aria)-[" + Me + "]*$"), dv = new RegExp("^(aria)[A-Z][" + Me + "]*$");
      Ko = function(e, t, a, u) {
        if (dr.call($r, t) && $r[t])
          return !0;
        var f = t.toLowerCase();
        if (f === "onfocusin" || f === "onfocusout")
          return p("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), $r[t] = !0, !0;
        if (u != null) {
          var m = u.registrationNameDependencies, y = u.possibleRegistrationNames;
          if (m.hasOwnProperty(t))
            return !0;
          var S = y.hasOwnProperty(f) ? y[f] : null;
          if (S != null)
            return p("Invalid event handler property `%s`. Did you mean `%s`?", t, S), $r[t] = !0, !0;
          if (Rh.test(t))
            return p("Unknown event handler property `%s`. It will be ignored.", t), $r[t] = !0, !0;
        } else if (Rh.test(t))
          return mf.test(t) && p("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", t), $r[t] = !0, !0;
        if (fv.test(t) || dv.test(t))
          return !0;
        if (f === "innerhtml")
          return p("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), $r[t] = !0, !0;
        if (f === "aria")
          return p("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), $r[t] = !0, !0;
        if (f === "is" && a !== null && a !== void 0 && typeof a != "string")
          return p("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof a), $r[t] = !0, !0;
        if (typeof a == "number" && isNaN(a))
          return p("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", t), $r[t] = !0, !0;
        var w = gn(t), k = w !== null && w.type === Bn;
        if (Qu.hasOwnProperty(f)) {
          var M = Qu[f];
          if (M !== t)
            return p("Invalid DOM property `%s`. Did you mean `%s`?", t, M), $r[t] = !0, !0;
        } else if (!k && t !== f)
          return p("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", t, f), $r[t] = !0, !0;
        return typeof a == "boolean" && xn(t, a, w, !1) ? (a ? p('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', a, t, t, a, t) : p('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', a, t, t, a, t, t, t), $r[t] = !0, !0) : k ? !0 : xn(t, a, w, !1) ? ($r[t] = !0, !1) : ((a === "false" || a === "true") && w !== null && w.type === Tt && (p("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", a, t, a === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', t, a), $r[t] = !0), !0);
      };
    }
    var hv = function(e, t, a) {
      {
        var u = [];
        for (var f in t) {
          var m = Ko(e, f, t[f], a);
          m || u.push(f);
        }
        var y = u.map(function(S) {
          return "`" + S + "`";
        }).join(", ");
        u.length === 1 ? p("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", y, e) : u.length > 1 && p("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", y, e);
      }
    };
    function pv(e, t, a) {
      fo(e, t) || hv(e, t, a);
    }
    var Th = 1, vf = 2, ha = 4, kh = Th | vf | ha, Xo = null;
    function k0(e) {
      Xo !== null && p("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Xo = e;
    }
    function O0() {
      Xo === null && p("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Xo = null;
    }
    function Xu(e) {
      return e === Xo;
    }
    function Oh(e) {
      var t = e.target || e.srcElement || window;
      return t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === As ? t.parentNode : t;
    }
    var gf = null, Zo = null, yn = null;
    function yf(e) {
      var t = yu(e);
      if (t) {
        if (typeof gf != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var a = t.stateNode;
        if (a) {
          var u = Eg(a);
          gf(t.stateNode, t.type, u);
        }
      }
    }
    function bf(e) {
      gf = e;
    }
    function Xl(e) {
      Zo ? yn ? yn.push(e) : yn = [e] : Zo = e;
    }
    function mv() {
      return Zo !== null || yn !== null;
    }
    function Sf() {
      if (Zo) {
        var e = Zo, t = yn;
        if (Zo = null, yn = null, yf(e), t)
          for (var a = 0; a < t.length; a++)
            yf(t[a]);
      }
    }
    var Zl = function(e, t) {
      return e(t);
    }, Zu = function() {
    }, ho = !1;
    function vv() {
      var e = mv();
      e && (Zu(), Sf());
    }
    function gv(e, t, a) {
      if (ho)
        return e(t, a);
      ho = !0;
      try {
        return Zl(e, t, a);
      } finally {
        ho = !1, vv();
      }
    }
    function N0(e, t, a) {
      Zl = e, Zu = a;
    }
    function yv(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function Ef(e, t, a) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(a.disabled && yv(t));
        default:
          return !1;
      }
    }
    function po(e, t) {
      var a = e.stateNode;
      if (a === null)
        return null;
      var u = Eg(a);
      if (u === null)
        return null;
      var f = u[t];
      if (Ef(t, e.type, u))
        return null;
      if (f && typeof f != "function")
        throw new Error("Expected `" + t + "` listener to be a function, instead got a value of `" + typeof f + "` type.");
      return f;
    }
    var ec = !1;
    if (Un)
      try {
        var el = {};
        Object.defineProperty(el, "passive", {
          get: function() {
            ec = !0;
          }
        }), window.addEventListener("test", el, el), window.removeEventListener("test", el, el);
      } catch {
        ec = !1;
      }
    function wf(e, t, a, u, f, m, y, S, w) {
      var k = Array.prototype.slice.call(arguments, 3);
      try {
        t.apply(a, k);
      } catch (M) {
        this.onError(M);
      }
    }
    var _f = wf;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Nh = document.createElement("react");
      _f = function(t, a, u, f, m, y, S, w, k) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var M = document.createEvent("Event"), q = !1, H = !0, ee = window.event, re = Object.getOwnPropertyDescriptor(window, "event");
        function ce() {
          Nh.removeEventListener(fe, yt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = ee);
        }
        var Ie = Array.prototype.slice.call(arguments, 3);
        function yt() {
          q = !0, ce(), a.apply(u, Ie), H = !1;
        }
        var ut, tn = !1, Qt = !1;
        function J(Q) {
          if (ut = Q.error, tn = !0, ut === null && Q.colno === 0 && Q.lineno === 0 && (Qt = !0), Q.defaultPrevented && ut != null && typeof ut == "object")
            try {
              ut._suppressLogging = !0;
            } catch {
            }
        }
        var fe = "react-" + (t || "invokeguardedcallback");
        if (window.addEventListener("error", J), Nh.addEventListener(fe, yt, !1), M.initEvent(fe, !1, !1), Nh.dispatchEvent(M), re && Object.defineProperty(window, "event", re), q && H && (tn ? Qt && (ut = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : ut = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(ut)), window.removeEventListener("error", J), !q)
          return ce(), wf.apply(this, arguments);
      };
    }
    var bv = _f, eu = !1, xf = null, tu = !1, is = null, Sv = {
      onError: function(e) {
        eu = !0, xf = e;
      }
    };
    function mo(e, t, a, u, f, m, y, S, w) {
      eu = !1, xf = null, bv.apply(Sv, arguments);
    }
    function as(e, t, a, u, f, m, y, S, w) {
      if (mo.apply(this, arguments), eu) {
        var k = nc();
        tu || (tu = !0, is = k);
      }
    }
    function tc() {
      if (tu) {
        var e = is;
        throw tu = !1, is = null, e;
      }
    }
    function Ms() {
      return eu;
    }
    function nc() {
      if (eu) {
        var e = xf;
        return eu = !1, xf = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function nu(e) {
      return e._reactInternals;
    }
    function A0(e) {
      return e._reactInternals !== void 0;
    }
    function tl(e, t) {
      e._reactInternals = t;
    }
    var pt = (
      /*                      */
      0
    ), Fa = (
      /*                */
      1
    ), ir = (
      /*                    */
      2
    ), Xt = (
      /*                       */
      4
    ), pa = (
      /*                */
      16
    ), Ia = (
      /*                 */
      32
    ), Pn = (
      /*                     */
      64
    ), ft = (
      /*                   */
      128
    ), Ci = (
      /*            */
      256
    ), tr = (
      /*                          */
      512
    ), Rr = (
      /*                     */
      1024
    ), Ri = (
      /*                      */
      2048
    ), ma = (
      /*                    */
      4096
    ), vr = (
      /*                   */
      8192
    ), ru = (
      /*             */
      16384
    ), Ev = (
      /*               */
      32767
    ), rc = (
      /*                   */
      32768
    ), Ti = (
      /*                */
      65536
    ), Cf = (
      /* */
      131072
    ), ss = (
      /*                       */
      1048576
    ), iu = (
      /*                    */
      2097152
    ), js = (
      /*                 */
      4194304
    ), Rf = (
      /*                */
      8388608
    ), vo = (
      /*               */
      16777216
    ), os = (
      /*              */
      33554432
    ), go = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Xt | Rr | 0
    ), yo = ir | Xt | pa | Ia | tr | ma | vr, bo = Xt | Pn | tr | vr, Ls = Ri | pa, gr = js | Rf | iu, va = s.ReactCurrentOwner;
    function Yi(e) {
      var t = e, a = e;
      if (e.alternate)
        for (; t.return; )
          t = t.return;
      else {
        var u = t;
        do
          t = u, (t.flags & (ir | ma)) !== pt && (a = t.return), u = t.return;
        while (u);
      }
      return t.tag === O ? a : null;
    }
    function ls(e) {
      if (e.tag === Re) {
        var t = e.memoizedState;
        if (t === null) {
          var a = e.alternate;
          a !== null && (t = a.memoizedState);
        }
        if (t !== null)
          return t.dehydrated;
      }
      return null;
    }
    function us(e) {
      return e.tag === O ? e.stateNode.containerInfo : null;
    }
    function nl(e) {
      return Yi(e) === e;
    }
    function wv(e) {
      {
        var t = va.current;
        if (t !== null && t.tag === x) {
          var a = t, u = a.stateNode;
          u._warnedAboutRefsInRender || p("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Nt(a) || "A component"), u._warnedAboutRefsInRender = !0;
        }
      }
      var f = nu(e);
      return f ? Yi(f) === f : !1;
    }
    function Tf(e) {
      if (Yi(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function kf(e) {
      var t = e.alternate;
      if (!t) {
        var a = Yi(e);
        if (a === null)
          throw new Error("Unable to find node on an unmounted component.");
        return a !== e ? null : e;
      }
      for (var u = e, f = t; ; ) {
        var m = u.return;
        if (m === null)
          break;
        var y = m.alternate;
        if (y === null) {
          var S = m.return;
          if (S !== null) {
            u = f = S;
            continue;
          }
          break;
        }
        if (m.child === y.child) {
          for (var w = m.child; w; ) {
            if (w === u)
              return Tf(m), e;
            if (w === f)
              return Tf(m), t;
            w = w.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (u.return !== f.return)
          u = m, f = y;
        else {
          for (var k = !1, M = m.child; M; ) {
            if (M === u) {
              k = !0, u = m, f = y;
              break;
            }
            if (M === f) {
              k = !0, f = m, u = y;
              break;
            }
            M = M.sibling;
          }
          if (!k) {
            for (M = y.child; M; ) {
              if (M === u) {
                k = !0, u = y, f = m;
                break;
              }
              if (M === f) {
                k = !0, f = y, u = m;
                break;
              }
              M = M.sibling;
            }
            if (!k)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (u.alternate !== f)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (u.tag !== O)
        throw new Error("Unable to find node on an unmounted component.");
      return u.stateNode.current === u ? e : t;
    }
    function ki(e) {
      var t = kf(e);
      return t !== null ? Oi(t) : null;
    }
    function Oi(e) {
      if (e.tag === z || e.tag === B)
        return e;
      for (var t = e.child; t !== null; ) {
        var a = Oi(t);
        if (a !== null)
          return a;
        t = t.sibling;
      }
      return null;
    }
    function Hn(e) {
      var t = kf(e);
      return t !== null ? ga(t) : null;
    }
    function ga(e) {
      if (e.tag === z || e.tag === B)
        return e;
      for (var t = e.child; t !== null; ) {
        if (t.tag !== P) {
          var a = ga(t);
          if (a !== null)
            return a;
        }
        t = t.sibling;
      }
      return null;
    }
    var Ah = n.unstable_scheduleCallback, _v = n.unstable_cancelCallback, Dh = n.unstable_shouldYield, Mh = n.unstable_requestPaint, Tr = n.unstable_now, Of = n.unstable_getCurrentPriorityLevel, ic = n.unstable_ImmediatePriority, So = n.unstable_UserBlockingPriority, Ps = n.unstable_NormalPriority, D0 = n.unstable_LowPriority, rl = n.unstable_IdlePriority, Nf = n.unstable_yieldValue, xv = n.unstable_setDisableYieldValue, il = null, ar = null, Fe = null, Wi = !1, Ni = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function au(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t.isDisabled)
        return !0;
      if (!t.supportsFiber)
        return p("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        st && (e = U({}, e, {
          getLaneLabelMap: al,
          injectProfilingHooks: ya
        })), il = t.inject(e), ar = t;
      } catch (a) {
        p("React instrumentation encountered an error: %s.", a);
      }
      return !!t.checkDCE;
    }
    function jh(e, t) {
      if (ar && typeof ar.onScheduleFiberRoot == "function")
        try {
          ar.onScheduleFiberRoot(il, e, t);
        } catch (a) {
          Wi || (Wi = !0, p("React instrumentation encountered an error: %s", a));
        }
    }
    function Lh(e, t) {
      if (ar && typeof ar.onCommitFiberRoot == "function")
        try {
          var a = (e.current.flags & ft) === ft;
          if (dt) {
            var u;
            switch (t) {
              case li:
                u = ic;
                break;
              case fs:
                u = So;
                break;
              case ba:
                u = Ps;
                break;
              case Sa:
                u = rl;
                break;
              default:
                u = Ps;
                break;
            }
            ar.onCommitFiberRoot(il, e, u, a);
          }
        } catch (f) {
          Wi || (Wi = !0, p("React instrumentation encountered an error: %s", f));
        }
    }
    function Ph(e) {
      if (ar && typeof ar.onPostCommitFiberRoot == "function")
        try {
          ar.onPostCommitFiberRoot(il, e);
        } catch (t) {
          Wi || (Wi = !0, p("React instrumentation encountered an error: %s", t));
        }
    }
    function Uh(e) {
      if (ar && typeof ar.onCommitFiberUnmount == "function")
        try {
          ar.onCommitFiberUnmount(il, e);
        } catch (t) {
          Wi || (Wi = !0, p("React instrumentation encountered an error: %s", t));
        }
    }
    function Gn(e) {
      if (typeof Nf == "function" && (xv(e), d(e)), ar && typeof ar.setStrictMode == "function")
        try {
          ar.setStrictMode(il, e);
        } catch (t) {
          Wi || (Wi = !0, p("React instrumentation encountered an error: %s", t));
        }
    }
    function ya(e) {
      Fe = e;
    }
    function al() {
      {
        for (var e = /* @__PURE__ */ new Map(), t = 1, a = 0; a < ll; a++) {
          var u = kv(t);
          e.set(t, u), t *= 2;
        }
        return e;
      }
    }
    function Fh(e) {
      Fe !== null && typeof Fe.markCommitStarted == "function" && Fe.markCommitStarted(e);
    }
    function Ih() {
      Fe !== null && typeof Fe.markCommitStopped == "function" && Fe.markCommitStopped();
    }
    function Gi(e) {
      Fe !== null && typeof Fe.markComponentRenderStarted == "function" && Fe.markComponentRenderStarted(e);
    }
    function Ji() {
      Fe !== null && typeof Fe.markComponentRenderStopped == "function" && Fe.markComponentRenderStopped();
    }
    function zh(e) {
      Fe !== null && typeof Fe.markComponentPassiveEffectMountStarted == "function" && Fe.markComponentPassiveEffectMountStarted(e);
    }
    function Cv() {
      Fe !== null && typeof Fe.markComponentPassiveEffectMountStopped == "function" && Fe.markComponentPassiveEffectMountStopped();
    }
    function Us(e) {
      Fe !== null && typeof Fe.markComponentPassiveEffectUnmountStarted == "function" && Fe.markComponentPassiveEffectUnmountStarted(e);
    }
    function Eo() {
      Fe !== null && typeof Fe.markComponentPassiveEffectUnmountStopped == "function" && Fe.markComponentPassiveEffectUnmountStopped();
    }
    function Af(e) {
      Fe !== null && typeof Fe.markComponentLayoutEffectMountStarted == "function" && Fe.markComponentLayoutEffectMountStarted(e);
    }
    function Rv() {
      Fe !== null && typeof Fe.markComponentLayoutEffectMountStopped == "function" && Fe.markComponentLayoutEffectMountStopped();
    }
    function ac(e) {
      Fe !== null && typeof Fe.markComponentLayoutEffectUnmountStarted == "function" && Fe.markComponentLayoutEffectUnmountStarted(e);
    }
    function $h() {
      Fe !== null && typeof Fe.markComponentLayoutEffectUnmountStopped == "function" && Fe.markComponentLayoutEffectUnmountStopped();
    }
    function sc(e, t, a) {
      Fe !== null && typeof Fe.markComponentErrored == "function" && Fe.markComponentErrored(e, t, a);
    }
    function cs(e, t, a) {
      Fe !== null && typeof Fe.markComponentSuspended == "function" && Fe.markComponentSuspended(e, t, a);
    }
    function oc(e) {
      Fe !== null && typeof Fe.markLayoutEffectsStarted == "function" && Fe.markLayoutEffectsStarted(e);
    }
    function lc() {
      Fe !== null && typeof Fe.markLayoutEffectsStopped == "function" && Fe.markLayoutEffectsStopped();
    }
    function sl(e) {
      Fe !== null && typeof Fe.markPassiveEffectsStarted == "function" && Fe.markPassiveEffectsStarted(e);
    }
    function Bh() {
      Fe !== null && typeof Fe.markPassiveEffectsStopped == "function" && Fe.markPassiveEffectsStopped();
    }
    function ol(e) {
      Fe !== null && typeof Fe.markRenderStarted == "function" && Fe.markRenderStarted(e);
    }
    function Tv() {
      Fe !== null && typeof Fe.markRenderYielded == "function" && Fe.markRenderYielded();
    }
    function Df() {
      Fe !== null && typeof Fe.markRenderStopped == "function" && Fe.markRenderStopped();
    }
    function Jn(e) {
      Fe !== null && typeof Fe.markRenderScheduled == "function" && Fe.markRenderScheduled(e);
    }
    function Mf(e, t) {
      Fe !== null && typeof Fe.markForceUpdateScheduled == "function" && Fe.markForceUpdateScheduled(e, t);
    }
    function uc(e, t) {
      Fe !== null && typeof Fe.markStateUpdateScheduled == "function" && Fe.markStateUpdateScheduled(e, t);
    }
    var mt = (
      /*                         */
      0
    ), qt = (
      /*                 */
      1
    ), fn = (
      /*                    */
      2
    ), On = (
      /*               */
      8
    ), dn = (
      /*              */
      16
    ), yr = Math.clz32 ? Math.clz32 : cc, Mr = Math.log, jf = Math.LN2;
    function cc(e) {
      var t = e >>> 0;
      return t === 0 ? 32 : 31 - (Mr(t) / jf | 0) | 0;
    }
    var ll = 31, Se = (
      /*                        */
      0
    ), ln = (
      /*                          */
      0
    ), Ct = (
      /*                        */
      1
    ), wo = (
      /*    */
      2
    ), za = (
      /*             */
      4
    ), ti = (
      /*            */
      8
    ), sr = (
      /*                     */
      16
    ), Fs = (
      /*                */
      32
    ), _o = (
      /*                       */
      4194240
    ), ul = (
      /*                        */
      64
    ), Lf = (
      /*                        */
      128
    ), Pf = (
      /*                        */
      256
    ), Uf = (
      /*                        */
      512
    ), Ff = (
      /*                        */
      1024
    ), If = (
      /*                        */
      2048
    ), zf = (
      /*                        */
      4096
    ), $f = (
      /*                        */
      8192
    ), Bf = (
      /*                        */
      16384
    ), cl = (
      /*                       */
      32768
    ), Hf = (
      /*                       */
      65536
    ), su = (
      /*                       */
      131072
    ), ou = (
      /*                       */
      262144
    ), Vf = (
      /*                       */
      524288
    ), fc = (
      /*                       */
      1048576
    ), qf = (
      /*                       */
      2097152
    ), dc = (
      /*                            */
      130023424
    ), fl = (
      /*                             */
      4194304
    ), Yf = (
      /*                             */
      8388608
    ), hc = (
      /*                             */
      16777216
    ), Wf = (
      /*                             */
      33554432
    ), Gf = (
      /*                             */
      67108864
    ), Hh = fl, pc = (
      /*          */
      134217728
    ), Vh = (
      /*                          */
      268435455
    ), mc = (
      /*               */
      268435456
    ), dl = (
      /*                        */
      536870912
    ), Qi = (
      /*                   */
      1073741824
    );
    function kv(e) {
      {
        if (e & Ct)
          return "Sync";
        if (e & wo)
          return "InputContinuousHydration";
        if (e & za)
          return "InputContinuous";
        if (e & ti)
          return "DefaultHydration";
        if (e & sr)
          return "Default";
        if (e & Fs)
          return "TransitionHydration";
        if (e & _o)
          return "Transition";
        if (e & dc)
          return "Retry";
        if (e & pc)
          return "SelectiveHydration";
        if (e & mc)
          return "IdleHydration";
        if (e & dl)
          return "Idle";
        if (e & Qi)
          return "Offscreen";
      }
    }
    var Mn = -1, hl = ul, Jf = fl;
    function vc(e) {
      switch (xo(e)) {
        case Ct:
          return Ct;
        case wo:
          return wo;
        case za:
          return za;
        case ti:
          return ti;
        case sr:
          return sr;
        case Fs:
          return Fs;
        case ul:
        case Lf:
        case Pf:
        case Uf:
        case Ff:
        case If:
        case zf:
        case $f:
        case Bf:
        case cl:
        case Hf:
        case su:
        case ou:
        case Vf:
        case fc:
        case qf:
          return e & _o;
        case fl:
        case Yf:
        case hc:
        case Wf:
        case Gf:
          return e & dc;
        case pc:
          return pc;
        case mc:
          return mc;
        case dl:
          return dl;
        case Qi:
          return Qi;
        default:
          return p("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function Qf(e, t) {
      var a = e.pendingLanes;
      if (a === Se)
        return Se;
      var u = Se, f = e.suspendedLanes, m = e.pingedLanes, y = a & Vh;
      if (y !== Se) {
        var S = y & ~f;
        if (S !== Se)
          u = vc(S);
        else {
          var w = y & m;
          w !== Se && (u = vc(w));
        }
      } else {
        var k = a & ~f;
        k !== Se ? u = vc(k) : m !== Se && (u = vc(m));
      }
      if (u === Se)
        return Se;
      if (t !== Se && t !== u && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (t & f) === Se) {
        var M = xo(u), q = xo(t);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          M >= q || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          M === sr && (q & _o) !== Se
        )
          return t;
      }
      (u & za) !== Se && (u |= a & sr);
      var H = e.entangledLanes;
      if (H !== Se)
        for (var ee = e.entanglements, re = u & H; re > 0; ) {
          var ce = br(re), Ie = 1 << ce;
          u |= ee[ce], re &= ~Ie;
        }
      return u;
    }
    function $a(e, t) {
      for (var a = e.eventTimes, u = Mn; t > 0; ) {
        var f = br(t), m = 1 << f, y = a[f];
        y > u && (u = y), t &= ~m;
      }
      return u;
    }
    function qh(e, t) {
      switch (e) {
        case Ct:
        case wo:
        case za:
          return t + 250;
        case ti:
        case sr:
        case Fs:
        case ul:
        case Lf:
        case Pf:
        case Uf:
        case Ff:
        case If:
        case zf:
        case $f:
        case Bf:
        case cl:
        case Hf:
        case su:
        case ou:
        case Vf:
        case fc:
        case qf:
          return t + 5e3;
        case fl:
        case Yf:
        case hc:
        case Wf:
        case Gf:
          return Mn;
        case pc:
        case mc:
        case dl:
        case Qi:
          return Mn;
        default:
          return p("Should have found matching lanes. This is a bug in React."), Mn;
      }
    }
    function Kf(e, t) {
      for (var a = e.pendingLanes, u = e.suspendedLanes, f = e.pingedLanes, m = e.expirationTimes, y = a; y > 0; ) {
        var S = br(y), w = 1 << S, k = m[S];
        k === Mn ? ((w & u) === Se || (w & f) !== Se) && (m[S] = qh(w, t)) : k <= t && (e.expiredLanes |= w), y &= ~w;
      }
    }
    function Ov(e) {
      return vc(e.pendingLanes);
    }
    function Xf(e) {
      var t = e.pendingLanes & -1073741825;
      return t !== Se ? t : t & Qi ? Qi : Se;
    }
    function Nv(e) {
      return (e & Ct) !== Se;
    }
    function gc(e) {
      return (e & Vh) !== Se;
    }
    function pl(e) {
      return (e & dc) === e;
    }
    function Yh(e) {
      var t = Ct | za | sr;
      return (e & t) === Se;
    }
    function Wh(e) {
      return (e & _o) === e;
    }
    function Zf(e, t) {
      var a = wo | za | ti | sr;
      return (t & a) !== Se;
    }
    function Av(e, t) {
      return (t & e.expiredLanes) !== Se;
    }
    function Gh(e) {
      return (e & _o) !== Se;
    }
    function Jh() {
      var e = hl;
      return hl <<= 1, (hl & _o) === Se && (hl = ul), e;
    }
    function Dv() {
      var e = Jf;
      return Jf <<= 1, (Jf & dc) === Se && (Jf = fl), e;
    }
    function xo(e) {
      return e & -e;
    }
    function yc(e) {
      return xo(e);
    }
    function br(e) {
      return 31 - yr(e);
    }
    function Br(e) {
      return br(e);
    }
    function Ai(e, t) {
      return (e & t) !== Se;
    }
    function ml(e, t) {
      return (e & t) === t;
    }
    function It(e, t) {
      return e | t;
    }
    function bc(e, t) {
      return e & ~t;
    }
    function Qh(e, t) {
      return e & t;
    }
    function Mv(e) {
      return e;
    }
    function jv(e, t) {
      return e !== ln && e < t ? e : t;
    }
    function Sc(e) {
      for (var t = [], a = 0; a < ll; a++)
        t.push(e);
      return t;
    }
    function lu(e, t, a) {
      e.pendingLanes |= t, t !== dl && (e.suspendedLanes = Se, e.pingedLanes = Se);
      var u = e.eventTimes, f = Br(t);
      u[f] = a;
    }
    function Lv(e, t) {
      e.suspendedLanes |= t, e.pingedLanes &= ~t;
      for (var a = e.expirationTimes, u = t; u > 0; ) {
        var f = br(u), m = 1 << f;
        a[f] = Mn, u &= ~m;
      }
    }
    function ed(e, t, a) {
      e.pingedLanes |= e.suspendedLanes & t;
    }
    function Kh(e, t) {
      var a = e.pendingLanes & ~t;
      e.pendingLanes = t, e.suspendedLanes = Se, e.pingedLanes = Se, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t;
      for (var u = e.entanglements, f = e.eventTimes, m = e.expirationTimes, y = a; y > 0; ) {
        var S = br(y), w = 1 << S;
        u[S] = Se, f[S] = Mn, m[S] = Mn, y &= ~w;
      }
    }
    function td(e, t) {
      for (var a = e.entangledLanes |= t, u = e.entanglements, f = a; f; ) {
        var m = br(f), y = 1 << m;
        // Is this one of the newly entangled lanes?
        y & t | // Is this lane transitively entangled with the newly entangled lanes?
        u[m] & t && (u[m] |= t), f &= ~y;
      }
    }
    function Xh(e, t) {
      var a = xo(t), u;
      switch (a) {
        case za:
          u = wo;
          break;
        case sr:
          u = ti;
          break;
        case ul:
        case Lf:
        case Pf:
        case Uf:
        case Ff:
        case If:
        case zf:
        case $f:
        case Bf:
        case cl:
        case Hf:
        case su:
        case ou:
        case Vf:
        case fc:
        case qf:
        case fl:
        case Yf:
        case hc:
        case Wf:
        case Gf:
          u = Fs;
          break;
        case dl:
          u = mc;
          break;
        default:
          u = ln;
          break;
      }
      return (u & (e.suspendedLanes | t)) !== ln ? ln : u;
    }
    function Ec(e, t, a) {
      if (Ni)
        for (var u = e.pendingUpdatersLaneMap; a > 0; ) {
          var f = Br(a), m = 1 << f, y = u[f];
          y.add(t), a &= ~m;
        }
    }
    function Pv(e, t) {
      if (Ni)
        for (var a = e.pendingUpdatersLaneMap, u = e.memoizedUpdaters; t > 0; ) {
          var f = Br(t), m = 1 << f, y = a[f];
          y.size > 0 && (y.forEach(function(S) {
            var w = S.alternate;
            (w === null || !u.has(w)) && u.add(S);
          }), y.clear()), t &= ~m;
        }
    }
    function Zh(e, t) {
      return null;
    }
    var li = Ct, fs = za, ba = sr, Sa = dl, wc = ln;
    function Ea() {
      return wc;
    }
    function Sr(e) {
      wc = e;
    }
    function Uv(e, t) {
      var a = wc;
      try {
        return wc = e, t();
      } finally {
        wc = a;
      }
    }
    function Fv(e, t) {
      return e !== 0 && e < t ? e : t;
    }
    function _c(e, t) {
      return e > t ? e : t;
    }
    function jr(e, t) {
      return e !== 0 && e < t;
    }
    function Iv(e) {
      var t = xo(e);
      return jr(li, t) ? jr(fs, t) ? gc(t) ? ba : Sa : fs : li;
    }
    function nd(e) {
      var t = e.current.memoizedState;
      return t.isDehydrated;
    }
    var xc;
    function ni(e) {
      xc = e;
    }
    function M0(e) {
      xc(e);
    }
    var Xe;
    function uu(e) {
      Xe = e;
    }
    var rd;
    function zv(e) {
      rd = e;
    }
    var $v;
    function Cc(e) {
      $v = e;
    }
    var Rc;
    function ep(e) {
      Rc = e;
    }
    var id = !1, Tc = [], Is = null, ds = null, hs = null, or = /* @__PURE__ */ new Map(), ui = /* @__PURE__ */ new Map(), ci = [], Bv = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Hv(e) {
      return Bv.indexOf(e) > -1;
    }
    function Ba(e, t, a, u, f) {
      return {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: a,
        nativeEvent: f,
        targetContainers: [u]
      };
    }
    function tp(e, t) {
      switch (e) {
        case "focusin":
        case "focusout":
          Is = null;
          break;
        case "dragenter":
        case "dragleave":
          ds = null;
          break;
        case "mouseover":
        case "mouseout":
          hs = null;
          break;
        case "pointerover":
        case "pointerout": {
          var a = t.pointerId;
          or.delete(a);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var u = t.pointerId;
          ui.delete(u);
          break;
        }
      }
    }
    function Di(e, t, a, u, f, m) {
      if (e === null || e.nativeEvent !== m) {
        var y = Ba(t, a, u, f, m);
        if (t !== null) {
          var S = yu(t);
          S !== null && Xe(S);
        }
        return y;
      }
      e.eventSystemFlags |= u;
      var w = e.targetContainers;
      return f !== null && w.indexOf(f) === -1 && w.push(f), e;
    }
    function j0(e, t, a, u, f) {
      switch (t) {
        case "focusin": {
          var m = f;
          return Is = Di(Is, e, t, a, u, m), !0;
        }
        case "dragenter": {
          var y = f;
          return ds = Di(ds, e, t, a, u, y), !0;
        }
        case "mouseover": {
          var S = f;
          return hs = Di(hs, e, t, a, u, S), !0;
        }
        case "pointerover": {
          var w = f, k = w.pointerId;
          return or.set(k, Di(or.get(k) || null, e, t, a, u, w)), !0;
        }
        case "gotpointercapture": {
          var M = f, q = M.pointerId;
          return ui.set(q, Di(ui.get(q) || null, e, t, a, u, M)), !0;
        }
      }
      return !1;
    }
    function np(e) {
      var t = Ic(e.target);
      if (t !== null) {
        var a = Yi(t);
        if (a !== null) {
          var u = a.tag;
          if (u === Re) {
            var f = ls(a);
            if (f !== null) {
              e.blockedOn = f, Rc(e.priority, function() {
                rd(a);
              });
              return;
            }
          } else if (u === O) {
            var m = a.stateNode;
            if (nd(m)) {
              e.blockedOn = us(a);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function Vv(e) {
      for (var t = $v(), a = {
        blockedOn: null,
        target: e,
        priority: t
      }, u = 0; u < ci.length && jr(t, ci[u].priority); u++)
        ;
      ci.splice(u, 0, a), u === 0 && np(a);
    }
    function kc(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var t = e.targetContainers; t.length > 0; ) {
        var a = t[0], u = fu(e.domEventName, e.eventSystemFlags, a, e.nativeEvent);
        if (u === null) {
          var f = e.nativeEvent, m = new f.constructor(f.type, f);
          k0(m), f.target.dispatchEvent(m), O0();
        } else {
          var y = yu(u);
          return y !== null && Xe(y), e.blockedOn = u, !1;
        }
        t.shift();
      }
      return !0;
    }
    function rp(e, t, a) {
      kc(e) && a.delete(t);
    }
    function L0() {
      id = !1, Is !== null && kc(Is) && (Is = null), ds !== null && kc(ds) && (ds = null), hs !== null && kc(hs) && (hs = null), or.forEach(rp), ui.forEach(rp);
    }
    function Co(e, t) {
      e.blockedOn === t && (e.blockedOn = null, id || (id = !0, n.unstable_scheduleCallback(n.unstable_NormalPriority, L0)));
    }
    function vl(e) {
      if (Tc.length > 0) {
        Co(Tc[0], e);
        for (var t = 1; t < Tc.length; t++) {
          var a = Tc[t];
          a.blockedOn === e && (a.blockedOn = null);
        }
      }
      Is !== null && Co(Is, e), ds !== null && Co(ds, e), hs !== null && Co(hs, e);
      var u = function(S) {
        return Co(S, e);
      };
      or.forEach(u), ui.forEach(u);
      for (var f = 0; f < ci.length; f++) {
        var m = ci[f];
        m.blockedOn === e && (m.blockedOn = null);
      }
      for (; ci.length > 0; ) {
        var y = ci[0];
        if (y.blockedOn !== null)
          break;
        np(y), y.blockedOn === null && ci.shift();
      }
    }
    var Hr = s.ReactCurrentBatchConfig, Zt = !0;
    function kr(e) {
      Zt = !!e;
    }
    function Er() {
      return Zt;
    }
    function Vr(e, t, a) {
      var u = ad(t), f;
      switch (u) {
        case li:
          f = Ki;
          break;
        case fs:
          f = cu;
          break;
        case ba:
        default:
          f = lr;
          break;
      }
      return f.bind(null, t, a, e);
    }
    function Ki(e, t, a, u) {
      var f = Ea(), m = Hr.transition;
      Hr.transition = null;
      try {
        Sr(li), lr(e, t, a, u);
      } finally {
        Sr(f), Hr.transition = m;
      }
    }
    function cu(e, t, a, u) {
      var f = Ea(), m = Hr.transition;
      Hr.transition = null;
      try {
        Sr(fs), lr(e, t, a, u);
      } finally {
        Sr(f), Hr.transition = m;
      }
    }
    function lr(e, t, a, u) {
      Zt && Oc(e, t, a, u);
    }
    function Oc(e, t, a, u) {
      var f = fu(e, t, a, u);
      if (f === null) {
        Z0(e, t, u, ps, a), tp(e, u);
        return;
      }
      if (j0(f, e, t, a, u)) {
        u.stopPropagation();
        return;
      }
      if (tp(e, u), t & ha && Hv(e)) {
        for (; f !== null; ) {
          var m = yu(f);
          m !== null && M0(m);
          var y = fu(e, t, a, u);
          if (y === null && Z0(e, t, u, ps, a), y === f)
            break;
          f = y;
        }
        f !== null && u.stopPropagation();
        return;
      }
      Z0(e, t, u, null, a);
    }
    var ps = null;
    function fu(e, t, a, u) {
      ps = null;
      var f = Oh(u), m = Ic(f);
      if (m !== null) {
        var y = Yi(m);
        if (y === null)
          m = null;
        else {
          var S = y.tag;
          if (S === Re) {
            var w = ls(y);
            if (w !== null)
              return w;
            m = null;
          } else if (S === O) {
            var k = y.stateNode;
            if (nd(k))
              return us(y);
            m = null;
          } else y !== m && (m = null);
        }
      }
      return ps = m, null;
    }
    function ad(e) {
      switch (e) {
        // Used by SimpleEventPlugin:
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        // Used by polyfills:
        // eslint-disable-next-line no-fallthrough
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        // Only enableCreateEventHandleAPI:
        // eslint-disable-next-line no-fallthrough
        case "beforeblur":
        case "afterblur":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return li;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return fs;
        case "message": {
          var t = Of();
          switch (t) {
            case ic:
              return li;
            case So:
              return fs;
            case Ps:
            case D0:
              return ba;
            case rl:
              return Sa;
            default:
              return ba;
          }
        }
        default:
          return ba;
      }
    }
    function Nc(e, t, a) {
      return e.addEventListener(t, a, !1), a;
    }
    function Mi(e, t, a) {
      return e.addEventListener(t, a, !0), a;
    }
    function ip(e, t, a, u) {
      return e.addEventListener(t, a, {
        capture: !0,
        passive: u
      }), a;
    }
    function du(e, t, a, u) {
      return e.addEventListener(t, a, {
        passive: u
      }), a;
    }
    var Xi = null, hu = null, gl = null;
    function Ro(e) {
      return Xi = e, hu = Ac(), !0;
    }
    function sd() {
      Xi = null, hu = null, gl = null;
    }
    function zs() {
      if (gl)
        return gl;
      var e, t = hu, a = t.length, u, f = Ac(), m = f.length;
      for (e = 0; e < a && t[e] === f[e]; e++)
        ;
      var y = a - e;
      for (u = 1; u <= y && t[a - u] === f[m - u]; u++)
        ;
      var S = u > 1 ? 1 - u : void 0;
      return gl = f.slice(e, S), gl;
    }
    function Ac() {
      return "value" in Xi ? Xi.value : Xi.textContent;
    }
    function To(e) {
      var t, a = e.keyCode;
      return "charCode" in e ? (t = e.charCode, t === 0 && a === 13 && (t = 13)) : t = a, t === 10 && (t = 13), t >= 32 || t === 13 ? t : 0;
    }
    function pu() {
      return !0;
    }
    function Dc() {
      return !1;
    }
    function ri(e) {
      function t(a, u, f, m, y) {
        this._reactName = a, this._targetInst = f, this.type = u, this.nativeEvent = m, this.target = y, this.currentTarget = null;
        for (var S in e)
          if (e.hasOwnProperty(S)) {
            var w = e[S];
            w ? this[S] = w(m) : this[S] = m[S];
          }
        var k = m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1;
        return k ? this.isDefaultPrevented = pu : this.isDefaultPrevented = Dc, this.isPropagationStopped = Dc, this;
      }
      return U(t.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var a = this.nativeEvent;
          a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1), this.isDefaultPrevented = pu);
        },
        stopPropagation: function() {
          var a = this.nativeEvent;
          a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0), this.isPropagationStopped = pu);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: pu
      }), t;
    }
    var wr = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, ms = ri(wr), fi = U({}, wr, {
      view: 0,
      detail: 0
    }), ji = ri(fi), od, Mc, yl;
    function P0(e) {
      e !== yl && (yl && e.type === "mousemove" ? (od = e.screenX - yl.screenX, Mc = e.screenY - yl.screenY) : (od = 0, Mc = 0), yl = e);
    }
    var Ha = U({}, fi, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Vn,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (P0(e), od);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : Mc;
      }
    }), ap = ri(Ha), sp = U({}, Ha, {
      dataTransfer: 0
    }), bl = ri(sp), op = U({}, fi, {
      relatedTarget: 0
    }), $s = ri(op), qv = U({}, wr, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Yv = ri(qv), lp = U({}, wr, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), ld = ri(lp), U0 = U({}, wr, {
      data: 0
    }), Wv = ri(U0), Gv = Wv, Jv = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Sl = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function F0(e) {
      if (e.key) {
        var t = Jv[e.key] || e.key;
        if (t !== "Unidentified")
          return t;
      }
      if (e.type === "keypress") {
        var a = To(e);
        return a === 13 ? "Enter" : String.fromCharCode(a);
      }
      return e.type === "keydown" || e.type === "keyup" ? Sl[e.keyCode] || "Unidentified" : "";
    }
    var mu = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Qv(e) {
      var t = this, a = t.nativeEvent;
      if (a.getModifierState)
        return a.getModifierState(e);
      var u = mu[e];
      return u ? !!a[u] : !1;
    }
    function Vn(e) {
      return Qv;
    }
    var I0 = U({}, fi, {
      key: F0,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Vn,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? To(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? To(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), Kv = ri(I0), z0 = U({}, Ha, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Xv = ri(z0), Zv = U({}, fi, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Vn
    }), eg = ri(Zv), $0 = U({}, wr, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), wa = ri($0), up = U({}, Ha, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), B0 = ri(up), ko = [9, 13, 27, 32], jc = 229, Bs = Un && "CompositionEvent" in window, Oo = null;
    Un && "documentMode" in document && (Oo = document.documentMode);
    var cp = Un && "TextEvent" in window && !Oo, ud = Un && (!Bs || Oo && Oo > 8 && Oo <= 11), tg = 32, cd = String.fromCharCode(tg);
    function H0() {
      Ae("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Ae("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Ae("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Ae("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var fp = !1;
    function ng(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function fd(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function dd(e, t) {
      return e === "keydown" && t.keyCode === jc;
    }
    function dp(e, t) {
      switch (e) {
        case "keyup":
          return ko.indexOf(t.keyCode) !== -1;
        case "keydown":
          return t.keyCode !== jc;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function hd(e) {
      var t = e.detail;
      return typeof t == "object" && "data" in t ? t.data : null;
    }
    function hp(e) {
      return e.locale === "ko";
    }
    var No = !1;
    function pd(e, t, a, u, f) {
      var m, y;
      if (Bs ? m = fd(t) : No ? dp(t, u) && (m = "onCompositionEnd") : dd(t, u) && (m = "onCompositionStart"), !m)
        return null;
      ud && !hp(u) && (!No && m === "onCompositionStart" ? No = Ro(f) : m === "onCompositionEnd" && No && (y = zs()));
      var S = lg(a, m);
      if (S.length > 0) {
        var w = new Wv(m, t, null, u, f);
        if (e.push({
          event: w,
          listeners: S
        }), y)
          w.data = y;
        else {
          var k = hd(u);
          k !== null && (w.data = k);
        }
      }
    }
    function pp(e, t) {
      switch (e) {
        case "compositionend":
          return hd(t);
        case "keypress":
          var a = t.which;
          return a !== tg ? null : (fp = !0, cd);
        case "textInput":
          var u = t.data;
          return u === cd && fp ? null : u;
        default:
          return null;
      }
    }
    function md(e, t) {
      if (No) {
        if (e === "compositionend" || !Bs && dp(e, t)) {
          var a = zs();
          return sd(), No = !1, a;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!ng(t)) {
            if (t.char && t.char.length > 1)
              return t.char;
            if (t.which)
              return String.fromCharCode(t.which);
          }
          return null;
        case "compositionend":
          return ud && !hp(t) ? null : t.data;
        default:
          return null;
      }
    }
    function rg(e, t, a, u, f) {
      var m;
      if (cp ? m = pp(t, u) : m = md(t, u), !m)
        return null;
      var y = lg(a, "onBeforeInput");
      if (y.length > 0) {
        var S = new Gv("onBeforeInput", "beforeinput", null, u, f);
        e.push({
          event: S,
          listeners: y
        }), S.data = m;
      }
    }
    function V0(e, t, a, u, f, m, y) {
      pd(e, t, a, u, f), rg(e, t, a, u, f);
    }
    var vd = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function ig(e) {
      var t = e && e.nodeName && e.nodeName.toLowerCase();
      return t === "input" ? !!vd[e.type] : t === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function Lc(e) {
      if (!Un)
        return !1;
      var t = "on" + e, a = t in document;
      if (!a) {
        var u = document.createElement("div");
        u.setAttribute(t, "return;"), a = typeof u[t] == "function";
      }
      return a;
    }
    function q0() {
      Ae("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function Pc(e, t, a, u) {
      Xl(u);
      var f = lg(t, "onChange");
      if (f.length > 0) {
        var m = new ms("onChange", "change", null, a, u);
        e.push({
          event: m,
          listeners: f
        });
      }
    }
    var r = null, i = null;
    function c(e) {
      var t = e.nodeName && e.nodeName.toLowerCase();
      return t === "select" || t === "input" && e.type === "file";
    }
    function h(e) {
      var t = [];
      Pc(t, i, e, Oh(e)), gv(g, t);
    }
    function g(e) {
      n_(e, 0);
    }
    function b(e) {
      var t = wd(e);
      if (ns(t))
        return e;
    }
    function R(e, t) {
      if (e === "change")
        return t;
    }
    var L = !1;
    Un && (L = Lc("input") && (!document.documentMode || document.documentMode > 9));
    function $(e, t) {
      r = e, i = t, r.attachEvent("onpropertychange", we);
    }
    function ne() {
      r && (r.detachEvent("onpropertychange", we), r = null, i = null);
    }
    function we(e) {
      e.propertyName === "value" && b(i) && h(e);
    }
    function _e(e, t, a) {
      e === "focusin" ? (ne(), $(t, a)) : e === "focusout" && ne();
    }
    function Ee(e, t) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return b(i);
    }
    function Ge(e) {
      var t = e.nodeName;
      return t && t.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function et(e, t) {
      if (e === "click")
        return b(t);
    }
    function rt(e, t) {
      if (e === "input" || e === "change")
        return b(t);
    }
    function ur(e) {
      var t = e._wrapperState;
      !t || !t.controlled || e.type !== "number" || gt(e, "number", e.value);
    }
    function G(e, t, a, u, f, m, y) {
      var S = a ? wd(a) : window, w, k;
      if (c(S) ? w = R : ig(S) ? L ? w = rt : (w = Ee, k = _e) : Ge(S) && (w = et), w) {
        var M = w(t, a);
        if (M) {
          Pc(e, M, u, f);
          return;
        }
      }
      k && k(t, S, a), t === "focusout" && ur(S);
    }
    function V() {
      Lt("onMouseEnter", ["mouseout", "mouseover"]), Lt("onMouseLeave", ["mouseout", "mouseover"]), Lt("onPointerEnter", ["pointerout", "pointerover"]), Lt("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function X(e, t, a, u, f, m, y) {
      var S = t === "mouseover" || t === "pointerover", w = t === "mouseout" || t === "pointerout";
      if (S && !Xu(u)) {
        var k = u.relatedTarget || u.fromElement;
        if (k && (Ic(k) || kp(k)))
          return;
      }
      if (!(!w && !S)) {
        var M;
        if (f.window === f)
          M = f;
        else {
          var q = f.ownerDocument;
          q ? M = q.defaultView || q.parentWindow : M = window;
        }
        var H, ee;
        if (w) {
          var re = u.relatedTarget || u.toElement;
          if (H = a, ee = re ? Ic(re) : null, ee !== null) {
            var ce = Yi(ee);
            (ee !== ce || ee.tag !== z && ee.tag !== B) && (ee = null);
          }
        } else
          H = null, ee = a;
        if (H !== ee) {
          var Ie = ap, yt = "onMouseLeave", ut = "onMouseEnter", tn = "mouse";
          (t === "pointerout" || t === "pointerover") && (Ie = Xv, yt = "onPointerLeave", ut = "onPointerEnter", tn = "pointer");
          var Qt = H == null ? M : wd(H), J = ee == null ? M : wd(ee), fe = new Ie(yt, tn + "leave", H, u, f);
          fe.target = Qt, fe.relatedTarget = J;
          var Q = null, xe = Ic(f);
          if (xe === a) {
            var Qe = new Ie(ut, tn + "enter", ee, u, f);
            Qe.target = J, Qe.relatedTarget = Qt, Q = Qe;
          }
          fk(e, fe, Q, H, ee);
        }
      }
    }
    function Oe(e, t) {
      return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
    }
    var Be = typeof Object.is == "function" ? Object.is : Oe;
    function vt(e, t) {
      if (Be(e, t))
        return !0;
      if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
      var a = Object.keys(e), u = Object.keys(t);
      if (a.length !== u.length)
        return !1;
      for (var f = 0; f < a.length; f++) {
        var m = a[f];
        if (!dr.call(t, m) || !Be(e[m], t[m]))
          return !1;
      }
      return !0;
    }
    function bt(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function At(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function Or(e, t) {
      for (var a = bt(e), u = 0, f = 0; a; ) {
        if (a.nodeType === As) {
          if (f = u + a.textContent.length, u <= t && f >= t)
            return {
              node: a,
              offset: t - u
            };
          u = f;
        }
        a = bt(At(a));
      }
    }
    function hn(e) {
      var t = e.ownerDocument, a = t && t.defaultView || window, u = a.getSelection && a.getSelection();
      if (!u || u.rangeCount === 0)
        return null;
      var f = u.anchorNode, m = u.anchorOffset, y = u.focusNode, S = u.focusOffset;
      try {
        f.nodeType, y.nodeType;
      } catch {
        return null;
      }
      return Ao(e, f, m, y, S);
    }
    function Ao(e, t, a, u, f) {
      var m = 0, y = -1, S = -1, w = 0, k = 0, M = e, q = null;
      e: for (; ; ) {
        for (var H = null; M === t && (a === 0 || M.nodeType === As) && (y = m + a), M === u && (f === 0 || M.nodeType === As) && (S = m + f), M.nodeType === As && (m += M.nodeValue.length), (H = M.firstChild) !== null; )
          q = M, M = H;
        for (; ; ) {
          if (M === e)
            break e;
          if (q === t && ++w === a && (y = m), q === u && ++k === f && (S = m), (H = M.nextSibling) !== null)
            break;
          M = q, q = M.parentNode;
        }
        M = H;
      }
      return y === -1 || S === -1 ? null : {
        start: y,
        end: S
      };
    }
    function Y0(e, t) {
      var a = e.ownerDocument || document, u = a && a.defaultView || window;
      if (u.getSelection) {
        var f = u.getSelection(), m = e.textContent.length, y = Math.min(t.start, m), S = t.end === void 0 ? y : Math.min(t.end, m);
        if (!f.extend && y > S) {
          var w = S;
          S = y, y = w;
        }
        var k = Or(e, y), M = Or(e, S);
        if (k && M) {
          if (f.rangeCount === 1 && f.anchorNode === k.node && f.anchorOffset === k.offset && f.focusNode === M.node && f.focusOffset === M.offset)
            return;
          var q = a.createRange();
          q.setStart(k.node, k.offset), f.removeAllRanges(), y > S ? (f.addRange(q), f.extend(M.node, M.offset)) : (q.setEnd(M.node, M.offset), f.addRange(q));
        }
      }
    }
    function Vw(e) {
      return e && e.nodeType === As;
    }
    function qw(e, t) {
      return !e || !t ? !1 : e === t ? !0 : Vw(e) ? !1 : Vw(t) ? qw(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1;
    }
    function WT(e) {
      return e && e.ownerDocument && qw(e.ownerDocument.documentElement, e);
    }
    function GT(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function Yw() {
      for (var e = window, t = da(); t instanceof e.HTMLIFrameElement; ) {
        if (GT(t))
          e = t.contentWindow;
        else
          return t;
        t = da(e.document);
      }
      return t;
    }
    function W0(e) {
      var t = e && e.nodeName && e.nodeName.toLowerCase();
      return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
    }
    function JT() {
      var e = Yw();
      return {
        focusedElem: e,
        selectionRange: W0(e) ? KT(e) : null
      };
    }
    function QT(e) {
      var t = Yw(), a = e.focusedElem, u = e.selectionRange;
      if (t !== a && WT(a)) {
        u !== null && W0(a) && XT(a, u);
        for (var f = [], m = a; m = m.parentNode; )
          m.nodeType === xi && f.push({
            element: m,
            left: m.scrollLeft,
            top: m.scrollTop
          });
        typeof a.focus == "function" && a.focus();
        for (var y = 0; y < f.length; y++) {
          var S = f[y];
          S.element.scrollLeft = S.left, S.element.scrollTop = S.top;
        }
      }
    }
    function KT(e) {
      var t;
      return "selectionStart" in e ? t = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : t = hn(e), t || {
        start: 0,
        end: 0
      };
    }
    function XT(e, t) {
      var a = t.start, u = t.end;
      u === void 0 && (u = a), "selectionStart" in e ? (e.selectionStart = a, e.selectionEnd = Math.min(u, e.value.length)) : Y0(e, t);
    }
    var ZT = Un && "documentMode" in document && document.documentMode <= 11;
    function ek() {
      Ae("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var gd = null, G0 = null, mp = null, J0 = !1;
    function tk(e) {
      if ("selectionStart" in e && W0(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var t = e.ownerDocument && e.ownerDocument.defaultView || window, a = t.getSelection();
      return {
        anchorNode: a.anchorNode,
        anchorOffset: a.anchorOffset,
        focusNode: a.focusNode,
        focusOffset: a.focusOffset
      };
    }
    function nk(e) {
      return e.window === e ? e.document : e.nodeType === Ds ? e : e.ownerDocument;
    }
    function Ww(e, t, a) {
      var u = nk(a);
      if (!(J0 || gd == null || gd !== da(u))) {
        var f = tk(gd);
        if (!mp || !vt(mp, f)) {
          mp = f;
          var m = lg(G0, "onSelect");
          if (m.length > 0) {
            var y = new ms("onSelect", "select", null, t, a);
            e.push({
              event: y,
              listeners: m
            }), y.target = gd;
          }
        }
      }
    }
    function rk(e, t, a, u, f, m, y) {
      var S = a ? wd(a) : window;
      switch (t) {
        // Track the input node that has focus.
        case "focusin":
          (ig(S) || S.contentEditable === "true") && (gd = S, G0 = a, mp = null);
          break;
        case "focusout":
          gd = null, G0 = null, mp = null;
          break;
        // Don't fire the event while the user is dragging. This matches the
        // semantics of the native select event.
        case "mousedown":
          J0 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          J0 = !1, Ww(e, u, f);
          break;
        // Chrome and IE fire non-standard event when selection is changed (and
        // sometimes when it hasn't). IE's event fires out of order with respect
        // to key and input events on deletion, so we discard it.
        //
        // Firefox doesn't support selectionchange, so check selection status
        // after each key entry. The selection changes after keydown and before
        // keyup, but we check on keydown as well in the case of holding down a
        // key, when multiple keydown events are fired but only one keyup is.
        // This is also our approach for IE handling, for the reason above.
        case "selectionchange":
          if (ZT)
            break;
        // falls through
        case "keydown":
        case "keyup":
          Ww(e, u, f);
      }
    }
    function ag(e, t) {
      var a = {};
      return a[e.toLowerCase()] = t.toLowerCase(), a["Webkit" + e] = "webkit" + t, a["Moz" + e] = "moz" + t, a;
    }
    var yd = {
      animationend: ag("Animation", "AnimationEnd"),
      animationiteration: ag("Animation", "AnimationIteration"),
      animationstart: ag("Animation", "AnimationStart"),
      transitionend: ag("Transition", "TransitionEnd")
    }, Q0 = {}, Gw = {};
    Un && (Gw = document.createElement("div").style, "AnimationEvent" in window || (delete yd.animationend.animation, delete yd.animationiteration.animation, delete yd.animationstart.animation), "TransitionEvent" in window || delete yd.transitionend.transition);
    function sg(e) {
      if (Q0[e])
        return Q0[e];
      if (!yd[e])
        return e;
      var t = yd[e];
      for (var a in t)
        if (t.hasOwnProperty(a) && a in Gw)
          return Q0[e] = t[a];
      return e;
    }
    var Jw = sg("animationend"), Qw = sg("animationiteration"), Kw = sg("animationstart"), Xw = sg("transitionend"), Zw = /* @__PURE__ */ new Map(), e_ = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function vu(e, t) {
      Zw.set(e, t), Ae(t, [e]);
    }
    function ik() {
      for (var e = 0; e < e_.length; e++) {
        var t = e_[e], a = t.toLowerCase(), u = t[0].toUpperCase() + t.slice(1);
        vu(a, "on" + u);
      }
      vu(Jw, "onAnimationEnd"), vu(Qw, "onAnimationIteration"), vu(Kw, "onAnimationStart"), vu("dblclick", "onDoubleClick"), vu("focusin", "onFocus"), vu("focusout", "onBlur"), vu(Xw, "onTransitionEnd");
    }
    function ak(e, t, a, u, f, m, y) {
      var S = Zw.get(t);
      if (S !== void 0) {
        var w = ms, k = t;
        switch (t) {
          case "keypress":
            if (To(u) === 0)
              return;
          /* falls through */
          case "keydown":
          case "keyup":
            w = Kv;
            break;
          case "focusin":
            k = "focus", w = $s;
            break;
          case "focusout":
            k = "blur", w = $s;
            break;
          case "beforeblur":
          case "afterblur":
            w = $s;
            break;
          case "click":
            if (u.button === 2)
              return;
          /* falls through */
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          // TODO: Disabled elements should not respond to mouse events
          /* falls through */
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            w = ap;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            w = bl;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            w = eg;
            break;
          case Jw:
          case Qw:
          case Kw:
            w = Yv;
            break;
          case Xw:
            w = wa;
            break;
          case "scroll":
            w = ji;
            break;
          case "wheel":
            w = B0;
            break;
          case "copy":
          case "cut":
          case "paste":
            w = ld;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            w = Xv;
            break;
        }
        var M = (m & ha) !== 0;
        {
          var q = !M && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          t === "scroll", H = uk(a, S, u.type, M, q);
          if (H.length > 0) {
            var ee = new w(S, k, null, u, f);
            e.push({
              event: ee,
              listeners: H
            });
          }
        }
      }
    }
    ik(), V(), q0(), ek(), H0();
    function sk(e, t, a, u, f, m, y) {
      ak(e, t, a, u, f, m);
      var S = (m & kh) === 0;
      S && (X(e, t, a, u, f), G(e, t, a, u, f), rk(e, t, a, u, f), V0(e, t, a, u, f));
    }
    var vp = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], K0 = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(vp));
    function t_(e, t, a) {
      var u = e.type || "unknown-event";
      e.currentTarget = a, as(u, t, void 0, e), e.currentTarget = null;
    }
    function ok(e, t, a) {
      var u;
      if (a)
        for (var f = t.length - 1; f >= 0; f--) {
          var m = t[f], y = m.instance, S = m.currentTarget, w = m.listener;
          if (y !== u && e.isPropagationStopped())
            return;
          t_(e, w, S), u = y;
        }
      else
        for (var k = 0; k < t.length; k++) {
          var M = t[k], q = M.instance, H = M.currentTarget, ee = M.listener;
          if (q !== u && e.isPropagationStopped())
            return;
          t_(e, ee, H), u = q;
        }
    }
    function n_(e, t) {
      for (var a = (t & ha) !== 0, u = 0; u < e.length; u++) {
        var f = e[u], m = f.event, y = f.listeners;
        ok(m, y, a);
      }
      tc();
    }
    function lk(e, t, a, u, f) {
      var m = Oh(a), y = [];
      sk(y, e, u, a, m, t), n_(y, t);
    }
    function Qn(e, t) {
      K0.has(e) || p('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var a = !1, u = FO(t), f = dk(e);
      u.has(f) || (r_(t, e, vf, a), u.add(f));
    }
    function X0(e, t, a) {
      K0.has(e) && !t && p('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var u = 0;
      t && (u |= ha), r_(a, e, u, t);
    }
    var og = "_reactListening" + Math.random().toString(36).slice(2);
    function gp(e) {
      if (!e[og]) {
        e[og] = !0, Ot.forEach(function(a) {
          a !== "selectionchange" && (K0.has(a) || X0(a, !1, e), X0(a, !0, e));
        });
        var t = e.nodeType === Ds ? e : e.ownerDocument;
        t !== null && (t[og] || (t[og] = !0, X0("selectionchange", !1, t)));
      }
    }
    function r_(e, t, a, u, f) {
      var m = Vr(e, t, a), y = void 0;
      ec && (t === "touchstart" || t === "touchmove" || t === "wheel") && (y = !0), e = e, u ? y !== void 0 ? ip(e, t, m, y) : Mi(e, t, m) : y !== void 0 ? du(e, t, m, y) : Nc(e, t, m);
    }
    function i_(e, t) {
      return e === t || e.nodeType === mr && e.parentNode === t;
    }
    function Z0(e, t, a, u, f) {
      var m = u;
      if (!(t & Th) && !(t & vf)) {
        var y = f;
        if (u !== null) {
          var S = u;
          e: for (; ; ) {
            if (S === null)
              return;
            var w = S.tag;
            if (w === O || w === P) {
              var k = S.stateNode.containerInfo;
              if (i_(k, y))
                break;
              if (w === P)
                for (var M = S.return; M !== null; ) {
                  var q = M.tag;
                  if (q === O || q === P) {
                    var H = M.stateNode.containerInfo;
                    if (i_(H, y))
                      return;
                  }
                  M = M.return;
                }
              for (; k !== null; ) {
                var ee = Ic(k);
                if (ee === null)
                  return;
                var re = ee.tag;
                if (re === z || re === B) {
                  S = m = ee;
                  continue e;
                }
                k = k.parentNode;
              }
            }
            S = S.return;
          }
        }
      }
      gv(function() {
        return lk(e, t, a, m);
      });
    }
    function yp(e, t, a) {
      return {
        instance: e,
        listener: t,
        currentTarget: a
      };
    }
    function uk(e, t, a, u, f, m) {
      for (var y = t !== null ? t + "Capture" : null, S = u ? y : t, w = [], k = e, M = null; k !== null; ) {
        var q = k, H = q.stateNode, ee = q.tag;
        if (ee === z && H !== null && (M = H, S !== null)) {
          var re = po(k, S);
          re != null && w.push(yp(k, re, M));
        }
        if (f)
          break;
        k = k.return;
      }
      return w;
    }
    function lg(e, t) {
      for (var a = t + "Capture", u = [], f = e; f !== null; ) {
        var m = f, y = m.stateNode, S = m.tag;
        if (S === z && y !== null) {
          var w = y, k = po(f, a);
          k != null && u.unshift(yp(f, k, w));
          var M = po(f, t);
          M != null && u.push(yp(f, M, w));
        }
        f = f.return;
      }
      return u;
    }
    function bd(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== z);
      return e || null;
    }
    function ck(e, t) {
      for (var a = e, u = t, f = 0, m = a; m; m = bd(m))
        f++;
      for (var y = 0, S = u; S; S = bd(S))
        y++;
      for (; f - y > 0; )
        a = bd(a), f--;
      for (; y - f > 0; )
        u = bd(u), y--;
      for (var w = f; w--; ) {
        if (a === u || u !== null && a === u.alternate)
          return a;
        a = bd(a), u = bd(u);
      }
      return null;
    }
    function a_(e, t, a, u, f) {
      for (var m = t._reactName, y = [], S = a; S !== null && S !== u; ) {
        var w = S, k = w.alternate, M = w.stateNode, q = w.tag;
        if (k !== null && k === u)
          break;
        if (q === z && M !== null) {
          var H = M;
          if (f) {
            var ee = po(S, m);
            ee != null && y.unshift(yp(S, ee, H));
          } else if (!f) {
            var re = po(S, m);
            re != null && y.push(yp(S, re, H));
          }
        }
        S = S.return;
      }
      y.length !== 0 && e.push({
        event: t,
        listeners: y
      });
    }
    function fk(e, t, a, u, f) {
      var m = u && f ? ck(u, f) : null;
      u !== null && a_(e, t, u, m, !1), f !== null && a !== null && a_(e, a, f, m, !0);
    }
    function dk(e, t) {
      return e + "__bubble";
    }
    var _a = !1, bp = "dangerouslySetInnerHTML", ug = "suppressContentEditableWarning", gu = "suppressHydrationWarning", s_ = "autoFocus", Uc = "children", Fc = "style", cg = "__html", eb, fg, Sp, o_, dg, l_, u_;
    eb = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, fg = function(e, t) {
      xh(e, t), pf(e, t), pv(e, t, {
        registrationNameDependencies: ct,
        possibleRegistrationNames: ht
      });
    }, l_ = Un && !document.documentMode, Sp = function(e, t, a) {
      if (!_a) {
        var u = hg(a), f = hg(t);
        f !== u && (_a = !0, p("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(f), JSON.stringify(u)));
      }
    }, o_ = function(e) {
      if (!_a) {
        _a = !0;
        var t = [];
        e.forEach(function(a) {
          t.push(a);
        }), p("Extra attributes from the server: %s", t);
      }
    }, dg = function(e, t) {
      t === !1 ? p("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : p("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof t);
    }, u_ = function(e, t) {
      var a = e.namespaceURI === Ns ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return a.innerHTML = t, a.innerHTML;
    };
    var hk = /\r\n?/g, pk = /\u0000|\uFFFD/g;
    function hg(e) {
      Kn(e);
      var t = typeof e == "string" ? e : "" + e;
      return t.replace(hk, `
`).replace(pk, "");
    }
    function pg(e, t, a, u) {
      var f = hg(t), m = hg(e);
      if (m !== f && (u && (_a || (_a = !0, p('Text content did not match. Server: "%s" Client: "%s"', m, f))), a && Ye))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function c_(e) {
      return e.nodeType === Ds ? e : e.ownerDocument;
    }
    function mk() {
    }
    function mg(e) {
      e.onclick = mk;
    }
    function vk(e, t, a, u, f) {
      for (var m in u)
        if (u.hasOwnProperty(m)) {
          var y = u[m];
          if (m === Fc)
            y && Object.freeze(y), lv(t, y);
          else if (m === bp) {
            var S = y ? y[cg] : void 0;
            S != null && Qm(t, S);
          } else if (m === Uc)
            if (typeof y == "string") {
              var w = e !== "textarea" || y !== "";
              w && Gl(t, y);
            } else typeof y == "number" && Gl(t, "" + y);
          else m === ug || m === gu || m === s_ || (ct.hasOwnProperty(m) ? y != null && (typeof y != "function" && dg(m, y), m === "onScroll" && Qn("scroll", t)) : y != null && Zn(t, m, y, f));
        }
    }
    function gk(e, t, a, u) {
      for (var f = 0; f < t.length; f += 2) {
        var m = t[f], y = t[f + 1];
        m === Fc ? lv(e, y) : m === bp ? Qm(e, y) : m === Uc ? Gl(e, y) : Zn(e, m, y, u);
      }
    }
    function yk(e, t, a, u) {
      var f, m = c_(a), y, S = u;
      if (S === Ns && (S = gh(e)), S === Ns) {
        if (f = fo(e, t), !f && e !== e.toLowerCase() && p("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var w = m.createElement("div");
          w.innerHTML = "<script><\/script>";
          var k = w.firstChild;
          y = w.removeChild(k);
        } else if (typeof t.is == "string")
          y = m.createElement(e, {
            is: t.is
          });
        else if (y = m.createElement(e), e === "select") {
          var M = y;
          t.multiple ? M.multiple = !0 : t.size && (M.size = t.size);
        }
      } else
        y = m.createElementNS(S, e);
      return S === Ns && !f && Object.prototype.toString.call(y) === "[object HTMLUnknownElement]" && !dr.call(eb, e) && (eb[e] = !0, p("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), y;
    }
    function bk(e, t) {
      return c_(t).createTextNode(e);
    }
    function Sk(e, t, a, u) {
      var f = fo(t, a);
      fg(t, a);
      var m;
      switch (t) {
        case "dialog":
          Qn("cancel", e), Qn("close", e), m = a;
          break;
        case "iframe":
        case "object":
        case "embed":
          Qn("load", e), m = a;
          break;
        case "video":
        case "audio":
          for (var y = 0; y < vp.length; y++)
            Qn(vp[y], e);
          m = a;
          break;
        case "source":
          Qn("error", e), m = a;
          break;
        case "img":
        case "image":
        case "link":
          Qn("error", e), Qn("load", e), m = a;
          break;
        case "details":
          Qn("toggle", e), m = a;
          break;
        case "input":
          Pa(e, a), m = Wl(e, a), Qn("invalid", e);
          break;
        case "option":
          an(e, a), m = a;
          break;
        case "select":
          Jo(e, a), m = qu(e, a), Qn("invalid", e);
          break;
        case "textarea":
          ph(e, a), m = hh(e, a), Qn("invalid", e);
          break;
        default:
          m = a;
      }
      switch (df(t, m), vk(t, e, u, m, f), t) {
        case "input":
          La(e), te(e, a, !1);
          break;
        case "textarea":
          La(e), Gm(e);
          break;
        case "option":
          Ln(e, a);
          break;
        case "select":
          fh(e, a);
          break;
        default:
          typeof m.onClick == "function" && mg(e);
          break;
      }
    }
    function Ek(e, t, a, u, f) {
      fg(t, u);
      var m = null, y, S;
      switch (t) {
        case "input":
          y = Wl(e, a), S = Wl(e, u), m = [];
          break;
        case "select":
          y = qu(e, a), S = qu(e, u), m = [];
          break;
        case "textarea":
          y = hh(e, a), S = hh(e, u), m = [];
          break;
        default:
          y = a, S = u, typeof y.onClick != "function" && typeof S.onClick == "function" && mg(e);
          break;
      }
      df(t, S);
      var w, k, M = null;
      for (w in y)
        if (!(S.hasOwnProperty(w) || !y.hasOwnProperty(w) || y[w] == null))
          if (w === Fc) {
            var q = y[w];
            for (k in q)
              q.hasOwnProperty(k) && (M || (M = {}), M[k] = "");
          } else w === bp || w === Uc || w === ug || w === gu || w === s_ || (ct.hasOwnProperty(w) ? m || (m = []) : (m = m || []).push(w, null));
      for (w in S) {
        var H = S[w], ee = y?.[w];
        if (!(!S.hasOwnProperty(w) || H === ee || H == null && ee == null))
          if (w === Fc)
            if (H && Object.freeze(H), ee) {
              for (k in ee)
                ee.hasOwnProperty(k) && (!H || !H.hasOwnProperty(k)) && (M || (M = {}), M[k] = "");
              for (k in H)
                H.hasOwnProperty(k) && ee[k] !== H[k] && (M || (M = {}), M[k] = H[k]);
            } else
              M || (m || (m = []), m.push(w, M)), M = H;
          else if (w === bp) {
            var re = H ? H[cg] : void 0, ce = ee ? ee[cg] : void 0;
            re != null && ce !== re && (m = m || []).push(w, re);
          } else w === Uc ? (typeof H == "string" || typeof H == "number") && (m = m || []).push(w, "" + H) : w === ug || w === gu || (ct.hasOwnProperty(w) ? (H != null && (typeof H != "function" && dg(w, H), w === "onScroll" && Qn("scroll", e)), !m && ee !== H && (m = [])) : (m = m || []).push(w, H));
      }
      return M && (R0(M, S[Fc]), (m = m || []).push(Fc, M)), m;
    }
    function wk(e, t, a, u, f) {
      a === "input" && f.type === "radio" && f.name != null && C(e, f);
      var m = fo(a, u), y = fo(a, f);
      switch (gk(e, t, m, y), a) {
        case "input":
          F(e, f);
          break;
        case "textarea":
          Wm(e, f);
          break;
        case "select":
          uf(e, f);
          break;
      }
    }
    function _k(e) {
      {
        var t = e.toLowerCase();
        return Qu.hasOwnProperty(t) && Qu[t] || null;
      }
    }
    function xk(e, t, a, u, f, m, y) {
      var S, w;
      switch (S = fo(t, a), fg(t, a), t) {
        case "dialog":
          Qn("cancel", e), Qn("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          Qn("load", e);
          break;
        case "video":
        case "audio":
          for (var k = 0; k < vp.length; k++)
            Qn(vp[k], e);
          break;
        case "source":
          Qn("error", e);
          break;
        case "img":
        case "image":
        case "link":
          Qn("error", e), Qn("load", e);
          break;
        case "details":
          Qn("toggle", e);
          break;
        case "input":
          Pa(e, a), Qn("invalid", e);
          break;
        case "option":
          an(e, a);
          break;
        case "select":
          Jo(e, a), Qn("invalid", e);
          break;
        case "textarea":
          ph(e, a), Qn("invalid", e);
          break;
      }
      df(t, a);
      {
        w = /* @__PURE__ */ new Set();
        for (var M = e.attributes, q = 0; q < M.length; q++) {
          var H = M[q].name.toLowerCase();
          switch (H) {
            // Controlled attributes are not validated
            // TODO: Only ignore them on controlled tags.
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              w.add(M[q].name);
          }
        }
      }
      var ee = null;
      for (var re in a)
        if (a.hasOwnProperty(re)) {
          var ce = a[re];
          if (re === Uc)
            typeof ce == "string" ? e.textContent !== ce && (a[gu] !== !0 && pg(e.textContent, ce, m, y), ee = [Uc, ce]) : typeof ce == "number" && e.textContent !== "" + ce && (a[gu] !== !0 && pg(e.textContent, ce, m, y), ee = [Uc, "" + ce]);
          else if (ct.hasOwnProperty(re))
            ce != null && (typeof ce != "function" && dg(re, ce), re === "onScroll" && Qn("scroll", e));
          else if (y && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof S == "boolean") {
            var Ie = void 0, yt = gn(re);
            if (a[gu] !== !0) {
              if (!(re === ug || re === gu || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              re === "value" || re === "checked" || re === "selected")) {
                if (re === bp) {
                  var ut = e.innerHTML, tn = ce ? ce[cg] : void 0;
                  if (tn != null) {
                    var Qt = u_(e, tn);
                    Qt !== ut && Sp(re, ut, Qt);
                  }
                } else if (re === Fc) {
                  if (w.delete(re), l_) {
                    var J = x0(ce);
                    Ie = e.getAttribute("style"), J !== Ie && Sp(re, Ie, J);
                  }
                } else if (S)
                  w.delete(re.toLowerCase()), Ie = Hi(e, re, ce), ce !== Ie && Sp(re, Ie, ce);
                else if (!_n(re, yt, S) && !Xn(re, ce, yt, S)) {
                  var fe = !1;
                  if (yt !== null)
                    w.delete(yt.attributeName), Ie = Bi(e, re, ce, yt);
                  else {
                    var Q = u;
                    if (Q === Ns && (Q = gh(t)), Q === Ns)
                      w.delete(re.toLowerCase());
                    else {
                      var xe = _k(re);
                      xe !== null && xe !== re && (fe = !0, w.delete(xe)), w.delete(re);
                    }
                    Ie = Hi(e, re, ce);
                  }
                  var Qe = Y;
                  !Qe && ce !== Ie && !fe && Sp(re, Ie, ce);
                }
              }
            }
          }
        }
      switch (y && // $FlowFixMe - Should be inferred as not undefined.
      w.size > 0 && a[gu] !== !0 && o_(w), t) {
        case "input":
          La(e), te(e, a, !0);
          break;
        case "textarea":
          La(e), Gm(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof a.onClick == "function" && mg(e);
          break;
      }
      return ee;
    }
    function Ck(e, t, a) {
      var u = e.nodeValue !== t;
      return u;
    }
    function tb(e, t) {
      {
        if (_a)
          return;
        _a = !0, p("Did not expect server HTML to contain a <%s> in <%s>.", t.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function nb(e, t) {
      {
        if (_a)
          return;
        _a = !0, p('Did not expect server HTML to contain the text node "%s" in <%s>.', t.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function rb(e, t, a) {
      {
        if (_a)
          return;
        _a = !0, p("Expected server HTML to contain a matching <%s> in <%s>.", t, e.nodeName.toLowerCase());
      }
    }
    function ib(e, t) {
      {
        if (t === "" || _a)
          return;
        _a = !0, p('Expected server HTML to contain a matching text node for "%s" in <%s>.', t, e.nodeName.toLowerCase());
      }
    }
    function Rk(e, t, a) {
      switch (t) {
        case "input":
          oe(e, a);
          return;
        case "textarea":
          S0(e, a);
          return;
        case "select":
          dh(e, a);
          return;
      }
    }
    var Ep = function() {
    }, wp = function() {
    };
    {
      var Tk = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], f_ = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], kk = f_.concat(["button"]), Ok = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], d_ = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      wp = function(e, t) {
        var a = U({}, e || d_), u = {
          tag: t
        };
        return f_.indexOf(t) !== -1 && (a.aTagInScope = null, a.buttonTagInScope = null, a.nobrTagInScope = null), kk.indexOf(t) !== -1 && (a.pTagInButtonScope = null), Tk.indexOf(t) !== -1 && t !== "address" && t !== "div" && t !== "p" && (a.listItemTagAutoclosing = null, a.dlItemTagAutoclosing = null), a.current = u, t === "form" && (a.formTag = u), t === "a" && (a.aTagInScope = u), t === "button" && (a.buttonTagInScope = u), t === "nobr" && (a.nobrTagInScope = u), t === "p" && (a.pTagInButtonScope = u), t === "li" && (a.listItemTagAutoclosing = u), (t === "dd" || t === "dt") && (a.dlItemTagAutoclosing = u), a;
      };
      var Nk = function(e, t) {
        switch (t) {
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
          // but
          case "option":
            return e === "#text";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
          // No special behavior since these rules fall back to "in body" mode for
          // all except special table nodes which cause bad parsing behavior anyway.
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
          case "colgroup":
            return e === "col" || e === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t !== "h1" && t !== "h2" && t !== "h3" && t !== "h4" && t !== "h5" && t !== "h6";
          case "rp":
          case "rt":
            return Ok.indexOf(t) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return t == null;
        }
        return !0;
      }, Ak = function(e, t) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return t.pTagInButtonScope;
          case "form":
            return t.formTag || t.pTagInButtonScope;
          case "li":
            return t.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return t.dlItemTagAutoclosing;
          case "button":
            return t.buttonTagInScope;
          case "a":
            return t.aTagInScope;
          case "nobr":
            return t.nobrTagInScope;
        }
        return null;
      }, h_ = {};
      Ep = function(e, t, a) {
        a = a || d_;
        var u = a.current, f = u && u.tag;
        t != null && (e != null && p("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var m = Nk(e, f) ? null : u, y = m ? null : Ak(e, a), S = m || y;
        if (S) {
          var w = S.tag, k = !!m + "|" + e + "|" + w;
          if (!h_[k]) {
            h_[k] = !0;
            var M = e, q = "";
            if (e === "#text" ? /\S/.test(t) ? M = "Text nodes" : (M = "Whitespace text nodes", q = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : M = "<" + e + ">", m) {
              var H = "";
              w === "table" && e === "tr" && (H += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), p("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", M, w, q, H);
            } else
              p("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", M, w);
          }
        }
      };
    }
    var vg = "suppressHydrationWarning", gg = "$", yg = "/$", _p = "$?", xp = "$!", Dk = "style", ab = null, sb = null;
    function Mk(e) {
      var t, a, u = e.nodeType;
      switch (u) {
        case Ds:
        case bh: {
          t = u === Ds ? "#document" : "#fragment";
          var f = e.documentElement;
          a = f ? f.namespaceURI : yh(null, "");
          break;
        }
        default: {
          var m = u === mr ? e.parentNode : e, y = m.namespaceURI || null;
          t = m.tagName, a = yh(y, t);
          break;
        }
      }
      {
        var S = t.toLowerCase(), w = wp(null, S);
        return {
          namespace: a,
          ancestorInfo: w
        };
      }
    }
    function jk(e, t, a) {
      {
        var u = e, f = yh(u.namespace, t), m = wp(u.ancestorInfo, t);
        return {
          namespace: f,
          ancestorInfo: m
        };
      }
    }
    function vF(e) {
      return e;
    }
    function Lk(e) {
      ab = Er(), sb = JT();
      var t = null;
      return kr(!1), t;
    }
    function Pk(e) {
      QT(sb), kr(ab), ab = null, sb = null;
    }
    function Uk(e, t, a, u, f) {
      var m;
      {
        var y = u;
        if (Ep(e, null, y.ancestorInfo), typeof t.children == "string" || typeof t.children == "number") {
          var S = "" + t.children, w = wp(y.ancestorInfo, e);
          Ep(null, S, w);
        }
        m = y.namespace;
      }
      var k = yk(e, t, a, m);
      return Tp(f, k), pb(k, t), k;
    }
    function Fk(e, t) {
      e.appendChild(t);
    }
    function Ik(e, t, a, u, f) {
      switch (Sk(e, t, a, u), t) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!a.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function zk(e, t, a, u, f, m) {
      {
        var y = m;
        if (typeof u.children != typeof a.children && (typeof u.children == "string" || typeof u.children == "number")) {
          var S = "" + u.children, w = wp(y.ancestorInfo, t);
          Ep(null, S, w);
        }
      }
      return Ek(e, t, a, u);
    }
    function ob(e, t) {
      return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
    }
    function $k(e, t, a, u) {
      {
        var f = a;
        Ep(null, e, f.ancestorInfo);
      }
      var m = bk(e, t);
      return Tp(u, m), m;
    }
    function Bk() {
      var e = window.event;
      return e === void 0 ? ba : ad(e.type);
    }
    var lb = typeof setTimeout == "function" ? setTimeout : void 0, Hk = typeof clearTimeout == "function" ? clearTimeout : void 0, ub = -1, p_ = typeof Promise == "function" ? Promise : void 0, Vk = typeof queueMicrotask == "function" ? queueMicrotask : typeof p_ < "u" ? function(e) {
      return p_.resolve(null).then(e).catch(qk);
    } : lb;
    function qk(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function Yk(e, t, a, u) {
      switch (t) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          a.autoFocus && e.focus();
          return;
        case "img": {
          a.src && (e.src = a.src);
          return;
        }
      }
    }
    function Wk(e, t, a, u, f, m) {
      wk(e, t, a, u, f), pb(e, f);
    }
    function m_(e) {
      Gl(e, "");
    }
    function Gk(e, t, a) {
      e.nodeValue = a;
    }
    function Jk(e, t) {
      e.appendChild(t);
    }
    function Qk(e, t) {
      var a;
      e.nodeType === mr ? (a = e.parentNode, a.insertBefore(t, e)) : (a = e, a.appendChild(t));
      var u = e._reactRootContainer;
      u == null && a.onclick === null && mg(a);
    }
    function Kk(e, t, a) {
      e.insertBefore(t, a);
    }
    function Xk(e, t, a) {
      e.nodeType === mr ? e.parentNode.insertBefore(t, a) : e.insertBefore(t, a);
    }
    function Zk(e, t) {
      e.removeChild(t);
    }
    function eO(e, t) {
      e.nodeType === mr ? e.parentNode.removeChild(t) : e.removeChild(t);
    }
    function cb(e, t) {
      var a = t, u = 0;
      do {
        var f = a.nextSibling;
        if (e.removeChild(a), f && f.nodeType === mr) {
          var m = f.data;
          if (m === yg)
            if (u === 0) {
              e.removeChild(f), vl(t);
              return;
            } else
              u--;
          else (m === gg || m === _p || m === xp) && u++;
        }
        a = f;
      } while (a);
      vl(t);
    }
    function tO(e, t) {
      e.nodeType === mr ? cb(e.parentNode, t) : e.nodeType === xi && cb(e, t), vl(e);
    }
    function nO(e) {
      e = e;
      var t = e.style;
      typeof t.setProperty == "function" ? t.setProperty("display", "none", "important") : t.display = "none";
    }
    function rO(e) {
      e.nodeValue = "";
    }
    function iO(e, t) {
      e = e;
      var a = t[Dk], u = a != null && a.hasOwnProperty("display") ? a.display : null;
      e.style.display = ff("display", u);
    }
    function aO(e, t) {
      e.nodeValue = t;
    }
    function sO(e) {
      e.nodeType === xi ? e.textContent = "" : e.nodeType === Ds && e.documentElement && e.removeChild(e.documentElement);
    }
    function oO(e, t, a) {
      return e.nodeType !== xi || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function lO(e, t) {
      return t === "" || e.nodeType !== As ? null : e;
    }
    function uO(e) {
      return e.nodeType !== mr ? null : e;
    }
    function v_(e) {
      return e.data === _p;
    }
    function fb(e) {
      return e.data === xp;
    }
    function cO(e) {
      var t = e.nextSibling && e.nextSibling.dataset, a, u, f;
      return t && (a = t.dgst, u = t.msg, f = t.stck), {
        message: u,
        digest: a,
        stack: f
      };
    }
    function fO(e, t) {
      e._reactRetry = t;
    }
    function bg(e) {
      for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === xi || t === As)
          break;
        if (t === mr) {
          var a = e.data;
          if (a === gg || a === xp || a === _p)
            break;
          if (a === yg)
            return null;
        }
      }
      return e;
    }
    function Cp(e) {
      return bg(e.nextSibling);
    }
    function dO(e) {
      return bg(e.firstChild);
    }
    function hO(e) {
      return bg(e.firstChild);
    }
    function pO(e) {
      return bg(e.nextSibling);
    }
    function mO(e, t, a, u, f, m, y) {
      Tp(m, e), pb(e, a);
      var S;
      {
        var w = f;
        S = w.namespace;
      }
      var k = (m.mode & qt) !== mt;
      return xk(e, t, a, S, u, k, y);
    }
    function vO(e, t, a, u) {
      return Tp(a, e), a.mode & qt, Ck(e, t);
    }
    function gO(e, t) {
      Tp(t, e);
    }
    function yO(e) {
      for (var t = e.nextSibling, a = 0; t; ) {
        if (t.nodeType === mr) {
          var u = t.data;
          if (u === yg) {
            if (a === 0)
              return Cp(t);
            a--;
          } else (u === gg || u === xp || u === _p) && a++;
        }
        t = t.nextSibling;
      }
      return null;
    }
    function g_(e) {
      for (var t = e.previousSibling, a = 0; t; ) {
        if (t.nodeType === mr) {
          var u = t.data;
          if (u === gg || u === xp || u === _p) {
            if (a === 0)
              return t;
            a--;
          } else u === yg && a++;
        }
        t = t.previousSibling;
      }
      return null;
    }
    function bO(e) {
      vl(e);
    }
    function SO(e) {
      vl(e);
    }
    function EO(e) {
      return e !== "head" && e !== "body";
    }
    function wO(e, t, a, u) {
      var f = !0;
      pg(t.nodeValue, a, u, f);
    }
    function _O(e, t, a, u, f, m) {
      if (t[vg] !== !0) {
        var y = !0;
        pg(u.nodeValue, f, m, y);
      }
    }
    function xO(e, t) {
      t.nodeType === xi ? tb(e, t) : t.nodeType === mr || nb(e, t);
    }
    function CO(e, t) {
      {
        var a = e.parentNode;
        a !== null && (t.nodeType === xi ? tb(a, t) : t.nodeType === mr || nb(a, t));
      }
    }
    function RO(e, t, a, u, f) {
      (f || t[vg] !== !0) && (u.nodeType === xi ? tb(a, u) : u.nodeType === mr || nb(a, u));
    }
    function TO(e, t, a) {
      rb(e, t);
    }
    function kO(e, t) {
      ib(e, t);
    }
    function OO(e, t, a) {
      {
        var u = e.parentNode;
        u !== null && rb(u, t);
      }
    }
    function NO(e, t) {
      {
        var a = e.parentNode;
        a !== null && ib(a, t);
      }
    }
    function AO(e, t, a, u, f, m) {
      (m || t[vg] !== !0) && rb(a, u);
    }
    function DO(e, t, a, u, f) {
      (f || t[vg] !== !0) && ib(a, u);
    }
    function MO(e) {
      p("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function jO(e) {
      gp(e);
    }
    var Sd = Math.random().toString(36).slice(2), Ed = "__reactFiber$" + Sd, db = "__reactProps$" + Sd, Rp = "__reactContainer$" + Sd, hb = "__reactEvents$" + Sd, LO = "__reactListeners$" + Sd, PO = "__reactHandles$" + Sd;
    function UO(e) {
      delete e[Ed], delete e[db], delete e[hb], delete e[LO], delete e[PO];
    }
    function Tp(e, t) {
      t[Ed] = e;
    }
    function Sg(e, t) {
      t[Rp] = e;
    }
    function y_(e) {
      e[Rp] = null;
    }
    function kp(e) {
      return !!e[Rp];
    }
    function Ic(e) {
      var t = e[Ed];
      if (t)
        return t;
      for (var a = e.parentNode; a; ) {
        if (t = a[Rp] || a[Ed], t) {
          var u = t.alternate;
          if (t.child !== null || u !== null && u.child !== null)
            for (var f = g_(e); f !== null; ) {
              var m = f[Ed];
              if (m)
                return m;
              f = g_(f);
            }
          return t;
        }
        e = a, a = e.parentNode;
      }
      return null;
    }
    function yu(e) {
      var t = e[Ed] || e[Rp];
      return t && (t.tag === z || t.tag === B || t.tag === Re || t.tag === O) ? t : null;
    }
    function wd(e) {
      if (e.tag === z || e.tag === B)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Eg(e) {
      return e[db] || null;
    }
    function pb(e, t) {
      e[db] = t;
    }
    function FO(e) {
      var t = e[hb];
      return t === void 0 && (t = e[hb] = /* @__PURE__ */ new Set()), t;
    }
    var b_ = {}, S_ = s.ReactDebugCurrentFrame;
    function wg(e) {
      if (e) {
        var t = e._owner, a = Ts(e.type, e._source, t ? t.type : null);
        S_.setExtraStackFrame(a);
      } else
        S_.setExtraStackFrame(null);
    }
    function Hs(e, t, a, u, f) {
      {
        var m = Function.call.bind(dr);
        for (var y in e)
          if (m(e, y)) {
            var S = void 0;
            try {
              if (typeof e[y] != "function") {
                var w = Error((u || "React class") + ": " + a + " type `" + y + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[y] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw w.name = "Invariant Violation", w;
              }
              S = e[y](t, y, u, a, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (k) {
              S = k;
            }
            S && !(S instanceof Error) && (wg(f), p("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", u || "React class", a, y, typeof S), wg(null)), S instanceof Error && !(S.message in b_) && (b_[S.message] = !0, wg(f), p("Failed %s type: %s", a, S.message), wg(null));
          }
      }
    }
    var mb = [], _g;
    _g = [];
    var El = -1;
    function bu(e) {
      return {
        current: e
      };
    }
    function Li(e, t) {
      if (El < 0) {
        p("Unexpected pop.");
        return;
      }
      t !== _g[El] && p("Unexpected Fiber popped."), e.current = mb[El], mb[El] = null, _g[El] = null, El--;
    }
    function Pi(e, t, a) {
      El++, mb[El] = e.current, _g[El] = a, e.current = t;
    }
    var vb;
    vb = {};
    var Va = {};
    Object.freeze(Va);
    var wl = bu(Va), Do = bu(!1), gb = Va;
    function _d(e, t, a) {
      return a && Mo(t) ? gb : wl.current;
    }
    function E_(e, t, a) {
      {
        var u = e.stateNode;
        u.__reactInternalMemoizedUnmaskedChildContext = t, u.__reactInternalMemoizedMaskedChildContext = a;
      }
    }
    function xd(e, t) {
      {
        var a = e.type, u = a.contextTypes;
        if (!u)
          return Va;
        var f = e.stateNode;
        if (f && f.__reactInternalMemoizedUnmaskedChildContext === t)
          return f.__reactInternalMemoizedMaskedChildContext;
        var m = {};
        for (var y in u)
          m[y] = t[y];
        {
          var S = Nt(e) || "Unknown";
          Hs(u, m, "context", S);
        }
        return f && E_(e, t, m), m;
      }
    }
    function xg() {
      return Do.current;
    }
    function Mo(e) {
      {
        var t = e.childContextTypes;
        return t != null;
      }
    }
    function Cg(e) {
      Li(Do, e), Li(wl, e);
    }
    function yb(e) {
      Li(Do, e), Li(wl, e);
    }
    function w_(e, t, a) {
      {
        if (wl.current !== Va)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Pi(wl, t, e), Pi(Do, a, e);
      }
    }
    function __(e, t, a) {
      {
        var u = e.stateNode, f = t.childContextTypes;
        if (typeof u.getChildContext != "function") {
          {
            var m = Nt(e) || "Unknown";
            vb[m] || (vb[m] = !0, p("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", m, m));
          }
          return a;
        }
        var y = u.getChildContext();
        for (var S in y)
          if (!(S in f))
            throw new Error((Nt(e) || "Unknown") + '.getChildContext(): key "' + S + '" is not defined in childContextTypes.');
        {
          var w = Nt(e) || "Unknown";
          Hs(f, y, "child context", w);
        }
        return U({}, a, y);
      }
    }
    function Rg(e) {
      {
        var t = e.stateNode, a = t && t.__reactInternalMemoizedMergedChildContext || Va;
        return gb = wl.current, Pi(wl, a, e), Pi(Do, Do.current, e), !0;
      }
    }
    function x_(e, t, a) {
      {
        var u = e.stateNode;
        if (!u)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (a) {
          var f = __(e, t, gb);
          u.__reactInternalMemoizedMergedChildContext = f, Li(Do, e), Li(wl, e), Pi(wl, f, e), Pi(Do, a, e);
        } else
          Li(Do, e), Pi(Do, a, e);
      }
    }
    function IO(e) {
      {
        if (!nl(e) || e.tag !== x)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var t = e;
        do {
          switch (t.tag) {
            case O:
              return t.stateNode.context;
            case x: {
              var a = t.type;
              if (Mo(a))
                return t.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          t = t.return;
        } while (t !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Su = 0, Tg = 1, _l = null, bb = !1, Sb = !1;
    function C_(e) {
      _l === null ? _l = [e] : _l.push(e);
    }
    function zO(e) {
      bb = !0, C_(e);
    }
    function R_() {
      bb && Eu();
    }
    function Eu() {
      if (!Sb && _l !== null) {
        Sb = !0;
        var e = 0, t = Ea();
        try {
          var a = !0, u = _l;
          for (Sr(li); e < u.length; e++) {
            var f = u[e];
            do
              f = f(a);
            while (f !== null);
          }
          _l = null, bb = !1;
        } catch (m) {
          throw _l !== null && (_l = _l.slice(e + 1)), Ah(ic, Eu), m;
        } finally {
          Sr(t), Sb = !1;
        }
      }
      return null;
    }
    var Cd = [], Rd = 0, kg = null, Og = 0, vs = [], gs = 0, zc = null, xl = 1, Cl = "";
    function $O(e) {
      return Bc(), (e.flags & ss) !== pt;
    }
    function BO(e) {
      return Bc(), Og;
    }
    function HO() {
      var e = Cl, t = xl, a = t & ~VO(t);
      return a.toString(32) + e;
    }
    function $c(e, t) {
      Bc(), Cd[Rd++] = Og, Cd[Rd++] = kg, kg = e, Og = t;
    }
    function T_(e, t, a) {
      Bc(), vs[gs++] = xl, vs[gs++] = Cl, vs[gs++] = zc, zc = e;
      var u = xl, f = Cl, m = Ng(u) - 1, y = u & ~(1 << m), S = a + 1, w = Ng(t) + m;
      if (w > 30) {
        var k = m - m % 5, M = (1 << k) - 1, q = (y & M).toString(32), H = y >> k, ee = m - k, re = Ng(t) + ee, ce = S << ee, Ie = ce | H, yt = q + f;
        xl = 1 << re | Ie, Cl = yt;
      } else {
        var ut = S << m, tn = ut | y, Qt = f;
        xl = 1 << w | tn, Cl = Qt;
      }
    }
    function Eb(e) {
      Bc();
      var t = e.return;
      if (t !== null) {
        var a = 1, u = 0;
        $c(e, a), T_(e, a, u);
      }
    }
    function Ng(e) {
      return 32 - yr(e);
    }
    function VO(e) {
      return 1 << Ng(e) - 1;
    }
    function wb(e) {
      for (; e === kg; )
        kg = Cd[--Rd], Cd[Rd] = null, Og = Cd[--Rd], Cd[Rd] = null;
      for (; e === zc; )
        zc = vs[--gs], vs[gs] = null, Cl = vs[--gs], vs[gs] = null, xl = vs[--gs], vs[gs] = null;
    }
    function qO() {
      return Bc(), zc !== null ? {
        id: xl,
        overflow: Cl
      } : null;
    }
    function YO(e, t) {
      Bc(), vs[gs++] = xl, vs[gs++] = Cl, vs[gs++] = zc, xl = t.id, Cl = t.overflow, zc = e;
    }
    function Bc() {
      hi() || p("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var di = null, ys = null, Vs = !1, Hc = !1, wu = null;
    function WO() {
      Vs && p("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function k_() {
      Hc = !0;
    }
    function GO() {
      return Hc;
    }
    function JO(e) {
      var t = e.stateNode.containerInfo;
      return ys = hO(t), di = e, Vs = !0, wu = null, Hc = !1, !0;
    }
    function QO(e, t, a) {
      return ys = pO(t), di = e, Vs = !0, wu = null, Hc = !1, a !== null && YO(e, a), !0;
    }
    function O_(e, t) {
      switch (e.tag) {
        case O: {
          xO(e.stateNode.containerInfo, t);
          break;
        }
        case z: {
          var a = (e.mode & qt) !== mt;
          RO(
            e.type,
            e.memoizedProps,
            e.stateNode,
            t,
            // TODO: Delete this argument when we remove the legacy root API.
            a
          );
          break;
        }
        case Re: {
          var u = e.memoizedState;
          u.dehydrated !== null && CO(u.dehydrated, t);
          break;
        }
      }
    }
    function N_(e, t) {
      O_(e, t);
      var a = eM();
      a.stateNode = t, a.return = e;
      var u = e.deletions;
      u === null ? (e.deletions = [a], e.flags |= pa) : u.push(a);
    }
    function _b(e, t) {
      {
        if (Hc)
          return;
        switch (e.tag) {
          case O: {
            var a = e.stateNode.containerInfo;
            switch (t.tag) {
              case z:
                var u = t.type;
                t.pendingProps, TO(a, u);
                break;
              case B:
                var f = t.pendingProps;
                kO(a, f);
                break;
            }
            break;
          }
          case z: {
            var m = e.type, y = e.memoizedProps, S = e.stateNode;
            switch (t.tag) {
              case z: {
                var w = t.type, k = t.pendingProps, M = (e.mode & qt) !== mt;
                AO(
                  m,
                  y,
                  S,
                  w,
                  k,
                  // TODO: Delete this argument when we remove the legacy root API.
                  M
                );
                break;
              }
              case B: {
                var q = t.pendingProps, H = (e.mode & qt) !== mt;
                DO(
                  m,
                  y,
                  S,
                  q,
                  // TODO: Delete this argument when we remove the legacy root API.
                  H
                );
                break;
              }
            }
            break;
          }
          case Re: {
            var ee = e.memoizedState, re = ee.dehydrated;
            if (re !== null) switch (t.tag) {
              case z:
                var ce = t.type;
                t.pendingProps, OO(re, ce);
                break;
              case B:
                var Ie = t.pendingProps;
                NO(re, Ie);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function A_(e, t) {
      t.flags = t.flags & -4097 | ir, _b(e, t);
    }
    function D_(e, t) {
      switch (e.tag) {
        case z: {
          var a = e.type;
          e.pendingProps;
          var u = oO(t, a);
          return u !== null ? (e.stateNode = u, di = e, ys = dO(u), !0) : !1;
        }
        case B: {
          var f = e.pendingProps, m = lO(t, f);
          return m !== null ? (e.stateNode = m, di = e, ys = null, !0) : !1;
        }
        case Re: {
          var y = uO(t);
          if (y !== null) {
            var S = {
              dehydrated: y,
              treeContext: qO(),
              retryLane: Qi
            };
            e.memoizedState = S;
            var w = tM(y);
            return w.return = e, e.child = w, di = e, ys = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function xb(e) {
      return (e.mode & qt) !== mt && (e.flags & ft) === pt;
    }
    function Cb(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function Rb(e) {
      if (Vs) {
        var t = ys;
        if (!t) {
          xb(e) && (_b(di, e), Cb()), A_(di, e), Vs = !1, di = e;
          return;
        }
        var a = t;
        if (!D_(e, t)) {
          xb(e) && (_b(di, e), Cb()), t = Cp(a);
          var u = di;
          if (!t || !D_(e, t)) {
            A_(di, e), Vs = !1, di = e;
            return;
          }
          N_(u, a);
        }
      }
    }
    function KO(e, t, a) {
      var u = e.stateNode, f = !Hc, m = mO(u, e.type, e.memoizedProps, t, a, e, f);
      return e.updateQueue = m, m !== null;
    }
    function XO(e) {
      var t = e.stateNode, a = e.memoizedProps, u = vO(t, a, e);
      if (u) {
        var f = di;
        if (f !== null)
          switch (f.tag) {
            case O: {
              var m = f.stateNode.containerInfo, y = (f.mode & qt) !== mt;
              wO(
                m,
                t,
                a,
                // TODO: Delete this argument when we remove the legacy root API.
                y
              );
              break;
            }
            case z: {
              var S = f.type, w = f.memoizedProps, k = f.stateNode, M = (f.mode & qt) !== mt;
              _O(
                S,
                w,
                k,
                t,
                a,
                // TODO: Delete this argument when we remove the legacy root API.
                M
              );
              break;
            }
          }
      }
      return u;
    }
    function ZO(e) {
      var t = e.memoizedState, a = t !== null ? t.dehydrated : null;
      if (!a)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      gO(a, e);
    }
    function eN(e) {
      var t = e.memoizedState, a = t !== null ? t.dehydrated : null;
      if (!a)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return yO(a);
    }
    function M_(e) {
      for (var t = e.return; t !== null && t.tag !== z && t.tag !== O && t.tag !== Re; )
        t = t.return;
      di = t;
    }
    function Ag(e) {
      if (e !== di)
        return !1;
      if (!Vs)
        return M_(e), Vs = !0, !1;
      if (e.tag !== O && (e.tag !== z || EO(e.type) && !ob(e.type, e.memoizedProps))) {
        var t = ys;
        if (t)
          if (xb(e))
            j_(e), Cb();
          else
            for (; t; )
              N_(e, t), t = Cp(t);
      }
      return M_(e), e.tag === Re ? ys = eN(e) : ys = di ? Cp(e.stateNode) : null, !0;
    }
    function tN() {
      return Vs && ys !== null;
    }
    function j_(e) {
      for (var t = ys; t; )
        O_(e, t), t = Cp(t);
    }
    function Td() {
      di = null, ys = null, Vs = !1, Hc = !1;
    }
    function L_() {
      wu !== null && (kC(wu), wu = null);
    }
    function hi() {
      return Vs;
    }
    function Tb(e) {
      wu === null ? wu = [e] : wu.push(e);
    }
    var nN = s.ReactCurrentBatchConfig, rN = null;
    function iN() {
      return nN.transition;
    }
    var qs = {
      recordUnsafeLifecycleWarnings: function(e, t) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, t) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var aN = function(e) {
        for (var t = null, a = e; a !== null; )
          a.mode & On && (t = a), a = a.return;
        return t;
      }, Vc = function(e) {
        var t = [];
        return e.forEach(function(a) {
          t.push(a);
        }), t.sort().join(", ");
      }, Op = [], Np = [], Ap = [], Dp = [], Mp = [], jp = [], qc = /* @__PURE__ */ new Set();
      qs.recordUnsafeLifecycleWarnings = function(e, t) {
        qc.has(e.type) || (typeof t.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        t.componentWillMount.__suppressDeprecationWarning !== !0 && Op.push(e), e.mode & On && typeof t.UNSAFE_componentWillMount == "function" && Np.push(e), typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Ap.push(e), e.mode & On && typeof t.UNSAFE_componentWillReceiveProps == "function" && Dp.push(e), typeof t.componentWillUpdate == "function" && t.componentWillUpdate.__suppressDeprecationWarning !== !0 && Mp.push(e), e.mode & On && typeof t.UNSAFE_componentWillUpdate == "function" && jp.push(e));
      }, qs.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        Op.length > 0 && (Op.forEach(function(H) {
          e.add(Nt(H) || "Component"), qc.add(H.type);
        }), Op = []);
        var t = /* @__PURE__ */ new Set();
        Np.length > 0 && (Np.forEach(function(H) {
          t.add(Nt(H) || "Component"), qc.add(H.type);
        }), Np = []);
        var a = /* @__PURE__ */ new Set();
        Ap.length > 0 && (Ap.forEach(function(H) {
          a.add(Nt(H) || "Component"), qc.add(H.type);
        }), Ap = []);
        var u = /* @__PURE__ */ new Set();
        Dp.length > 0 && (Dp.forEach(function(H) {
          u.add(Nt(H) || "Component"), qc.add(H.type);
        }), Dp = []);
        var f = /* @__PURE__ */ new Set();
        Mp.length > 0 && (Mp.forEach(function(H) {
          f.add(Nt(H) || "Component"), qc.add(H.type);
        }), Mp = []);
        var m = /* @__PURE__ */ new Set();
        if (jp.length > 0 && (jp.forEach(function(H) {
          m.add(Nt(H) || "Component"), qc.add(H.type);
        }), jp = []), t.size > 0) {
          var y = Vc(t);
          p(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, y);
        }
        if (u.size > 0) {
          var S = Vc(u);
          p(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, S);
        }
        if (m.size > 0) {
          var w = Vc(m);
          p(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, w);
        }
        if (e.size > 0) {
          var k = Vc(e);
          v(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, k);
        }
        if (a.size > 0) {
          var M = Vc(a);
          v(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, M);
        }
        if (f.size > 0) {
          var q = Vc(f);
          v(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, q);
        }
      };
      var Dg = /* @__PURE__ */ new Map(), P_ = /* @__PURE__ */ new Set();
      qs.recordLegacyContextWarning = function(e, t) {
        var a = aN(e);
        if (a === null) {
          p("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!P_.has(e.type)) {
          var u = Dg.get(a);
          (e.type.contextTypes != null || e.type.childContextTypes != null || t !== null && typeof t.getChildContext == "function") && (u === void 0 && (u = [], Dg.set(a, u)), u.push(e));
        }
      }, qs.flushLegacyContextWarning = function() {
        Dg.forEach(function(e, t) {
          if (e.length !== 0) {
            var a = e[0], u = /* @__PURE__ */ new Set();
            e.forEach(function(m) {
              u.add(Nt(m) || "Component"), P_.add(m.type);
            });
            var f = Vc(u);
            try {
              Rn(a), p(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, f);
            } finally {
              In();
            }
          }
        });
      }, qs.discardPendingWarnings = function() {
        Op = [], Np = [], Ap = [], Dp = [], Mp = [], jp = [], Dg = /* @__PURE__ */ new Map();
      };
    }
    var kb, Ob, Nb, Ab, Db, U_ = function(e, t) {
    };
    kb = !1, Ob = !1, Nb = {}, Ab = {}, Db = {}, U_ = function(e, t) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var a = Nt(t) || "Component";
        Ab[a] || (Ab[a] = !0, p('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function sN(e) {
      return e.prototype && e.prototype.isReactComponent;
    }
    function Lp(e, t, a) {
      var u = a.ref;
      if (u !== null && typeof u != "function" && typeof u != "object") {
        if ((e.mode & On || ue) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(a._owner && a._self && a._owner.stateNode !== a._self) && // Will already throw with "Function components cannot have string refs"
        !(a._owner && a._owner.tag !== x) && // Will already warn with "Function components cannot be given refs"
        !(typeof a.type == "function" && !sN(a.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        a._owner) {
          var f = Nt(e) || "Component";
          Nb[f] || (p('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', f, u), Nb[f] = !0);
        }
        if (a._owner) {
          var m = a._owner, y;
          if (m) {
            var S = m;
            if (S.tag !== x)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            y = S.stateNode;
          }
          if (!y)
            throw new Error("Missing owner for string ref " + u + ". This error is likely caused by a bug in React. Please file an issue.");
          var w = y;
          wi(u, "ref");
          var k = "" + u;
          if (t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === k)
            return t.ref;
          var M = function(q) {
            var H = w.refs;
            q === null ? delete H[k] : H[k] = q;
          };
          return M._stringRef = k, M;
        } else {
          if (typeof u != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!a._owner)
            throw new Error("Element ref was specified as a string (" + u + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return u;
    }
    function Mg(e, t) {
      var a = Object.prototype.toString.call(t);
      throw new Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
    }
    function jg(e) {
      {
        var t = Nt(e) || "Component";
        if (Db[t])
          return;
        Db[t] = !0, p("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function F_(e) {
      var t = e._payload, a = e._init;
      return a(t);
    }
    function I_(e) {
      function t(J, fe) {
        if (e) {
          var Q = J.deletions;
          Q === null ? (J.deletions = [fe], J.flags |= pa) : Q.push(fe);
        }
      }
      function a(J, fe) {
        if (!e)
          return null;
        for (var Q = fe; Q !== null; )
          t(J, Q), Q = Q.sibling;
        return null;
      }
      function u(J, fe) {
        for (var Q = /* @__PURE__ */ new Map(), xe = fe; xe !== null; )
          xe.key !== null ? Q.set(xe.key, xe) : Q.set(xe.index, xe), xe = xe.sibling;
        return Q;
      }
      function f(J, fe) {
        var Q = ef(J, fe);
        return Q.index = 0, Q.sibling = null, Q;
      }
      function m(J, fe, Q) {
        if (J.index = Q, !e)
          return J.flags |= ss, fe;
        var xe = J.alternate;
        if (xe !== null) {
          var Qe = xe.index;
          return Qe < fe ? (J.flags |= ir, fe) : Qe;
        } else
          return J.flags |= ir, fe;
      }
      function y(J) {
        return e && J.alternate === null && (J.flags |= ir), J;
      }
      function S(J, fe, Q, xe) {
        if (fe === null || fe.tag !== B) {
          var Qe = TE(Q, J.mode, xe);
          return Qe.return = J, Qe;
        } else {
          var He = f(fe, Q);
          return He.return = J, He;
        }
      }
      function w(J, fe, Q, xe) {
        var Qe = Q.type;
        if (Qe === ei)
          return M(J, fe, Q.props.children, xe, Q.key);
        if (fe !== null && (fe.elementType === Qe || // Keep this check inline so it only runs on the false path:
        VC(fe, Q) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Qe == "object" && Qe !== null && Qe.$$typeof === _t && F_(Qe) === fe.type)) {
          var He = f(fe, Q.props);
          return He.ref = Lp(J, fe, Q), He.return = J, He._debugSource = Q._source, He._debugOwner = Q._owner, He;
        }
        var kt = RE(Q, J.mode, xe);
        return kt.ref = Lp(J, fe, Q), kt.return = J, kt;
      }
      function k(J, fe, Q, xe) {
        if (fe === null || fe.tag !== P || fe.stateNode.containerInfo !== Q.containerInfo || fe.stateNode.implementation !== Q.implementation) {
          var Qe = kE(Q, J.mode, xe);
          return Qe.return = J, Qe;
        } else {
          var He = f(fe, Q.children || []);
          return He.return = J, He;
        }
      }
      function M(J, fe, Q, xe, Qe) {
        if (fe === null || fe.tag !== ie) {
          var He = Mu(Q, J.mode, xe, Qe);
          return He.return = J, He;
        } else {
          var kt = f(fe, Q);
          return kt.return = J, kt;
        }
      }
      function q(J, fe, Q) {
        if (typeof fe == "string" && fe !== "" || typeof fe == "number") {
          var xe = TE("" + fe, J.mode, Q);
          return xe.return = J, xe;
        }
        if (typeof fe == "object" && fe !== null) {
          switch (fe.$$typeof) {
            case rr: {
              var Qe = RE(fe, J.mode, Q);
              return Qe.ref = Lp(J, null, fe), Qe.return = J, Qe;
            }
            case er: {
              var He = kE(fe, J.mode, Q);
              return He.return = J, He;
            }
            case _t: {
              var kt = fe._payload, Mt = fe._init;
              return q(J, Mt(kt), Q);
            }
          }
          if ($t(fe) || D(fe)) {
            var An = Mu(fe, J.mode, Q, null);
            return An.return = J, An;
          }
          Mg(J, fe);
        }
        return typeof fe == "function" && jg(J), null;
      }
      function H(J, fe, Q, xe) {
        var Qe = fe !== null ? fe.key : null;
        if (typeof Q == "string" && Q !== "" || typeof Q == "number")
          return Qe !== null ? null : S(J, fe, "" + Q, xe);
        if (typeof Q == "object" && Q !== null) {
          switch (Q.$$typeof) {
            case rr:
              return Q.key === Qe ? w(J, fe, Q, xe) : null;
            case er:
              return Q.key === Qe ? k(J, fe, Q, xe) : null;
            case _t: {
              var He = Q._payload, kt = Q._init;
              return H(J, fe, kt(He), xe);
            }
          }
          if ($t(Q) || D(Q))
            return Qe !== null ? null : M(J, fe, Q, xe, null);
          Mg(J, Q);
        }
        return typeof Q == "function" && jg(J), null;
      }
      function ee(J, fe, Q, xe, Qe) {
        if (typeof xe == "string" && xe !== "" || typeof xe == "number") {
          var He = J.get(Q) || null;
          return S(fe, He, "" + xe, Qe);
        }
        if (typeof xe == "object" && xe !== null) {
          switch (xe.$$typeof) {
            case rr: {
              var kt = J.get(xe.key === null ? Q : xe.key) || null;
              return w(fe, kt, xe, Qe);
            }
            case er: {
              var Mt = J.get(xe.key === null ? Q : xe.key) || null;
              return k(fe, Mt, xe, Qe);
            }
            case _t:
              var An = xe._payload, pn = xe._init;
              return ee(J, fe, Q, pn(An), Qe);
          }
          if ($t(xe) || D(xe)) {
            var Nr = J.get(Q) || null;
            return M(fe, Nr, xe, Qe, null);
          }
          Mg(fe, xe);
        }
        return typeof xe == "function" && jg(fe), null;
      }
      function re(J, fe, Q) {
        {
          if (typeof J != "object" || J === null)
            return fe;
          switch (J.$$typeof) {
            case rr:
            case er:
              U_(J, Q);
              var xe = J.key;
              if (typeof xe != "string")
                break;
              if (fe === null) {
                fe = /* @__PURE__ */ new Set(), fe.add(xe);
                break;
              }
              if (!fe.has(xe)) {
                fe.add(xe);
                break;
              }
              p("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", xe);
              break;
            case _t:
              var Qe = J._payload, He = J._init;
              re(He(Qe), fe, Q);
              break;
          }
        }
        return fe;
      }
      function ce(J, fe, Q, xe) {
        for (var Qe = null, He = 0; He < Q.length; He++) {
          var kt = Q[He];
          Qe = re(kt, Qe, J);
        }
        for (var Mt = null, An = null, pn = fe, Nr = 0, mn = 0, _r = null; pn !== null && mn < Q.length; mn++) {
          pn.index > mn ? (_r = pn, pn = null) : _r = pn.sibling;
          var Fi = H(J, pn, Q[mn], xe);
          if (Fi === null) {
            pn === null && (pn = _r);
            break;
          }
          e && pn && Fi.alternate === null && t(J, pn), Nr = m(Fi, Nr, mn), An === null ? Mt = Fi : An.sibling = Fi, An = Fi, pn = _r;
        }
        if (mn === Q.length) {
          if (a(J, pn), hi()) {
            var Si = mn;
            $c(J, Si);
          }
          return Mt;
        }
        if (pn === null) {
          for (; mn < Q.length; mn++) {
            var Ya = q(J, Q[mn], xe);
            Ya !== null && (Nr = m(Ya, Nr, mn), An === null ? Mt = Ya : An.sibling = Ya, An = Ya);
          }
          if (hi()) {
            var na = mn;
            $c(J, na);
          }
          return Mt;
        }
        for (var ra = u(J, pn); mn < Q.length; mn++) {
          var Ii = ee(ra, J, mn, Q[mn], xe);
          Ii !== null && (e && Ii.alternate !== null && ra.delete(Ii.key === null ? mn : Ii.key), Nr = m(Ii, Nr, mn), An === null ? Mt = Ii : An.sibling = Ii, An = Ii);
        }
        if (e && ra.forEach(function(Yd) {
          return t(J, Yd);
        }), hi()) {
          var Dl = mn;
          $c(J, Dl);
        }
        return Mt;
      }
      function Ie(J, fe, Q, xe) {
        var Qe = D(Q);
        if (typeof Qe != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Q[Symbol.toStringTag] === "Generator" && (Ob || p("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Ob = !0), Q.entries === Qe && (kb || p("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), kb = !0);
          var He = Qe.call(Q);
          if (He)
            for (var kt = null, Mt = He.next(); !Mt.done; Mt = He.next()) {
              var An = Mt.value;
              kt = re(An, kt, J);
            }
        }
        var pn = Qe.call(Q);
        if (pn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Nr = null, mn = null, _r = fe, Fi = 0, Si = 0, Ya = null, na = pn.next(); _r !== null && !na.done; Si++, na = pn.next()) {
          _r.index > Si ? (Ya = _r, _r = null) : Ya = _r.sibling;
          var ra = H(J, _r, na.value, xe);
          if (ra === null) {
            _r === null && (_r = Ya);
            break;
          }
          e && _r && ra.alternate === null && t(J, _r), Fi = m(ra, Fi, Si), mn === null ? Nr = ra : mn.sibling = ra, mn = ra, _r = Ya;
        }
        if (na.done) {
          if (a(J, _r), hi()) {
            var Ii = Si;
            $c(J, Ii);
          }
          return Nr;
        }
        if (_r === null) {
          for (; !na.done; Si++, na = pn.next()) {
            var Dl = q(J, na.value, xe);
            Dl !== null && (Fi = m(Dl, Fi, Si), mn === null ? Nr = Dl : mn.sibling = Dl, mn = Dl);
          }
          if (hi()) {
            var Yd = Si;
            $c(J, Yd);
          }
          return Nr;
        }
        for (var hm = u(J, _r); !na.done; Si++, na = pn.next()) {
          var $o = ee(hm, J, Si, na.value, xe);
          $o !== null && (e && $o.alternate !== null && hm.delete($o.key === null ? Si : $o.key), Fi = m($o, Fi, Si), mn === null ? Nr = $o : mn.sibling = $o, mn = $o);
        }
        if (e && hm.forEach(function(DM) {
          return t(J, DM);
        }), hi()) {
          var AM = Si;
          $c(J, AM);
        }
        return Nr;
      }
      function yt(J, fe, Q, xe) {
        if (fe !== null && fe.tag === B) {
          a(J, fe.sibling);
          var Qe = f(fe, Q);
          return Qe.return = J, Qe;
        }
        a(J, fe);
        var He = TE(Q, J.mode, xe);
        return He.return = J, He;
      }
      function ut(J, fe, Q, xe) {
        for (var Qe = Q.key, He = fe; He !== null; ) {
          if (He.key === Qe) {
            var kt = Q.type;
            if (kt === ei) {
              if (He.tag === ie) {
                a(J, He.sibling);
                var Mt = f(He, Q.props.children);
                return Mt.return = J, Mt._debugSource = Q._source, Mt._debugOwner = Q._owner, Mt;
              }
            } else if (He.elementType === kt || // Keep this check inline so it only runs on the false path:
            VC(He, Q) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof kt == "object" && kt !== null && kt.$$typeof === _t && F_(kt) === He.type) {
              a(J, He.sibling);
              var An = f(He, Q.props);
              return An.ref = Lp(J, He, Q), An.return = J, An._debugSource = Q._source, An._debugOwner = Q._owner, An;
            }
            a(J, He);
            break;
          } else
            t(J, He);
          He = He.sibling;
        }
        if (Q.type === ei) {
          var pn = Mu(Q.props.children, J.mode, xe, Q.key);
          return pn.return = J, pn;
        } else {
          var Nr = RE(Q, J.mode, xe);
          return Nr.ref = Lp(J, fe, Q), Nr.return = J, Nr;
        }
      }
      function tn(J, fe, Q, xe) {
        for (var Qe = Q.key, He = fe; He !== null; ) {
          if (He.key === Qe)
            if (He.tag === P && He.stateNode.containerInfo === Q.containerInfo && He.stateNode.implementation === Q.implementation) {
              a(J, He.sibling);
              var kt = f(He, Q.children || []);
              return kt.return = J, kt;
            } else {
              a(J, He);
              break;
            }
          else
            t(J, He);
          He = He.sibling;
        }
        var Mt = kE(Q, J.mode, xe);
        return Mt.return = J, Mt;
      }
      function Qt(J, fe, Q, xe) {
        var Qe = typeof Q == "object" && Q !== null && Q.type === ei && Q.key === null;
        if (Qe && (Q = Q.props.children), typeof Q == "object" && Q !== null) {
          switch (Q.$$typeof) {
            case rr:
              return y(ut(J, fe, Q, xe));
            case er:
              return y(tn(J, fe, Q, xe));
            case _t:
              var He = Q._payload, kt = Q._init;
              return Qt(J, fe, kt(He), xe);
          }
          if ($t(Q))
            return ce(J, fe, Q, xe);
          if (D(Q))
            return Ie(J, fe, Q, xe);
          Mg(J, Q);
        }
        return typeof Q == "string" && Q !== "" || typeof Q == "number" ? y(yt(J, fe, "" + Q, xe)) : (typeof Q == "function" && jg(J), a(J, fe));
      }
      return Qt;
    }
    var kd = I_(!0), z_ = I_(!1);
    function oN(e, t) {
      if (e !== null && t.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (t.child !== null) {
        var a = t.child, u = ef(a, a.pendingProps);
        for (t.child = u, u.return = t; a.sibling !== null; )
          a = a.sibling, u = u.sibling = ef(a, a.pendingProps), u.return = t;
        u.sibling = null;
      }
    }
    function lN(e, t) {
      for (var a = e.child; a !== null; )
        JD(a, t), a = a.sibling;
    }
    var Mb = bu(null), jb;
    jb = {};
    var Lg = null, Od = null, Lb = null, Pg = !1;
    function Ug() {
      Lg = null, Od = null, Lb = null, Pg = !1;
    }
    function $_() {
      Pg = !0;
    }
    function B_() {
      Pg = !1;
    }
    function H_(e, t, a) {
      Pi(Mb, t._currentValue, e), t._currentValue = a, t._currentRenderer !== void 0 && t._currentRenderer !== null && t._currentRenderer !== jb && p("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), t._currentRenderer = jb;
    }
    function Pb(e, t) {
      var a = Mb.current;
      Li(Mb, t), e._currentValue = a;
    }
    function Ub(e, t, a) {
      for (var u = e; u !== null; ) {
        var f = u.alternate;
        if (ml(u.childLanes, t) ? f !== null && !ml(f.childLanes, t) && (f.childLanes = It(f.childLanes, t)) : (u.childLanes = It(u.childLanes, t), f !== null && (f.childLanes = It(f.childLanes, t))), u === a)
          break;
        u = u.return;
      }
      u !== a && p("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function uN(e, t, a) {
      cN(e, t, a);
    }
    function cN(e, t, a) {
      var u = e.child;
      for (u !== null && (u.return = e); u !== null; ) {
        var f = void 0, m = u.dependencies;
        if (m !== null) {
          f = u.child;
          for (var y = m.firstContext; y !== null; ) {
            if (y.context === t) {
              if (u.tag === x) {
                var S = yc(a), w = Rl(Mn, S);
                w.tag = Ig;
                var k = u.updateQueue;
                if (k !== null) {
                  var M = k.shared, q = M.pending;
                  q === null ? w.next = w : (w.next = q.next, q.next = w), M.pending = w;
                }
              }
              u.lanes = It(u.lanes, a);
              var H = u.alternate;
              H !== null && (H.lanes = It(H.lanes, a)), Ub(u.return, a, e), m.lanes = It(m.lanes, a);
              break;
            }
            y = y.next;
          }
        } else if (u.tag === ae)
          f = u.type === e.type ? null : u.child;
        else if (u.tag === zt) {
          var ee = u.return;
          if (ee === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          ee.lanes = It(ee.lanes, a);
          var re = ee.alternate;
          re !== null && (re.lanes = It(re.lanes, a)), Ub(ee, a, e), f = u.sibling;
        } else
          f = u.child;
        if (f !== null)
          f.return = u;
        else
          for (f = u; f !== null; ) {
            if (f === e) {
              f = null;
              break;
            }
            var ce = f.sibling;
            if (ce !== null) {
              ce.return = f.return, f = ce;
              break;
            }
            f = f.return;
          }
        u = f;
      }
    }
    function Nd(e, t) {
      Lg = e, Od = null, Lb = null;
      var a = e.dependencies;
      if (a !== null) {
        var u = a.firstContext;
        u !== null && (Ai(a.lanes, t) && Qp(), a.firstContext = null);
      }
    }
    function Lr(e) {
      Pg && p("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var t = e._currentValue;
      if (Lb !== e) {
        var a = {
          context: e,
          memoizedValue: t,
          next: null
        };
        if (Od === null) {
          if (Lg === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Od = a, Lg.dependencies = {
            lanes: Se,
            firstContext: a
          };
        } else
          Od = Od.next = a;
      }
      return t;
    }
    var Yc = null;
    function Fb(e) {
      Yc === null ? Yc = [e] : Yc.push(e);
    }
    function fN() {
      if (Yc !== null) {
        for (var e = 0; e < Yc.length; e++) {
          var t = Yc[e], a = t.interleaved;
          if (a !== null) {
            t.interleaved = null;
            var u = a.next, f = t.pending;
            if (f !== null) {
              var m = f.next;
              f.next = u, a.next = m;
            }
            t.pending = a;
          }
        }
        Yc = null;
      }
    }
    function V_(e, t, a, u) {
      var f = t.interleaved;
      return f === null ? (a.next = a, Fb(t)) : (a.next = f.next, f.next = a), t.interleaved = a, Fg(e, u);
    }
    function dN(e, t, a, u) {
      var f = t.interleaved;
      f === null ? (a.next = a, Fb(t)) : (a.next = f.next, f.next = a), t.interleaved = a;
    }
    function hN(e, t, a, u) {
      var f = t.interleaved;
      return f === null ? (a.next = a, Fb(t)) : (a.next = f.next, f.next = a), t.interleaved = a, Fg(e, u);
    }
    function xa(e, t) {
      return Fg(e, t);
    }
    var pN = Fg;
    function Fg(e, t) {
      e.lanes = It(e.lanes, t);
      var a = e.alternate;
      a !== null && (a.lanes = It(a.lanes, t)), a === null && (e.flags & (ir | ma)) !== pt && zC(e);
      for (var u = e, f = e.return; f !== null; )
        f.childLanes = It(f.childLanes, t), a = f.alternate, a !== null ? a.childLanes = It(a.childLanes, t) : (f.flags & (ir | ma)) !== pt && zC(e), u = f, f = f.return;
      if (u.tag === O) {
        var m = u.stateNode;
        return m;
      } else
        return null;
    }
    var q_ = 0, Y_ = 1, Ig = 2, Ib = 3, zg = !1, zb, $g;
    zb = !1, $g = null;
    function $b(e) {
      var t = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Se
        },
        effects: null
      };
      e.updateQueue = t;
    }
    function W_(e, t) {
      var a = t.updateQueue, u = e.updateQueue;
      if (a === u) {
        var f = {
          baseState: u.baseState,
          firstBaseUpdate: u.firstBaseUpdate,
          lastBaseUpdate: u.lastBaseUpdate,
          shared: u.shared,
          effects: u.effects
        };
        t.updateQueue = f;
      }
    }
    function Rl(e, t) {
      var a = {
        eventTime: e,
        lane: t,
        tag: q_,
        payload: null,
        callback: null,
        next: null
      };
      return a;
    }
    function _u(e, t, a) {
      var u = e.updateQueue;
      if (u === null)
        return null;
      var f = u.shared;
      if ($g === f && !zb && (p("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), zb = !0), dD()) {
        var m = f.pending;
        return m === null ? t.next = t : (t.next = m.next, m.next = t), f.pending = t, pN(e, a);
      } else
        return hN(e, f, t, a);
    }
    function Bg(e, t, a) {
      var u = t.updateQueue;
      if (u !== null) {
        var f = u.shared;
        if (Gh(a)) {
          var m = f.lanes;
          m = Qh(m, e.pendingLanes);
          var y = It(m, a);
          f.lanes = y, td(e, y);
        }
      }
    }
    function Bb(e, t) {
      var a = e.updateQueue, u = e.alternate;
      if (u !== null) {
        var f = u.updateQueue;
        if (a === f) {
          var m = null, y = null, S = a.firstBaseUpdate;
          if (S !== null) {
            var w = S;
            do {
              var k = {
                eventTime: w.eventTime,
                lane: w.lane,
                tag: w.tag,
                payload: w.payload,
                callback: w.callback,
                next: null
              };
              y === null ? m = y = k : (y.next = k, y = k), w = w.next;
            } while (w !== null);
            y === null ? m = y = t : (y.next = t, y = t);
          } else
            m = y = t;
          a = {
            baseState: f.baseState,
            firstBaseUpdate: m,
            lastBaseUpdate: y,
            shared: f.shared,
            effects: f.effects
          }, e.updateQueue = a;
          return;
        }
      }
      var M = a.lastBaseUpdate;
      M === null ? a.firstBaseUpdate = t : M.next = t, a.lastBaseUpdate = t;
    }
    function mN(e, t, a, u, f, m) {
      switch (a.tag) {
        case Y_: {
          var y = a.payload;
          if (typeof y == "function") {
            $_();
            var S = y.call(m, u, f);
            {
              if (e.mode & On) {
                Gn(!0);
                try {
                  y.call(m, u, f);
                } finally {
                  Gn(!1);
                }
              }
              B_();
            }
            return S;
          }
          return y;
        }
        case Ib:
          e.flags = e.flags & -65537 | ft;
        // Intentional fallthrough
        case q_: {
          var w = a.payload, k;
          if (typeof w == "function") {
            $_(), k = w.call(m, u, f);
            {
              if (e.mode & On) {
                Gn(!0);
                try {
                  w.call(m, u, f);
                } finally {
                  Gn(!1);
                }
              }
              B_();
            }
          } else
            k = w;
          return k == null ? u : U({}, u, k);
        }
        case Ig:
          return zg = !0, u;
      }
      return u;
    }
    function Hg(e, t, a, u) {
      var f = e.updateQueue;
      zg = !1, $g = f.shared;
      var m = f.firstBaseUpdate, y = f.lastBaseUpdate, S = f.shared.pending;
      if (S !== null) {
        f.shared.pending = null;
        var w = S, k = w.next;
        w.next = null, y === null ? m = k : y.next = k, y = w;
        var M = e.alternate;
        if (M !== null) {
          var q = M.updateQueue, H = q.lastBaseUpdate;
          H !== y && (H === null ? q.firstBaseUpdate = k : H.next = k, q.lastBaseUpdate = w);
        }
      }
      if (m !== null) {
        var ee = f.baseState, re = Se, ce = null, Ie = null, yt = null, ut = m;
        do {
          var tn = ut.lane, Qt = ut.eventTime;
          if (ml(u, tn)) {
            if (yt !== null) {
              var fe = {
                eventTime: Qt,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: ln,
                tag: ut.tag,
                payload: ut.payload,
                callback: ut.callback,
                next: null
              };
              yt = yt.next = fe;
            }
            ee = mN(e, f, ut, ee, t, a);
            var Q = ut.callback;
            if (Q !== null && // If the update was already committed, we should not queue its
            // callback again.
            ut.lane !== ln) {
              e.flags |= Pn;
              var xe = f.effects;
              xe === null ? f.effects = [ut] : xe.push(ut);
            }
          } else {
            var J = {
              eventTime: Qt,
              lane: tn,
              tag: ut.tag,
              payload: ut.payload,
              callback: ut.callback,
              next: null
            };
            yt === null ? (Ie = yt = J, ce = ee) : yt = yt.next = J, re = It(re, tn);
          }
          if (ut = ut.next, ut === null) {
            if (S = f.shared.pending, S === null)
              break;
            var Qe = S, He = Qe.next;
            Qe.next = null, ut = He, f.lastBaseUpdate = Qe, f.shared.pending = null;
          }
        } while (!0);
        yt === null && (ce = ee), f.baseState = ce, f.firstBaseUpdate = Ie, f.lastBaseUpdate = yt;
        var kt = f.shared.interleaved;
        if (kt !== null) {
          var Mt = kt;
          do
            re = It(re, Mt.lane), Mt = Mt.next;
          while (Mt !== kt);
        } else m === null && (f.shared.lanes = Se);
        lm(re), e.lanes = re, e.memoizedState = ee;
      }
      $g = null;
    }
    function vN(e, t) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(t);
    }
    function G_() {
      zg = !1;
    }
    function Vg() {
      return zg;
    }
    function J_(e, t, a) {
      var u = t.effects;
      if (t.effects = null, u !== null)
        for (var f = 0; f < u.length; f++) {
          var m = u[f], y = m.callback;
          y !== null && (m.callback = null, vN(y, a));
        }
    }
    var Pp = {}, xu = bu(Pp), Up = bu(Pp), qg = bu(Pp);
    function Yg(e) {
      if (e === Pp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function Q_() {
      var e = Yg(qg.current);
      return e;
    }
    function Hb(e, t) {
      Pi(qg, t, e), Pi(Up, e, e), Pi(xu, Pp, e);
      var a = Mk(t);
      Li(xu, e), Pi(xu, a, e);
    }
    function Ad(e) {
      Li(xu, e), Li(Up, e), Li(qg, e);
    }
    function Vb() {
      var e = Yg(xu.current);
      return e;
    }
    function K_(e) {
      Yg(qg.current);
      var t = Yg(xu.current), a = jk(t, e.type);
      t !== a && (Pi(Up, e, e), Pi(xu, a, e));
    }
    function qb(e) {
      Up.current === e && (Li(xu, e), Li(Up, e));
    }
    var gN = 0, X_ = 1, Z_ = 1, Fp = 2, Ys = bu(gN);
    function Yb(e, t) {
      return (e & t) !== 0;
    }
    function Dd(e) {
      return e & X_;
    }
    function Wb(e, t) {
      return e & X_ | t;
    }
    function yN(e, t) {
      return e | t;
    }
    function Cu(e, t) {
      Pi(Ys, t, e);
    }
    function Md(e) {
      Li(Ys, e);
    }
    function bN(e, t) {
      var a = e.memoizedState;
      return a !== null ? a.dehydrated !== null : (e.memoizedProps, !0);
    }
    function Wg(e) {
      for (var t = e; t !== null; ) {
        if (t.tag === Re) {
          var a = t.memoizedState;
          if (a !== null) {
            var u = a.dehydrated;
            if (u === null || v_(u) || fb(u))
              return t;
          }
        } else if (t.tag === it && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        t.memoizedProps.revealOrder !== void 0) {
          var f = (t.flags & ft) !== pt;
          if (f)
            return t;
        } else if (t.child !== null) {
          t.child.return = t, t = t.child;
          continue;
        }
        if (t === e)
          return null;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
            return null;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      return null;
    }
    var Ca = (
      /*   */
      0
    ), qr = (
      /* */
      1
    ), jo = (
      /*  */
      2
    ), Yr = (
      /*    */
      4
    ), pi = (
      /*   */
      8
    ), Gb = [];
    function Jb() {
      for (var e = 0; e < Gb.length; e++) {
        var t = Gb[e];
        t._workInProgressVersionPrimary = null;
      }
      Gb.length = 0;
    }
    function SN(e, t) {
      var a = t._getVersion, u = a(t._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, u] : e.mutableSourceEagerHydrationData.push(t, u);
    }
    var Je = s.ReactCurrentDispatcher, Ip = s.ReactCurrentBatchConfig, Qb, jd;
    Qb = /* @__PURE__ */ new Set();
    var Wc = Se, Nn = null, Wr = null, Gr = null, Gg = !1, zp = !1, $p = 0, EN = 0, wN = 25, pe = null, bs = null, Ru = -1, Kb = !1;
    function bn() {
      {
        var e = pe;
        bs === null ? bs = [e] : bs.push(e);
      }
    }
    function Le() {
      {
        var e = pe;
        bs !== null && (Ru++, bs[Ru] !== e && _N(e));
      }
    }
    function Ld(e) {
      e != null && !$t(e) && p("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", pe, typeof e);
    }
    function _N(e) {
      {
        var t = Nt(Nn);
        if (!Qb.has(t) && (Qb.add(t), bs !== null)) {
          for (var a = "", u = 30, f = 0; f <= Ru; f++) {
            for (var m = bs[f], y = f === Ru ? e : m, S = f + 1 + ". " + m; S.length < u; )
              S += " ";
            S += y + `
`, a += S;
          }
          p(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, t, a);
        }
      }
    }
    function Ui() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function Xb(e, t) {
      if (Kb)
        return !1;
      if (t === null)
        return p("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", pe), !1;
      e.length !== t.length && p(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, pe, "[" + t.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var a = 0; a < t.length && a < e.length; a++)
        if (!Be(e[a], t[a]))
          return !1;
      return !0;
    }
    function Pd(e, t, a, u, f, m) {
      Wc = m, Nn = t, bs = e !== null ? e._debugHookTypes : null, Ru = -1, Kb = e !== null && e.type !== t.type, t.memoizedState = null, t.updateQueue = null, t.lanes = Se, e !== null && e.memoizedState !== null ? Je.current = Ex : bs !== null ? Je.current = Sx : Je.current = bx;
      var y = a(u, f);
      if (zp) {
        var S = 0;
        do {
          if (zp = !1, $p = 0, S >= wN)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          S += 1, Kb = !1, Wr = null, Gr = null, t.updateQueue = null, Ru = -1, Je.current = wx, y = a(u, f);
        } while (zp);
      }
      Je.current = oy, t._debugHookTypes = bs;
      var w = Wr !== null && Wr.next !== null;
      if (Wc = Se, Nn = null, Wr = null, Gr = null, pe = null, bs = null, Ru = -1, e !== null && (e.flags & gr) !== (t.flags & gr) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & qt) !== mt && p("Internal React error: Expected static flag was missing. Please notify the React team."), Gg = !1, w)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return y;
    }
    function Ud() {
      var e = $p !== 0;
      return $p = 0, e;
    }
    function ex(e, t, a) {
      t.updateQueue = e.updateQueue, (t.mode & dn) !== mt ? t.flags &= -50333701 : t.flags &= -2053, e.lanes = bc(e.lanes, a);
    }
    function tx() {
      if (Je.current = oy, Gg) {
        for (var e = Nn.memoizedState; e !== null; ) {
          var t = e.queue;
          t !== null && (t.pending = null), e = e.next;
        }
        Gg = !1;
      }
      Wc = Se, Nn = null, Wr = null, Gr = null, bs = null, Ru = -1, pe = null, px = !1, zp = !1, $p = 0;
    }
    function Lo() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Gr === null ? Nn.memoizedState = Gr = e : Gr = Gr.next = e, Gr;
    }
    function Ss() {
      var e;
      if (Wr === null) {
        var t = Nn.alternate;
        t !== null ? e = t.memoizedState : e = null;
      } else
        e = Wr.next;
      var a;
      if (Gr === null ? a = Nn.memoizedState : a = Gr.next, a !== null)
        Gr = a, a = Gr.next, Wr = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Wr = e;
        var u = {
          memoizedState: Wr.memoizedState,
          baseState: Wr.baseState,
          baseQueue: Wr.baseQueue,
          queue: Wr.queue,
          next: null
        };
        Gr === null ? Nn.memoizedState = Gr = u : Gr = Gr.next = u;
      }
      return Gr;
    }
    function nx() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Zb(e, t) {
      return typeof t == "function" ? t(e) : t;
    }
    function eS(e, t, a) {
      var u = Lo(), f;
      a !== void 0 ? f = a(t) : f = t, u.memoizedState = u.baseState = f;
      var m = {
        pending: null,
        interleaved: null,
        lanes: Se,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: f
      };
      u.queue = m;
      var y = m.dispatch = TN.bind(null, Nn, m);
      return [u.memoizedState, y];
    }
    function tS(e, t, a) {
      var u = Ss(), f = u.queue;
      if (f === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      f.lastRenderedReducer = e;
      var m = Wr, y = m.baseQueue, S = f.pending;
      if (S !== null) {
        if (y !== null) {
          var w = y.next, k = S.next;
          y.next = k, S.next = w;
        }
        m.baseQueue !== y && p("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), m.baseQueue = y = S, f.pending = null;
      }
      if (y !== null) {
        var M = y.next, q = m.baseState, H = null, ee = null, re = null, ce = M;
        do {
          var Ie = ce.lane;
          if (ml(Wc, Ie)) {
            if (re !== null) {
              var ut = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: ln,
                action: ce.action,
                hasEagerState: ce.hasEagerState,
                eagerState: ce.eagerState,
                next: null
              };
              re = re.next = ut;
            }
            if (ce.hasEagerState)
              q = ce.eagerState;
            else {
              var tn = ce.action;
              q = e(q, tn);
            }
          } else {
            var yt = {
              lane: Ie,
              action: ce.action,
              hasEagerState: ce.hasEagerState,
              eagerState: ce.eagerState,
              next: null
            };
            re === null ? (ee = re = yt, H = q) : re = re.next = yt, Nn.lanes = It(Nn.lanes, Ie), lm(Ie);
          }
          ce = ce.next;
        } while (ce !== null && ce !== M);
        re === null ? H = q : re.next = ee, Be(q, u.memoizedState) || Qp(), u.memoizedState = q, u.baseState = H, u.baseQueue = re, f.lastRenderedState = q;
      }
      var Qt = f.interleaved;
      if (Qt !== null) {
        var J = Qt;
        do {
          var fe = J.lane;
          Nn.lanes = It(Nn.lanes, fe), lm(fe), J = J.next;
        } while (J !== Qt);
      } else y === null && (f.lanes = Se);
      var Q = f.dispatch;
      return [u.memoizedState, Q];
    }
    function nS(e, t, a) {
      var u = Ss(), f = u.queue;
      if (f === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      f.lastRenderedReducer = e;
      var m = f.dispatch, y = f.pending, S = u.memoizedState;
      if (y !== null) {
        f.pending = null;
        var w = y.next, k = w;
        do {
          var M = k.action;
          S = e(S, M), k = k.next;
        } while (k !== w);
        Be(S, u.memoizedState) || Qp(), u.memoizedState = S, u.baseQueue === null && (u.baseState = S), f.lastRenderedState = S;
      }
      return [S, m];
    }
    function gF(e, t, a) {
    }
    function yF(e, t, a) {
    }
    function rS(e, t, a) {
      var u = Nn, f = Lo(), m, y = hi();
      if (y) {
        if (a === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        m = a(), jd || m !== a() && (p("The result of getServerSnapshot should be cached to avoid an infinite loop"), jd = !0);
      } else {
        if (m = t(), !jd) {
          var S = t();
          Be(m, S) || (p("The result of getSnapshot should be cached to avoid an infinite loop"), jd = !0);
        }
        var w = Ry();
        if (w === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Zf(w, Wc) || rx(u, t, m);
      }
      f.memoizedState = m;
      var k = {
        value: m,
        getSnapshot: t
      };
      return f.queue = k, Zg(ax.bind(null, u, k, e), [e]), u.flags |= Ri, Bp(qr | pi, ix.bind(null, u, k, m, t), void 0, null), m;
    }
    function Jg(e, t, a) {
      var u = Nn, f = Ss(), m = t();
      if (!jd) {
        var y = t();
        Be(m, y) || (p("The result of getSnapshot should be cached to avoid an infinite loop"), jd = !0);
      }
      var S = f.memoizedState, w = !Be(S, m);
      w && (f.memoizedState = m, Qp());
      var k = f.queue;
      if (Vp(ax.bind(null, u, k, e), [e]), k.getSnapshot !== t || w || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Gr !== null && Gr.memoizedState.tag & qr) {
        u.flags |= Ri, Bp(qr | pi, ix.bind(null, u, k, m, t), void 0, null);
        var M = Ry();
        if (M === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Zf(M, Wc) || rx(u, t, m);
      }
      return m;
    }
    function rx(e, t, a) {
      e.flags |= ru;
      var u = {
        getSnapshot: t,
        value: a
      }, f = Nn.updateQueue;
      if (f === null)
        f = nx(), Nn.updateQueue = f, f.stores = [u];
      else {
        var m = f.stores;
        m === null ? f.stores = [u] : m.push(u);
      }
    }
    function ix(e, t, a, u) {
      t.value = a, t.getSnapshot = u, sx(t) && ox(e);
    }
    function ax(e, t, a) {
      var u = function() {
        sx(t) && ox(e);
      };
      return a(u);
    }
    function sx(e) {
      var t = e.getSnapshot, a = e.value;
      try {
        var u = t();
        return !Be(a, u);
      } catch {
        return !0;
      }
    }
    function ox(e) {
      var t = xa(e, Ct);
      t !== null && Xr(t, e, Ct, Mn);
    }
    function Qg(e) {
      var t = Lo();
      typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e;
      var a = {
        pending: null,
        interleaved: null,
        lanes: Se,
        dispatch: null,
        lastRenderedReducer: Zb,
        lastRenderedState: e
      };
      t.queue = a;
      var u = a.dispatch = kN.bind(null, Nn, a);
      return [t.memoizedState, u];
    }
    function iS(e) {
      return tS(Zb);
    }
    function aS(e) {
      return nS(Zb);
    }
    function Bp(e, t, a, u) {
      var f = {
        tag: e,
        create: t,
        destroy: a,
        deps: u,
        // Circular
        next: null
      }, m = Nn.updateQueue;
      if (m === null)
        m = nx(), Nn.updateQueue = m, m.lastEffect = f.next = f;
      else {
        var y = m.lastEffect;
        if (y === null)
          m.lastEffect = f.next = f;
        else {
          var S = y.next;
          y.next = f, f.next = S, m.lastEffect = f;
        }
      }
      return f;
    }
    function sS(e) {
      var t = Lo();
      {
        var a = {
          current: e
        };
        return t.memoizedState = a, a;
      }
    }
    function Kg(e) {
      var t = Ss();
      return t.memoizedState;
    }
    function Hp(e, t, a, u) {
      var f = Lo(), m = u === void 0 ? null : u;
      Nn.flags |= e, f.memoizedState = Bp(qr | t, a, void 0, m);
    }
    function Xg(e, t, a, u) {
      var f = Ss(), m = u === void 0 ? null : u, y = void 0;
      if (Wr !== null) {
        var S = Wr.memoizedState;
        if (y = S.destroy, m !== null) {
          var w = S.deps;
          if (Xb(m, w)) {
            f.memoizedState = Bp(t, a, y, m);
            return;
          }
        }
      }
      Nn.flags |= e, f.memoizedState = Bp(qr | t, a, y, m);
    }
    function Zg(e, t) {
      return (Nn.mode & dn) !== mt ? Hp(os | Ri | Rf, pi, e, t) : Hp(Ri | Rf, pi, e, t);
    }
    function Vp(e, t) {
      return Xg(Ri, pi, e, t);
    }
    function oS(e, t) {
      return Hp(Xt, jo, e, t);
    }
    function ey(e, t) {
      return Xg(Xt, jo, e, t);
    }
    function lS(e, t) {
      var a = Xt;
      return a |= js, (Nn.mode & dn) !== mt && (a |= vo), Hp(a, Yr, e, t);
    }
    function ty(e, t) {
      return Xg(Xt, Yr, e, t);
    }
    function lx(e, t) {
      if (typeof t == "function") {
        var a = t, u = e();
        return a(u), function() {
          a(null);
        };
      } else if (t != null) {
        var f = t;
        f.hasOwnProperty("current") || p("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(f).join(", ") + "}");
        var m = e();
        return f.current = m, function() {
          f.current = null;
        };
      }
    }
    function uS(e, t, a) {
      typeof t != "function" && p("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t !== null ? typeof t : "null");
      var u = a != null ? a.concat([e]) : null, f = Xt;
      return f |= js, (Nn.mode & dn) !== mt && (f |= vo), Hp(f, Yr, lx.bind(null, t, e), u);
    }
    function ny(e, t, a) {
      typeof t != "function" && p("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t !== null ? typeof t : "null");
      var u = a != null ? a.concat([e]) : null;
      return Xg(Xt, Yr, lx.bind(null, t, e), u);
    }
    function xN(e, t) {
    }
    var ry = xN;
    function cS(e, t) {
      var a = Lo(), u = t === void 0 ? null : t;
      return a.memoizedState = [e, u], e;
    }
    function iy(e, t) {
      var a = Ss(), u = t === void 0 ? null : t, f = a.memoizedState;
      if (f !== null && u !== null) {
        var m = f[1];
        if (Xb(u, m))
          return f[0];
      }
      return a.memoizedState = [e, u], e;
    }
    function fS(e, t) {
      var a = Lo(), u = t === void 0 ? null : t, f = e();
      return a.memoizedState = [f, u], f;
    }
    function ay(e, t) {
      var a = Ss(), u = t === void 0 ? null : t, f = a.memoizedState;
      if (f !== null && u !== null) {
        var m = f[1];
        if (Xb(u, m))
          return f[0];
      }
      var y = e();
      return a.memoizedState = [y, u], y;
    }
    function dS(e) {
      var t = Lo();
      return t.memoizedState = e, e;
    }
    function ux(e) {
      var t = Ss(), a = Wr, u = a.memoizedState;
      return fx(t, u, e);
    }
    function cx(e) {
      var t = Ss();
      if (Wr === null)
        return t.memoizedState = e, e;
      var a = Wr.memoizedState;
      return fx(t, a, e);
    }
    function fx(e, t, a) {
      var u = !Yh(Wc);
      if (u) {
        if (!Be(a, t)) {
          var f = Jh();
          Nn.lanes = It(Nn.lanes, f), lm(f), e.baseState = !0;
        }
        return t;
      } else
        return e.baseState && (e.baseState = !1, Qp()), e.memoizedState = a, a;
    }
    function CN(e, t, a) {
      var u = Ea();
      Sr(Fv(u, fs)), e(!0);
      var f = Ip.transition;
      Ip.transition = {};
      var m = Ip.transition;
      Ip.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), t();
      } finally {
        if (Sr(u), Ip.transition = f, f === null && m._updatedFibers) {
          var y = m._updatedFibers.size;
          y > 10 && v("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), m._updatedFibers.clear();
        }
      }
    }
    function hS() {
      var e = Qg(!1), t = e[0], a = e[1], u = CN.bind(null, a), f = Lo();
      return f.memoizedState = u, [t, u];
    }
    function dx() {
      var e = iS(), t = e[0], a = Ss(), u = a.memoizedState;
      return [t, u];
    }
    function hx() {
      var e = aS(), t = e[0], a = Ss(), u = a.memoizedState;
      return [t, u];
    }
    var px = !1;
    function RN() {
      return px;
    }
    function pS() {
      var e = Lo(), t = Ry(), a = t.identifierPrefix, u;
      if (hi()) {
        var f = HO();
        u = ":" + a + "R" + f;
        var m = $p++;
        m > 0 && (u += "H" + m.toString(32)), u += ":";
      } else {
        var y = EN++;
        u = ":" + a + "r" + y.toString(32) + ":";
      }
      return e.memoizedState = u, u;
    }
    function sy() {
      var e = Ss(), t = e.memoizedState;
      return t;
    }
    function TN(e, t, a) {
      typeof arguments[3] == "function" && p("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var u = Au(e), f = {
        lane: u,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (mx(e))
        vx(t, f);
      else {
        var m = V_(e, t, f, u);
        if (m !== null) {
          var y = ta();
          Xr(m, e, u, y), gx(m, t, u);
        }
      }
      yx(e, u);
    }
    function kN(e, t, a) {
      typeof arguments[3] == "function" && p("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var u = Au(e), f = {
        lane: u,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (mx(e))
        vx(t, f);
      else {
        var m = e.alternate;
        if (e.lanes === Se && (m === null || m.lanes === Se)) {
          var y = t.lastRenderedReducer;
          if (y !== null) {
            var S;
            S = Je.current, Je.current = Ws;
            try {
              var w = t.lastRenderedState, k = y(w, a);
              if (f.hasEagerState = !0, f.eagerState = k, Be(k, w)) {
                dN(e, t, f, u);
                return;
              }
            } catch {
            } finally {
              Je.current = S;
            }
          }
        }
        var M = V_(e, t, f, u);
        if (M !== null) {
          var q = ta();
          Xr(M, e, u, q), gx(M, t, u);
        }
      }
      yx(e, u);
    }
    function mx(e) {
      var t = e.alternate;
      return e === Nn || t !== null && t === Nn;
    }
    function vx(e, t) {
      zp = Gg = !0;
      var a = e.pending;
      a === null ? t.next = t : (t.next = a.next, a.next = t), e.pending = t;
    }
    function gx(e, t, a) {
      if (Gh(a)) {
        var u = t.lanes;
        u = Qh(u, e.pendingLanes);
        var f = It(u, a);
        t.lanes = f, td(e, f);
      }
    }
    function yx(e, t, a) {
      uc(e, t);
    }
    var oy = {
      readContext: Lr,
      useCallback: Ui,
      useContext: Ui,
      useEffect: Ui,
      useImperativeHandle: Ui,
      useInsertionEffect: Ui,
      useLayoutEffect: Ui,
      useMemo: Ui,
      useReducer: Ui,
      useRef: Ui,
      useState: Ui,
      useDebugValue: Ui,
      useDeferredValue: Ui,
      useTransition: Ui,
      useMutableSource: Ui,
      useSyncExternalStore: Ui,
      useId: Ui,
      unstable_isNewReconciler: Ce
    }, bx = null, Sx = null, Ex = null, wx = null, Po = null, Ws = null, ly = null;
    {
      var mS = function() {
        p("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Dt = function() {
        p("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      bx = {
        readContext: function(e) {
          return Lr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", bn(), Ld(t), cS(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", bn(), Lr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", bn(), Ld(t), Zg(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", bn(), Ld(a), uS(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", bn(), Ld(t), oS(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", bn(), Ld(t), lS(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", bn(), Ld(t);
          var a = Je.current;
          Je.current = Po;
          try {
            return fS(e, t);
          } finally {
            Je.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", bn();
          var u = Je.current;
          Je.current = Po;
          try {
            return eS(e, t, a);
          } finally {
            Je.current = u;
          }
        },
        useRef: function(e) {
          return pe = "useRef", bn(), sS(e);
        },
        useState: function(e) {
          pe = "useState", bn();
          var t = Je.current;
          Je.current = Po;
          try {
            return Qg(e);
          } finally {
            Je.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", bn(), void 0;
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", bn(), dS(e);
        },
        useTransition: function() {
          return pe = "useTransition", bn(), hS();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", bn(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", bn(), rS(e, t, a);
        },
        useId: function() {
          return pe = "useId", bn(), pS();
        },
        unstable_isNewReconciler: Ce
      }, Sx = {
        readContext: function(e) {
          return Lr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Le(), cS(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Le(), Lr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Le(), Zg(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Le(), uS(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Le(), oS(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Le(), lS(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Le();
          var a = Je.current;
          Je.current = Po;
          try {
            return fS(e, t);
          } finally {
            Je.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Le();
          var u = Je.current;
          Je.current = Po;
          try {
            return eS(e, t, a);
          } finally {
            Je.current = u;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Le(), sS(e);
        },
        useState: function(e) {
          pe = "useState", Le();
          var t = Je.current;
          Je.current = Po;
          try {
            return Qg(e);
          } finally {
            Je.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Le(), void 0;
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Le(), dS(e);
        },
        useTransition: function() {
          return pe = "useTransition", Le(), hS();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Le(), rS(e, t, a);
        },
        useId: function() {
          return pe = "useId", Le(), pS();
        },
        unstable_isNewReconciler: Ce
      }, Ex = {
        readContext: function(e) {
          return Lr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Le(), iy(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Le(), Lr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Le(), Vp(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Le(), ny(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Le(), ey(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Le(), ty(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Le();
          var a = Je.current;
          Je.current = Ws;
          try {
            return ay(e, t);
          } finally {
            Je.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Le();
          var u = Je.current;
          Je.current = Ws;
          try {
            return tS(e, t, a);
          } finally {
            Je.current = u;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Le(), Kg();
        },
        useState: function(e) {
          pe = "useState", Le();
          var t = Je.current;
          Je.current = Ws;
          try {
            return iS(e);
          } finally {
            Je.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Le(), ry();
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Le(), ux(e);
        },
        useTransition: function() {
          return pe = "useTransition", Le(), dx();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Le(), Jg(e, t);
        },
        useId: function() {
          return pe = "useId", Le(), sy();
        },
        unstable_isNewReconciler: Ce
      }, wx = {
        readContext: function(e) {
          return Lr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Le(), iy(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Le(), Lr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Le(), Vp(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Le(), ny(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Le(), ey(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Le(), ty(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Le();
          var a = Je.current;
          Je.current = ly;
          try {
            return ay(e, t);
          } finally {
            Je.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Le();
          var u = Je.current;
          Je.current = ly;
          try {
            return nS(e, t, a);
          } finally {
            Je.current = u;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Le(), Kg();
        },
        useState: function(e) {
          pe = "useState", Le();
          var t = Je.current;
          Je.current = ly;
          try {
            return aS(e);
          } finally {
            Je.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Le(), ry();
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Le(), cx(e);
        },
        useTransition: function() {
          return pe = "useTransition", Le(), hx();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Le(), Jg(e, t);
        },
        useId: function() {
          return pe = "useId", Le(), sy();
        },
        unstable_isNewReconciler: Ce
      }, Po = {
        readContext: function(e) {
          return mS(), Lr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Dt(), bn(), cS(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Dt(), bn(), Lr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Dt(), bn(), Zg(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Dt(), bn(), uS(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Dt(), bn(), oS(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Dt(), bn(), lS(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Dt(), bn();
          var a = Je.current;
          Je.current = Po;
          try {
            return fS(e, t);
          } finally {
            Je.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Dt(), bn();
          var u = Je.current;
          Je.current = Po;
          try {
            return eS(e, t, a);
          } finally {
            Je.current = u;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Dt(), bn(), sS(e);
        },
        useState: function(e) {
          pe = "useState", Dt(), bn();
          var t = Je.current;
          Je.current = Po;
          try {
            return Qg(e);
          } finally {
            Je.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Dt(), bn(), void 0;
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Dt(), bn(), dS(e);
        },
        useTransition: function() {
          return pe = "useTransition", Dt(), bn(), hS();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Dt(), bn(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Dt(), bn(), rS(e, t, a);
        },
        useId: function() {
          return pe = "useId", Dt(), bn(), pS();
        },
        unstable_isNewReconciler: Ce
      }, Ws = {
        readContext: function(e) {
          return mS(), Lr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Dt(), Le(), iy(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Dt(), Le(), Lr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Dt(), Le(), Vp(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Dt(), Le(), ny(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Dt(), Le(), ey(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Dt(), Le(), ty(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Dt(), Le();
          var a = Je.current;
          Je.current = Ws;
          try {
            return ay(e, t);
          } finally {
            Je.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Dt(), Le();
          var u = Je.current;
          Je.current = Ws;
          try {
            return tS(e, t, a);
          } finally {
            Je.current = u;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Dt(), Le(), Kg();
        },
        useState: function(e) {
          pe = "useState", Dt(), Le();
          var t = Je.current;
          Je.current = Ws;
          try {
            return iS(e);
          } finally {
            Je.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Dt(), Le(), ry();
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Dt(), Le(), ux(e);
        },
        useTransition: function() {
          return pe = "useTransition", Dt(), Le(), dx();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Dt(), Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Dt(), Le(), Jg(e, t);
        },
        useId: function() {
          return pe = "useId", Dt(), Le(), sy();
        },
        unstable_isNewReconciler: Ce
      }, ly = {
        readContext: function(e) {
          return mS(), Lr(e);
        },
        useCallback: function(e, t) {
          return pe = "useCallback", Dt(), Le(), iy(e, t);
        },
        useContext: function(e) {
          return pe = "useContext", Dt(), Le(), Lr(e);
        },
        useEffect: function(e, t) {
          return pe = "useEffect", Dt(), Le(), Vp(e, t);
        },
        useImperativeHandle: function(e, t, a) {
          return pe = "useImperativeHandle", Dt(), Le(), ny(e, t, a);
        },
        useInsertionEffect: function(e, t) {
          return pe = "useInsertionEffect", Dt(), Le(), ey(e, t);
        },
        useLayoutEffect: function(e, t) {
          return pe = "useLayoutEffect", Dt(), Le(), ty(e, t);
        },
        useMemo: function(e, t) {
          pe = "useMemo", Dt(), Le();
          var a = Je.current;
          Je.current = Ws;
          try {
            return ay(e, t);
          } finally {
            Je.current = a;
          }
        },
        useReducer: function(e, t, a) {
          pe = "useReducer", Dt(), Le();
          var u = Je.current;
          Je.current = Ws;
          try {
            return nS(e, t, a);
          } finally {
            Je.current = u;
          }
        },
        useRef: function(e) {
          return pe = "useRef", Dt(), Le(), Kg();
        },
        useState: function(e) {
          pe = "useState", Dt(), Le();
          var t = Je.current;
          Je.current = Ws;
          try {
            return aS(e);
          } finally {
            Je.current = t;
          }
        },
        useDebugValue: function(e, t) {
          return pe = "useDebugValue", Dt(), Le(), ry();
        },
        useDeferredValue: function(e) {
          return pe = "useDeferredValue", Dt(), Le(), cx(e);
        },
        useTransition: function() {
          return pe = "useTransition", Dt(), Le(), hx();
        },
        useMutableSource: function(e, t, a) {
          return pe = "useMutableSource", Dt(), Le(), void 0;
        },
        useSyncExternalStore: function(e, t, a) {
          return pe = "useSyncExternalStore", Dt(), Le(), Jg(e, t);
        },
        useId: function() {
          return pe = "useId", Dt(), Le(), sy();
        },
        unstable_isNewReconciler: Ce
      };
    }
    var Tu = n.unstable_now, _x = 0, uy = -1, qp = -1, cy = -1, vS = !1, fy = !1;
    function xx() {
      return vS;
    }
    function ON() {
      fy = !0;
    }
    function NN() {
      vS = !1, fy = !1;
    }
    function AN() {
      vS = fy, fy = !1;
    }
    function Cx() {
      return _x;
    }
    function Rx() {
      _x = Tu();
    }
    function gS(e) {
      qp = Tu(), e.actualStartTime < 0 && (e.actualStartTime = Tu());
    }
    function Tx(e) {
      qp = -1;
    }
    function dy(e, t) {
      if (qp >= 0) {
        var a = Tu() - qp;
        e.actualDuration += a, t && (e.selfBaseDuration = a), qp = -1;
      }
    }
    function Uo(e) {
      if (uy >= 0) {
        var t = Tu() - uy;
        uy = -1;
        for (var a = e.return; a !== null; ) {
          switch (a.tag) {
            case O:
              var u = a.stateNode;
              u.effectDuration += t;
              return;
            case De:
              var f = a.stateNode;
              f.effectDuration += t;
              return;
          }
          a = a.return;
        }
      }
    }
    function yS(e) {
      if (cy >= 0) {
        var t = Tu() - cy;
        cy = -1;
        for (var a = e.return; a !== null; ) {
          switch (a.tag) {
            case O:
              var u = a.stateNode;
              u !== null && (u.passiveEffectDuration += t);
              return;
            case De:
              var f = a.stateNode;
              f !== null && (f.passiveEffectDuration += t);
              return;
          }
          a = a.return;
        }
      }
    }
    function Fo() {
      uy = Tu();
    }
    function bS() {
      cy = Tu();
    }
    function SS(e) {
      for (var t = e.child; t; )
        e.actualDuration += t.actualDuration, t = t.sibling;
    }
    function Gs(e, t) {
      if (e && e.defaultProps) {
        var a = U({}, t), u = e.defaultProps;
        for (var f in u)
          a[f] === void 0 && (a[f] = u[f]);
        return a;
      }
      return t;
    }
    var ES = {}, wS, _S, xS, CS, RS, kx, hy, TS, kS, OS, Yp;
    {
      wS = /* @__PURE__ */ new Set(), _S = /* @__PURE__ */ new Set(), xS = /* @__PURE__ */ new Set(), CS = /* @__PURE__ */ new Set(), TS = /* @__PURE__ */ new Set(), RS = /* @__PURE__ */ new Set(), kS = /* @__PURE__ */ new Set(), OS = /* @__PURE__ */ new Set(), Yp = /* @__PURE__ */ new Set();
      var Ox = /* @__PURE__ */ new Set();
      hy = function(e, t) {
        if (!(e === null || typeof e == "function")) {
          var a = t + "_" + e;
          Ox.has(a) || (Ox.add(a), p("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t, e));
        }
      }, kx = function(e, t) {
        if (t === void 0) {
          var a = rn(e) || "Component";
          RS.has(a) || (RS.add(a), p("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", a));
        }
      }, Object.defineProperty(ES, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(ES);
    }
    function NS(e, t, a, u) {
      var f = e.memoizedState, m = a(u, f);
      {
        if (e.mode & On) {
          Gn(!0);
          try {
            m = a(u, f);
          } finally {
            Gn(!1);
          }
        }
        kx(t, m);
      }
      var y = m == null ? f : U({}, f, m);
      if (e.memoizedState = y, e.lanes === Se) {
        var S = e.updateQueue;
        S.baseState = y;
      }
    }
    var AS = {
      isMounted: wv,
      enqueueSetState: function(e, t, a) {
        var u = nu(e), f = ta(), m = Au(u), y = Rl(f, m);
        y.payload = t, a != null && (hy(a, "setState"), y.callback = a);
        var S = _u(u, y, m);
        S !== null && (Xr(S, u, m, f), Bg(S, u, m)), uc(u, m);
      },
      enqueueReplaceState: function(e, t, a) {
        var u = nu(e), f = ta(), m = Au(u), y = Rl(f, m);
        y.tag = Y_, y.payload = t, a != null && (hy(a, "replaceState"), y.callback = a);
        var S = _u(u, y, m);
        S !== null && (Xr(S, u, m, f), Bg(S, u, m)), uc(u, m);
      },
      enqueueForceUpdate: function(e, t) {
        var a = nu(e), u = ta(), f = Au(a), m = Rl(u, f);
        m.tag = Ig, t != null && (hy(t, "forceUpdate"), m.callback = t);
        var y = _u(a, m, f);
        y !== null && (Xr(y, a, f, u), Bg(y, a, f)), Mf(a, f);
      }
    };
    function Nx(e, t, a, u, f, m, y) {
      var S = e.stateNode;
      if (typeof S.shouldComponentUpdate == "function") {
        var w = S.shouldComponentUpdate(u, m, y);
        {
          if (e.mode & On) {
            Gn(!0);
            try {
              w = S.shouldComponentUpdate(u, m, y);
            } finally {
              Gn(!1);
            }
          }
          w === void 0 && p("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", rn(t) || "Component");
        }
        return w;
      }
      return t.prototype && t.prototype.isPureReactComponent ? !vt(a, u) || !vt(f, m) : !0;
    }
    function DN(e, t, a) {
      var u = e.stateNode;
      {
        var f = rn(t) || "Component", m = u.render;
        m || (t.prototype && typeof t.prototype.render == "function" ? p("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", f) : p("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", f)), u.getInitialState && !u.getInitialState.isReactClassApproved && !u.state && p("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", f), u.getDefaultProps && !u.getDefaultProps.isReactClassApproved && p("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", f), u.propTypes && p("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", f), u.contextType && p("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", f), t.childContextTypes && !Yp.has(t) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (e.mode & On) === mt && (Yp.add(t), p(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, f)), t.contextTypes && !Yp.has(t) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (e.mode & On) === mt && (Yp.add(t), p(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, f)), u.contextTypes && p("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", f), t.contextType && t.contextTypes && !kS.has(t) && (kS.add(t), p("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", f)), typeof u.componentShouldUpdate == "function" && p("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", f), t.prototype && t.prototype.isPureReactComponent && typeof u.shouldComponentUpdate < "u" && p("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", rn(t) || "A pure component"), typeof u.componentDidUnmount == "function" && p("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", f), typeof u.componentDidReceiveProps == "function" && p("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", f), typeof u.componentWillRecieveProps == "function" && p("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", f), typeof u.UNSAFE_componentWillRecieveProps == "function" && p("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", f);
        var y = u.props !== a;
        u.props !== void 0 && y && p("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", f, f), u.defaultProps && p("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", f, f), typeof u.getSnapshotBeforeUpdate == "function" && typeof u.componentDidUpdate != "function" && !xS.has(t) && (xS.add(t), p("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", rn(t))), typeof u.getDerivedStateFromProps == "function" && p("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", f), typeof u.getDerivedStateFromError == "function" && p("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", f), typeof t.getSnapshotBeforeUpdate == "function" && p("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", f);
        var S = u.state;
        S && (typeof S != "object" || $t(S)) && p("%s.state: must be set to an object or null", f), typeof u.getChildContext == "function" && typeof t.childContextTypes != "object" && p("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", f);
      }
    }
    function Ax(e, t) {
      t.updater = AS, e.stateNode = t, tl(t, e), t._reactInternalInstance = ES;
    }
    function Dx(e, t, a) {
      var u = !1, f = Va, m = Va, y = t.contextType;
      if ("contextType" in t) {
        var S = (
          // Allow null for conditional declaration
          y === null || y !== void 0 && y.$$typeof === I && y._context === void 0
        );
        if (!S && !OS.has(t)) {
          OS.add(t);
          var w = "";
          y === void 0 ? w = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof y != "object" ? w = " However, it is set to a " + typeof y + "." : y.$$typeof === Vi ? w = " Did you accidentally pass the Context.Provider instead?" : y._context !== void 0 ? w = " Did you accidentally pass the Context.Consumer instead?" : w = " However, it is set to an object with keys {" + Object.keys(y).join(", ") + "}.", p("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", rn(t) || "Component", w);
        }
      }
      if (typeof y == "object" && y !== null)
        m = Lr(y);
      else {
        f = _d(e, t, !0);
        var k = t.contextTypes;
        u = k != null, m = u ? xd(e, f) : Va;
      }
      var M = new t(a, m);
      if (e.mode & On) {
        Gn(!0);
        try {
          M = new t(a, m);
        } finally {
          Gn(!1);
        }
      }
      var q = e.memoizedState = M.state !== null && M.state !== void 0 ? M.state : null;
      Ax(e, M);
      {
        if (typeof t.getDerivedStateFromProps == "function" && q === null) {
          var H = rn(t) || "Component";
          _S.has(H) || (_S.add(H), p("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", H, M.state === null ? "null" : "undefined", H));
        }
        if (typeof t.getDerivedStateFromProps == "function" || typeof M.getSnapshotBeforeUpdate == "function") {
          var ee = null, re = null, ce = null;
          if (typeof M.componentWillMount == "function" && M.componentWillMount.__suppressDeprecationWarning !== !0 ? ee = "componentWillMount" : typeof M.UNSAFE_componentWillMount == "function" && (ee = "UNSAFE_componentWillMount"), typeof M.componentWillReceiveProps == "function" && M.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? re = "componentWillReceiveProps" : typeof M.UNSAFE_componentWillReceiveProps == "function" && (re = "UNSAFE_componentWillReceiveProps"), typeof M.componentWillUpdate == "function" && M.componentWillUpdate.__suppressDeprecationWarning !== !0 ? ce = "componentWillUpdate" : typeof M.UNSAFE_componentWillUpdate == "function" && (ce = "UNSAFE_componentWillUpdate"), ee !== null || re !== null || ce !== null) {
            var Ie = rn(t) || "Component", yt = typeof t.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            CS.has(Ie) || (CS.add(Ie), p(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ie, yt, ee !== null ? `
  ` + ee : "", re !== null ? `
  ` + re : "", ce !== null ? `
  ` + ce : ""));
          }
        }
      }
      return u && E_(e, f, m), M;
    }
    function MN(e, t) {
      var a = t.state;
      typeof t.componentWillMount == "function" && t.componentWillMount(), typeof t.UNSAFE_componentWillMount == "function" && t.UNSAFE_componentWillMount(), a !== t.state && (p("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Nt(e) || "Component"), AS.enqueueReplaceState(t, t.state, null));
    }
    function Mx(e, t, a, u) {
      var f = t.state;
      if (typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(a, u), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(a, u), t.state !== f) {
        {
          var m = Nt(e) || "Component";
          wS.has(m) || (wS.add(m), p("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", m));
        }
        AS.enqueueReplaceState(t, t.state, null);
      }
    }
    function DS(e, t, a, u) {
      DN(e, t, a);
      var f = e.stateNode;
      f.props = a, f.state = e.memoizedState, f.refs = {}, $b(e);
      var m = t.contextType;
      if (typeof m == "object" && m !== null)
        f.context = Lr(m);
      else {
        var y = _d(e, t, !0);
        f.context = xd(e, y);
      }
      {
        if (f.state === a) {
          var S = rn(t) || "Component";
          TS.has(S) || (TS.add(S), p("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", S));
        }
        e.mode & On && qs.recordLegacyContextWarning(e, f), qs.recordUnsafeLifecycleWarnings(e, f);
      }
      f.state = e.memoizedState;
      var w = t.getDerivedStateFromProps;
      if (typeof w == "function" && (NS(e, t, w, a), f.state = e.memoizedState), typeof t.getDerivedStateFromProps != "function" && typeof f.getSnapshotBeforeUpdate != "function" && (typeof f.UNSAFE_componentWillMount == "function" || typeof f.componentWillMount == "function") && (MN(e, f), Hg(e, a, f, u), f.state = e.memoizedState), typeof f.componentDidMount == "function") {
        var k = Xt;
        k |= js, (e.mode & dn) !== mt && (k |= vo), e.flags |= k;
      }
    }
    function jN(e, t, a, u) {
      var f = e.stateNode, m = e.memoizedProps;
      f.props = m;
      var y = f.context, S = t.contextType, w = Va;
      if (typeof S == "object" && S !== null)
        w = Lr(S);
      else {
        var k = _d(e, t, !0);
        w = xd(e, k);
      }
      var M = t.getDerivedStateFromProps, q = typeof M == "function" || typeof f.getSnapshotBeforeUpdate == "function";
      !q && (typeof f.UNSAFE_componentWillReceiveProps == "function" || typeof f.componentWillReceiveProps == "function") && (m !== a || y !== w) && Mx(e, f, a, w), G_();
      var H = e.memoizedState, ee = f.state = H;
      if (Hg(e, a, f, u), ee = e.memoizedState, m === a && H === ee && !xg() && !Vg()) {
        if (typeof f.componentDidMount == "function") {
          var re = Xt;
          re |= js, (e.mode & dn) !== mt && (re |= vo), e.flags |= re;
        }
        return !1;
      }
      typeof M == "function" && (NS(e, t, M, a), ee = e.memoizedState);
      var ce = Vg() || Nx(e, t, m, a, H, ee, w);
      if (ce) {
        if (!q && (typeof f.UNSAFE_componentWillMount == "function" || typeof f.componentWillMount == "function") && (typeof f.componentWillMount == "function" && f.componentWillMount(), typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount()), typeof f.componentDidMount == "function") {
          var Ie = Xt;
          Ie |= js, (e.mode & dn) !== mt && (Ie |= vo), e.flags |= Ie;
        }
      } else {
        if (typeof f.componentDidMount == "function") {
          var yt = Xt;
          yt |= js, (e.mode & dn) !== mt && (yt |= vo), e.flags |= yt;
        }
        e.memoizedProps = a, e.memoizedState = ee;
      }
      return f.props = a, f.state = ee, f.context = w, ce;
    }
    function LN(e, t, a, u, f) {
      var m = t.stateNode;
      W_(e, t);
      var y = t.memoizedProps, S = t.type === t.elementType ? y : Gs(t.type, y);
      m.props = S;
      var w = t.pendingProps, k = m.context, M = a.contextType, q = Va;
      if (typeof M == "object" && M !== null)
        q = Lr(M);
      else {
        var H = _d(t, a, !0);
        q = xd(t, H);
      }
      var ee = a.getDerivedStateFromProps, re = typeof ee == "function" || typeof m.getSnapshotBeforeUpdate == "function";
      !re && (typeof m.UNSAFE_componentWillReceiveProps == "function" || typeof m.componentWillReceiveProps == "function") && (y !== w || k !== q) && Mx(t, m, u, q), G_();
      var ce = t.memoizedState, Ie = m.state = ce;
      if (Hg(t, u, m, f), Ie = t.memoizedState, y === w && ce === Ie && !xg() && !Vg())
        return typeof m.componentDidUpdate == "function" && (y !== e.memoizedProps || ce !== e.memoizedState) && (t.flags |= Xt), typeof m.getSnapshotBeforeUpdate == "function" && (y !== e.memoizedProps || ce !== e.memoizedState) && (t.flags |= Rr), !1;
      typeof ee == "function" && (NS(t, a, ee, u), Ie = t.memoizedState);
      var yt = Vg() || Nx(t, a, S, u, ce, Ie, q) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Ze;
      return yt ? (!re && (typeof m.UNSAFE_componentWillUpdate == "function" || typeof m.componentWillUpdate == "function") && (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(u, Ie, q), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(u, Ie, q)), typeof m.componentDidUpdate == "function" && (t.flags |= Xt), typeof m.getSnapshotBeforeUpdate == "function" && (t.flags |= Rr)) : (typeof m.componentDidUpdate == "function" && (y !== e.memoizedProps || ce !== e.memoizedState) && (t.flags |= Xt), typeof m.getSnapshotBeforeUpdate == "function" && (y !== e.memoizedProps || ce !== e.memoizedState) && (t.flags |= Rr), t.memoizedProps = u, t.memoizedState = Ie), m.props = u, m.state = Ie, m.context = q, yt;
    }
    function Gc(e, t) {
      return {
        value: e,
        source: t,
        stack: ks(t),
        digest: null
      };
    }
    function MS(e, t, a) {
      return {
        value: e,
        source: null,
        stack: a ?? null,
        digest: t ?? null
      };
    }
    function PN(e, t) {
      return !0;
    }
    function jS(e, t) {
      try {
        var a = PN(e, t);
        if (a === !1)
          return;
        var u = t.value, f = t.source, m = t.stack, y = m !== null ? m : "";
        if (u != null && u._suppressLogging) {
          if (e.tag === x)
            return;
          console.error(u);
        }
        var S = f ? Nt(f) : null, w = S ? "The above error occurred in the <" + S + "> component:" : "The above error occurred in one of your React components:", k;
        if (e.tag === O)
          k = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var M = Nt(e) || "Anonymous";
          k = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + M + ".");
        }
        var q = w + `
` + y + `

` + ("" + k);
        console.error(q);
      } catch (H) {
        setTimeout(function() {
          throw H;
        });
      }
    }
    var UN = typeof WeakMap == "function" ? WeakMap : Map;
    function jx(e, t, a) {
      var u = Rl(Mn, a);
      u.tag = Ib, u.payload = {
        element: null
      };
      var f = t.value;
      return u.callback = function() {
        OD(f), jS(e, t);
      }, u;
    }
    function LS(e, t, a) {
      var u = Rl(Mn, a);
      u.tag = Ib;
      var f = e.type.getDerivedStateFromError;
      if (typeof f == "function") {
        var m = t.value;
        u.payload = function() {
          return f(m);
        }, u.callback = function() {
          qC(e), jS(e, t);
        };
      }
      var y = e.stateNode;
      return y !== null && typeof y.componentDidCatch == "function" && (u.callback = function() {
        qC(e), jS(e, t), typeof f != "function" && TD(this);
        var w = t.value, k = t.stack;
        this.componentDidCatch(w, {
          componentStack: k !== null ? k : ""
        }), typeof f != "function" && (Ai(e.lanes, Ct) || p("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Nt(e) || "Unknown"));
      }), u;
    }
    function Lx(e, t, a) {
      var u = e.pingCache, f;
      if (u === null ? (u = e.pingCache = new UN(), f = /* @__PURE__ */ new Set(), u.set(t, f)) : (f = u.get(t), f === void 0 && (f = /* @__PURE__ */ new Set(), u.set(t, f))), !f.has(a)) {
        f.add(a);
        var m = ND.bind(null, e, t, a);
        Ni && um(e, a), t.then(m, m);
      }
    }
    function FN(e, t, a, u) {
      var f = e.updateQueue;
      if (f === null) {
        var m = /* @__PURE__ */ new Set();
        m.add(a), e.updateQueue = m;
      } else
        f.add(a);
    }
    function IN(e, t) {
      var a = e.tag;
      if ((e.mode & qt) === mt && (a === _ || a === ve || a === Ve)) {
        var u = e.alternate;
        u ? (e.updateQueue = u.updateQueue, e.memoizedState = u.memoizedState, e.lanes = u.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function Px(e) {
      var t = e;
      do {
        if (t.tag === Re && bN(t))
          return t;
        t = t.return;
      } while (t !== null);
      return null;
    }
    function Ux(e, t, a, u, f) {
      if ((e.mode & qt) === mt) {
        if (e === t)
          e.flags |= Ti;
        else {
          if (e.flags |= ft, a.flags |= Cf, a.flags &= -52805, a.tag === x) {
            var m = a.alternate;
            if (m === null)
              a.tag = Rt;
            else {
              var y = Rl(Mn, Ct);
              y.tag = Ig, _u(a, y, Ct);
            }
          }
          a.lanes = It(a.lanes, Ct);
        }
        return e;
      }
      return e.flags |= Ti, e.lanes = f, e;
    }
    function zN(e, t, a, u, f) {
      if (a.flags |= rc, Ni && um(e, f), u !== null && typeof u == "object" && typeof u.then == "function") {
        var m = u;
        IN(a), hi() && a.mode & qt && k_();
        var y = Px(t);
        if (y !== null) {
          y.flags &= -257, Ux(y, t, a, e, f), y.mode & qt && Lx(e, m, f), FN(y, e, m);
          return;
        } else {
          if (!Nv(f)) {
            Lx(e, m, f), pE();
            return;
          }
          var S = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          u = S;
        }
      } else if (hi() && a.mode & qt) {
        k_();
        var w = Px(t);
        if (w !== null) {
          (w.flags & Ti) === pt && (w.flags |= Ci), Ux(w, t, a, e, f), Tb(Gc(u, a));
          return;
        }
      }
      u = Gc(u, a), bD(u);
      var k = t;
      do {
        switch (k.tag) {
          case O: {
            var M = u;
            k.flags |= Ti;
            var q = yc(f);
            k.lanes = It(k.lanes, q);
            var H = jx(k, M, q);
            Bb(k, H);
            return;
          }
          case x:
            var ee = u, re = k.type, ce = k.stateNode;
            if ((k.flags & ft) === pt && (typeof re.getDerivedStateFromError == "function" || ce !== null && typeof ce.componentDidCatch == "function" && !PC(ce))) {
              k.flags |= Ti;
              var Ie = yc(f);
              k.lanes = It(k.lanes, Ie);
              var yt = LS(k, ee, Ie);
              Bb(k, yt);
              return;
            }
            break;
        }
        k = k.return;
      } while (k !== null);
    }
    function $N() {
      return null;
    }
    var Wp = s.ReactCurrentOwner, Js = !1, PS, Gp, US, FS, IS, Jc, zS, py, Jp;
    PS = {}, Gp = {}, US = {}, FS = {}, IS = {}, Jc = !1, zS = {}, py = {}, Jp = {};
    function Zi(e, t, a, u) {
      e === null ? t.child = z_(t, null, a, u) : t.child = kd(t, e.child, a, u);
    }
    function BN(e, t, a, u) {
      t.child = kd(t, e.child, null, u), t.child = kd(t, null, a, u);
    }
    function Fx(e, t, a, u, f) {
      if (t.type !== t.elementType) {
        var m = a.propTypes;
        m && Hs(
          m,
          u,
          // Resolved props
          "prop",
          rn(a)
        );
      }
      var y = a.render, S = t.ref, w, k;
      Nd(t, f), Gi(t);
      {
        if (Wp.current = t, Cr(!0), w = Pd(e, t, y, u, S, f), k = Ud(), t.mode & On) {
          Gn(!0);
          try {
            w = Pd(e, t, y, u, S, f), k = Ud();
          } finally {
            Gn(!1);
          }
        }
        Cr(!1);
      }
      return Ji(), e !== null && !Js ? (ex(e, t, f), Tl(e, t, f)) : (hi() && k && Eb(t), t.flags |= Fa, Zi(e, t, w, f), t.child);
    }
    function Ix(e, t, a, u, f) {
      if (e === null) {
        var m = a.type;
        if (WD(m) && a.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        a.defaultProps === void 0) {
          var y = m;
          return y = qd(m), t.tag = Ve, t.type = y, HS(t, m), zx(e, t, y, u, f);
        }
        {
          var S = m.propTypes;
          if (S && Hs(
            S,
            u,
            // Resolved props
            "prop",
            rn(m)
          ), a.defaultProps !== void 0) {
            var w = rn(m) || "Unknown";
            Jp[w] || (p("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", w), Jp[w] = !0);
          }
        }
        var k = CE(a.type, null, u, t, t.mode, f);
        return k.ref = t.ref, k.return = t, t.child = k, k;
      }
      {
        var M = a.type, q = M.propTypes;
        q && Hs(
          q,
          u,
          // Resolved props
          "prop",
          rn(M)
        );
      }
      var H = e.child, ee = JS(e, f);
      if (!ee) {
        var re = H.memoizedProps, ce = a.compare;
        if (ce = ce !== null ? ce : vt, ce(re, u) && e.ref === t.ref)
          return Tl(e, t, f);
      }
      t.flags |= Fa;
      var Ie = ef(H, u);
      return Ie.ref = t.ref, Ie.return = t, t.child = Ie, Ie;
    }
    function zx(e, t, a, u, f) {
      if (t.type !== t.elementType) {
        var m = t.elementType;
        if (m.$$typeof === _t) {
          var y = m, S = y._payload, w = y._init;
          try {
            m = w(S);
          } catch {
            m = null;
          }
          var k = m && m.propTypes;
          k && Hs(
            k,
            u,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            rn(m)
          );
        }
      }
      if (e !== null) {
        var M = e.memoizedProps;
        if (vt(M, u) && e.ref === t.ref && // Prevent bailout if the implementation changed due to hot reload.
        t.type === e.type)
          if (Js = !1, t.pendingProps = u = M, JS(e, f))
            (e.flags & Cf) !== pt && (Js = !0);
          else return t.lanes = e.lanes, Tl(e, t, f);
      }
      return $S(e, t, a, u, f);
    }
    function $x(e, t, a) {
      var u = t.pendingProps, f = u.children, m = e !== null ? e.memoizedState : null;
      if (u.mode === "hidden" || ke)
        if ((t.mode & qt) === mt) {
          var y = {
            baseLanes: Se,
            cachePool: null,
            transitions: null
          };
          t.memoizedState = y, Ty(t, a);
        } else if (Ai(a, Qi)) {
          var q = {
            baseLanes: Se,
            cachePool: null,
            transitions: null
          };
          t.memoizedState = q;
          var H = m !== null ? m.baseLanes : a;
          Ty(t, H);
        } else {
          var S = null, w;
          if (m !== null) {
            var k = m.baseLanes;
            w = It(k, a);
          } else
            w = a;
          t.lanes = t.childLanes = Qi;
          var M = {
            baseLanes: w,
            cachePool: S,
            transitions: null
          };
          return t.memoizedState = M, t.updateQueue = null, Ty(t, w), null;
        }
      else {
        var ee;
        m !== null ? (ee = It(m.baseLanes, a), t.memoizedState = null) : ee = a, Ty(t, ee);
      }
      return Zi(e, t, f, a), t.child;
    }
    function HN(e, t, a) {
      var u = t.pendingProps;
      return Zi(e, t, u, a), t.child;
    }
    function VN(e, t, a) {
      var u = t.pendingProps.children;
      return Zi(e, t, u, a), t.child;
    }
    function qN(e, t, a) {
      {
        t.flags |= Xt;
        {
          var u = t.stateNode;
          u.effectDuration = 0, u.passiveEffectDuration = 0;
        }
      }
      var f = t.pendingProps, m = f.children;
      return Zi(e, t, m, a), t.child;
    }
    function Bx(e, t) {
      var a = t.ref;
      (e === null && a !== null || e !== null && e.ref !== a) && (t.flags |= tr, t.flags |= iu);
    }
    function $S(e, t, a, u, f) {
      if (t.type !== t.elementType) {
        var m = a.propTypes;
        m && Hs(
          m,
          u,
          // Resolved props
          "prop",
          rn(a)
        );
      }
      var y;
      {
        var S = _d(t, a, !0);
        y = xd(t, S);
      }
      var w, k;
      Nd(t, f), Gi(t);
      {
        if (Wp.current = t, Cr(!0), w = Pd(e, t, a, u, y, f), k = Ud(), t.mode & On) {
          Gn(!0);
          try {
            w = Pd(e, t, a, u, y, f), k = Ud();
          } finally {
            Gn(!1);
          }
        }
        Cr(!1);
      }
      return Ji(), e !== null && !Js ? (ex(e, t, f), Tl(e, t, f)) : (hi() && k && Eb(t), t.flags |= Fa, Zi(e, t, w, f), t.child);
    }
    function Hx(e, t, a, u, f) {
      {
        switch (lM(t)) {
          case !1: {
            var m = t.stateNode, y = t.type, S = new y(t.memoizedProps, m.context), w = S.state;
            m.updater.enqueueSetState(m, w, null);
            break;
          }
          case !0: {
            t.flags |= ft, t.flags |= Ti;
            var k = new Error("Simulated error coming from DevTools"), M = yc(f);
            t.lanes = It(t.lanes, M);
            var q = LS(t, Gc(k, t), M);
            Bb(t, q);
            break;
          }
        }
        if (t.type !== t.elementType) {
          var H = a.propTypes;
          H && Hs(
            H,
            u,
            // Resolved props
            "prop",
            rn(a)
          );
        }
      }
      var ee;
      Mo(a) ? (ee = !0, Rg(t)) : ee = !1, Nd(t, f);
      var re = t.stateNode, ce;
      re === null ? (vy(e, t), Dx(t, a, u), DS(t, a, u, f), ce = !0) : e === null ? ce = jN(t, a, u, f) : ce = LN(e, t, a, u, f);
      var Ie = BS(e, t, a, ce, ee, f);
      {
        var yt = t.stateNode;
        ce && yt.props !== u && (Jc || p("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Nt(t) || "a component"), Jc = !0);
      }
      return Ie;
    }
    function BS(e, t, a, u, f, m) {
      Bx(e, t);
      var y = (t.flags & ft) !== pt;
      if (!u && !y)
        return f && x_(t, a, !1), Tl(e, t, m);
      var S = t.stateNode;
      Wp.current = t;
      var w;
      if (y && typeof a.getDerivedStateFromError != "function")
        w = null, Tx();
      else {
        Gi(t);
        {
          if (Cr(!0), w = S.render(), t.mode & On) {
            Gn(!0);
            try {
              S.render();
            } finally {
              Gn(!1);
            }
          }
          Cr(!1);
        }
        Ji();
      }
      return t.flags |= Fa, e !== null && y ? BN(e, t, w, m) : Zi(e, t, w, m), t.memoizedState = S.state, f && x_(t, a, !0), t.child;
    }
    function Vx(e) {
      var t = e.stateNode;
      t.pendingContext ? w_(e, t.pendingContext, t.pendingContext !== t.context) : t.context && w_(e, t.context, !1), Hb(e, t.containerInfo);
    }
    function YN(e, t, a) {
      if (Vx(t), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var u = t.pendingProps, f = t.memoizedState, m = f.element;
      W_(e, t), Hg(t, u, null, a);
      var y = t.memoizedState;
      t.stateNode;
      var S = y.element;
      if (f.isDehydrated) {
        var w = {
          element: S,
          isDehydrated: !1,
          cache: y.cache,
          pendingSuspenseBoundaries: y.pendingSuspenseBoundaries,
          transitions: y.transitions
        }, k = t.updateQueue;
        if (k.baseState = w, t.memoizedState = w, t.flags & Ci) {
          var M = Gc(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), t);
          return qx(e, t, S, a, M);
        } else if (S !== m) {
          var q = Gc(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), t);
          return qx(e, t, S, a, q);
        } else {
          JO(t);
          var H = z_(t, null, S, a);
          t.child = H;
          for (var ee = H; ee; )
            ee.flags = ee.flags & -3 | ma, ee = ee.sibling;
        }
      } else {
        if (Td(), S === m)
          return Tl(e, t, a);
        Zi(e, t, S, a);
      }
      return t.child;
    }
    function qx(e, t, a, u, f) {
      return Td(), Tb(f), t.flags |= Ci, Zi(e, t, a, u), t.child;
    }
    function WN(e, t, a) {
      K_(t), e === null && Rb(t);
      var u = t.type, f = t.pendingProps, m = e !== null ? e.memoizedProps : null, y = f.children, S = ob(u, f);
      return S ? y = null : m !== null && ob(u, m) && (t.flags |= Ia), Bx(e, t), Zi(e, t, y, a), t.child;
    }
    function GN(e, t) {
      return e === null && Rb(t), null;
    }
    function JN(e, t, a, u) {
      vy(e, t);
      var f = t.pendingProps, m = a, y = m._payload, S = m._init, w = S(y);
      t.type = w;
      var k = t.tag = GD(w), M = Gs(w, f), q;
      switch (k) {
        case _:
          return HS(t, w), t.type = w = qd(w), q = $S(null, t, w, M, u), q;
        case x:
          return t.type = w = bE(w), q = Hx(null, t, w, M, u), q;
        case ve:
          return t.type = w = SE(w), q = Fx(null, t, w, M, u), q;
        case lt: {
          if (t.type !== t.elementType) {
            var H = w.propTypes;
            H && Hs(
              H,
              M,
              // Resolved for outer only
              "prop",
              rn(w)
            );
          }
          return q = Ix(
            null,
            t,
            w,
            Gs(w.type, M),
            // The inner type can have defaults too
            u
          ), q;
        }
      }
      var ee = "";
      throw w !== null && typeof w == "object" && w.$$typeof === _t && (ee = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + w + ". " + ("Lazy element type must resolve to a class or function." + ee));
    }
    function QN(e, t, a, u, f) {
      vy(e, t), t.tag = x;
      var m;
      return Mo(a) ? (m = !0, Rg(t)) : m = !1, Nd(t, f), Dx(t, a, u), DS(t, a, u, f), BS(null, t, a, !0, m, f);
    }
    function KN(e, t, a, u) {
      vy(e, t);
      var f = t.pendingProps, m;
      {
        var y = _d(t, a, !1);
        m = xd(t, y);
      }
      Nd(t, u);
      var S, w;
      Gi(t);
      {
        if (a.prototype && typeof a.prototype.render == "function") {
          var k = rn(a) || "Unknown";
          PS[k] || (p("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", k, k), PS[k] = !0);
        }
        t.mode & On && qs.recordLegacyContextWarning(t, null), Cr(!0), Wp.current = t, S = Pd(null, t, a, f, m, u), w = Ud(), Cr(!1);
      }
      if (Ji(), t.flags |= Fa, typeof S == "object" && S !== null && typeof S.render == "function" && S.$$typeof === void 0) {
        var M = rn(a) || "Unknown";
        Gp[M] || (p("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", M, M, M), Gp[M] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof S == "object" && S !== null && typeof S.render == "function" && S.$$typeof === void 0
      ) {
        {
          var q = rn(a) || "Unknown";
          Gp[q] || (p("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", q, q, q), Gp[q] = !0);
        }
        t.tag = x, t.memoizedState = null, t.updateQueue = null;
        var H = !1;
        return Mo(a) ? (H = !0, Rg(t)) : H = !1, t.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, $b(t), Ax(t, S), DS(t, a, f, u), BS(null, t, a, !0, H, u);
      } else {
        if (t.tag = _, t.mode & On) {
          Gn(!0);
          try {
            S = Pd(null, t, a, f, m, u), w = Ud();
          } finally {
            Gn(!1);
          }
        }
        return hi() && w && Eb(t), Zi(null, t, S, u), HS(t, a), t.child;
      }
    }
    function HS(e, t) {
      {
        if (t && t.childContextTypes && p("%s(...): childContextTypes cannot be defined on a function component.", t.displayName || t.name || "Component"), e.ref !== null) {
          var a = "", u = si();
          u && (a += `

Check the render method of \`` + u + "`.");
          var f = u || "", m = e._debugSource;
          m && (f = m.fileName + ":" + m.lineNumber), IS[f] || (IS[f] = !0, p("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", a));
        }
        if (t.defaultProps !== void 0) {
          var y = rn(t) || "Unknown";
          Jp[y] || (p("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", y), Jp[y] = !0);
        }
        if (typeof t.getDerivedStateFromProps == "function") {
          var S = rn(t) || "Unknown";
          FS[S] || (p("%s: Function components do not support getDerivedStateFromProps.", S), FS[S] = !0);
        }
        if (typeof t.contextType == "object" && t.contextType !== null) {
          var w = rn(t) || "Unknown";
          US[w] || (p("%s: Function components do not support contextType.", w), US[w] = !0);
        }
      }
    }
    var VS = {
      dehydrated: null,
      treeContext: null,
      retryLane: ln
    };
    function qS(e) {
      return {
        baseLanes: e,
        cachePool: $N(),
        transitions: null
      };
    }
    function XN(e, t) {
      var a = null;
      return {
        baseLanes: It(e.baseLanes, t),
        cachePool: a,
        transitions: e.transitions
      };
    }
    function ZN(e, t, a, u) {
      if (t !== null) {
        var f = t.memoizedState;
        if (f === null)
          return !1;
      }
      return Yb(e, Fp);
    }
    function eA(e, t) {
      return bc(e.childLanes, t);
    }
    function Yx(e, t, a) {
      var u = t.pendingProps;
      uM(t) && (t.flags |= ft);
      var f = Ys.current, m = !1, y = (t.flags & ft) !== pt;
      if (y || ZN(f, e) ? (m = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (f = yN(f, Z_)), f = Dd(f), Cu(t, f), e === null) {
        Rb(t);
        var S = t.memoizedState;
        if (S !== null) {
          var w = S.dehydrated;
          if (w !== null)
            return aA(t, w);
        }
        var k = u.children, M = u.fallback;
        if (m) {
          var q = tA(t, k, M, a), H = t.child;
          return H.memoizedState = qS(a), t.memoizedState = VS, q;
        } else
          return YS(t, k);
      } else {
        var ee = e.memoizedState;
        if (ee !== null) {
          var re = ee.dehydrated;
          if (re !== null)
            return sA(e, t, y, u, re, ee, a);
        }
        if (m) {
          var ce = u.fallback, Ie = u.children, yt = rA(e, t, Ie, ce, a), ut = t.child, tn = e.child.memoizedState;
          return ut.memoizedState = tn === null ? qS(a) : XN(tn, a), ut.childLanes = eA(e, a), t.memoizedState = VS, yt;
        } else {
          var Qt = u.children, J = nA(e, t, Qt, a);
          return t.memoizedState = null, J;
        }
      }
    }
    function YS(e, t, a) {
      var u = e.mode, f = {
        mode: "visible",
        children: t
      }, m = WS(f, u);
      return m.return = e, e.child = m, m;
    }
    function tA(e, t, a, u) {
      var f = e.mode, m = e.child, y = {
        mode: "hidden",
        children: t
      }, S, w;
      return (f & qt) === mt && m !== null ? (S = m, S.childLanes = Se, S.pendingProps = y, e.mode & fn && (S.actualDuration = 0, S.actualStartTime = -1, S.selfBaseDuration = 0, S.treeBaseDuration = 0), w = Mu(a, f, u, null)) : (S = WS(y, f), w = Mu(a, f, u, null)), S.return = e, w.return = e, S.sibling = w, e.child = S, w;
    }
    function WS(e, t, a) {
      return WC(e, t, Se, null);
    }
    function Wx(e, t) {
      return ef(e, t);
    }
    function nA(e, t, a, u) {
      var f = e.child, m = f.sibling, y = Wx(f, {
        mode: "visible",
        children: a
      });
      if ((t.mode & qt) === mt && (y.lanes = u), y.return = t, y.sibling = null, m !== null) {
        var S = t.deletions;
        S === null ? (t.deletions = [m], t.flags |= pa) : S.push(m);
      }
      return t.child = y, y;
    }
    function rA(e, t, a, u, f) {
      var m = t.mode, y = e.child, S = y.sibling, w = {
        mode: "hidden",
        children: a
      }, k;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (m & qt) === mt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        t.child !== y
      ) {
        var M = t.child;
        k = M, k.childLanes = Se, k.pendingProps = w, t.mode & fn && (k.actualDuration = 0, k.actualStartTime = -1, k.selfBaseDuration = y.selfBaseDuration, k.treeBaseDuration = y.treeBaseDuration), t.deletions = null;
      } else
        k = Wx(y, w), k.subtreeFlags = y.subtreeFlags & gr;
      var q;
      return S !== null ? q = ef(S, u) : (q = Mu(u, m, f, null), q.flags |= ir), q.return = t, k.return = t, k.sibling = q, t.child = k, q;
    }
    function my(e, t, a, u) {
      u !== null && Tb(u), kd(t, e.child, null, a);
      var f = t.pendingProps, m = f.children, y = YS(t, m);
      return y.flags |= ir, t.memoizedState = null, y;
    }
    function iA(e, t, a, u, f) {
      var m = t.mode, y = {
        mode: "visible",
        children: a
      }, S = WS(y, m), w = Mu(u, m, f, null);
      return w.flags |= ir, S.return = t, w.return = t, S.sibling = w, t.child = S, (t.mode & qt) !== mt && kd(t, e.child, null, f), w;
    }
    function aA(e, t, a) {
      return (e.mode & qt) === mt ? (p("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = Ct) : fb(t) ? e.lanes = ti : e.lanes = Qi, null;
    }
    function sA(e, t, a, u, f, m, y) {
      if (a)
        if (t.flags & Ci) {
          t.flags &= -257;
          var J = MS(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return my(e, t, y, J);
        } else {
          if (t.memoizedState !== null)
            return t.child = e.child, t.flags |= ft, null;
          var fe = u.children, Q = u.fallback, xe = iA(e, t, fe, Q, y), Qe = t.child;
          return Qe.memoizedState = qS(y), t.memoizedState = VS, xe;
        }
      else {
        if (WO(), (t.mode & qt) === mt)
          return my(
            e,
            t,
            y,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (fb(f)) {
          var S, w, k;
          {
            var M = cO(f);
            S = M.digest, w = M.message, k = M.stack;
          }
          var q;
          w ? q = new Error(w) : q = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var H = MS(q, S, k);
          return my(e, t, y, H);
        }
        var ee = Ai(y, e.childLanes);
        if (Js || ee) {
          var re = Ry();
          if (re !== null) {
            var ce = Xh(re, y);
            if (ce !== ln && ce !== m.retryLane) {
              m.retryLane = ce;
              var Ie = Mn;
              xa(e, ce), Xr(re, e, ce, Ie);
            }
          }
          pE();
          var yt = MS(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return my(e, t, y, yt);
        } else if (v_(f)) {
          t.flags |= ft, t.child = e.child;
          var ut = AD.bind(null, e);
          return fO(f, ut), null;
        } else {
          QO(t, f, m.treeContext);
          var tn = u.children, Qt = YS(t, tn);
          return Qt.flags |= ma, Qt;
        }
      }
    }
    function Gx(e, t, a) {
      e.lanes = It(e.lanes, t);
      var u = e.alternate;
      u !== null && (u.lanes = It(u.lanes, t)), Ub(e.return, t, a);
    }
    function oA(e, t, a) {
      for (var u = t; u !== null; ) {
        if (u.tag === Re) {
          var f = u.memoizedState;
          f !== null && Gx(u, a, e);
        } else if (u.tag === it)
          Gx(u, a, e);
        else if (u.child !== null) {
          u.child.return = u, u = u.child;
          continue;
        }
        if (u === e)
          return;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === e)
            return;
          u = u.return;
        }
        u.sibling.return = u.return, u = u.sibling;
      }
    }
    function lA(e) {
      for (var t = e, a = null; t !== null; ) {
        var u = t.alternate;
        u !== null && Wg(u) === null && (a = t), t = t.sibling;
      }
      return a;
    }
    function uA(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !zS[e])
        if (zS[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              p('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              p('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              p('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          p('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function cA(e, t) {
      e !== void 0 && !py[e] && (e !== "collapsed" && e !== "hidden" ? (py[e] = !0, p('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : t !== "forwards" && t !== "backwards" && (py[e] = !0, p('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function Jx(e, t) {
      {
        var a = $t(e), u = !a && typeof D(e) == "function";
        if (a || u) {
          var f = a ? "array" : "iterable";
          return p("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", f, t, f), !1;
        }
      }
      return !0;
    }
    function fA(e, t) {
      if ((t === "forwards" || t === "backwards") && e !== void 0 && e !== null && e !== !1)
        if ($t(e)) {
          for (var a = 0; a < e.length; a++)
            if (!Jx(e[a], a))
              return;
        } else {
          var u = D(e);
          if (typeof u == "function") {
            var f = u.call(e);
            if (f)
              for (var m = f.next(), y = 0; !m.done; m = f.next()) {
                if (!Jx(m.value, y))
                  return;
                y++;
              }
          } else
            p('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', t);
        }
    }
    function GS(e, t, a, u, f) {
      var m = e.memoizedState;
      m === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: u,
        tail: a,
        tailMode: f
      } : (m.isBackwards = t, m.rendering = null, m.renderingStartTime = 0, m.last = u, m.tail = a, m.tailMode = f);
    }
    function Qx(e, t, a) {
      var u = t.pendingProps, f = u.revealOrder, m = u.tail, y = u.children;
      uA(f), cA(m, f), fA(y, f), Zi(e, t, y, a);
      var S = Ys.current, w = Yb(S, Fp);
      if (w)
        S = Wb(S, Fp), t.flags |= ft;
      else {
        var k = e !== null && (e.flags & ft) !== pt;
        k && oA(t, t.child, a), S = Dd(S);
      }
      if (Cu(t, S), (t.mode & qt) === mt)
        t.memoizedState = null;
      else
        switch (f) {
          case "forwards": {
            var M = lA(t.child), q;
            M === null ? (q = t.child, t.child = null) : (q = M.sibling, M.sibling = null), GS(
              t,
              !1,
              // isBackwards
              q,
              M,
              m
            );
            break;
          }
          case "backwards": {
            var H = null, ee = t.child;
            for (t.child = null; ee !== null; ) {
              var re = ee.alternate;
              if (re !== null && Wg(re) === null) {
                t.child = ee;
                break;
              }
              var ce = ee.sibling;
              ee.sibling = H, H = ee, ee = ce;
            }
            GS(
              t,
              !0,
              // isBackwards
              H,
              null,
              // last
              m
            );
            break;
          }
          case "together": {
            GS(
              t,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            t.memoizedState = null;
        }
      return t.child;
    }
    function dA(e, t, a) {
      Hb(t, t.stateNode.containerInfo);
      var u = t.pendingProps;
      return e === null ? t.child = kd(t, null, u, a) : Zi(e, t, u, a), t.child;
    }
    var Kx = !1;
    function hA(e, t, a) {
      var u = t.type, f = u._context, m = t.pendingProps, y = t.memoizedProps, S = m.value;
      {
        "value" in m || Kx || (Kx = !0, p("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var w = t.type.propTypes;
        w && Hs(w, m, "prop", "Context.Provider");
      }
      if (H_(t, f, S), y !== null) {
        var k = y.value;
        if (Be(k, S)) {
          if (y.children === m.children && !xg())
            return Tl(e, t, a);
        } else
          uN(t, f, a);
      }
      var M = m.children;
      return Zi(e, t, M, a), t.child;
    }
    var Xx = !1;
    function pA(e, t, a) {
      var u = t.type;
      u._context === void 0 ? u !== u.Consumer && (Xx || (Xx = !0, p("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : u = u._context;
      var f = t.pendingProps, m = f.children;
      typeof m != "function" && p("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Nd(t, a);
      var y = Lr(u);
      Gi(t);
      var S;
      return Wp.current = t, Cr(!0), S = m(y), Cr(!1), Ji(), t.flags |= Fa, Zi(e, t, S, a), t.child;
    }
    function Qp() {
      Js = !0;
    }
    function vy(e, t) {
      (t.mode & qt) === mt && e !== null && (e.alternate = null, t.alternate = null, t.flags |= ir);
    }
    function Tl(e, t, a) {
      return e !== null && (t.dependencies = e.dependencies), Tx(), lm(t.lanes), Ai(a, t.childLanes) ? (oN(e, t), t.child) : null;
    }
    function mA(e, t, a) {
      {
        var u = t.return;
        if (u === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, t.alternate = null, a.index = t.index, a.sibling = t.sibling, a.return = t.return, a.ref = t.ref, t === u.child)
          u.child = a;
        else {
          var f = u.child;
          if (f === null)
            throw new Error("Expected parent to have a child.");
          for (; f.sibling !== t; )
            if (f = f.sibling, f === null)
              throw new Error("Expected to find the previous sibling.");
          f.sibling = a;
        }
        var m = u.deletions;
        return m === null ? (u.deletions = [e], u.flags |= pa) : m.push(e), a.flags |= ir, a;
      }
    }
    function JS(e, t) {
      var a = e.lanes;
      return !!Ai(a, t);
    }
    function vA(e, t, a) {
      switch (t.tag) {
        case O:
          Vx(t), t.stateNode, Td();
          break;
        case z:
          K_(t);
          break;
        case x: {
          var u = t.type;
          Mo(u) && Rg(t);
          break;
        }
        case P:
          Hb(t, t.stateNode.containerInfo);
          break;
        case ae: {
          var f = t.memoizedProps.value, m = t.type._context;
          H_(t, m, f);
          break;
        }
        case De:
          {
            var y = Ai(a, t.childLanes);
            y && (t.flags |= Xt);
            {
              var S = t.stateNode;
              S.effectDuration = 0, S.passiveEffectDuration = 0;
            }
          }
          break;
        case Re: {
          var w = t.memoizedState;
          if (w !== null) {
            if (w.dehydrated !== null)
              return Cu(t, Dd(Ys.current)), t.flags |= ft, null;
            var k = t.child, M = k.childLanes;
            if (Ai(a, M))
              return Yx(e, t, a);
            Cu(t, Dd(Ys.current));
            var q = Tl(e, t, a);
            return q !== null ? q.sibling : null;
          } else
            Cu(t, Dd(Ys.current));
          break;
        }
        case it: {
          var H = (e.flags & ft) !== pt, ee = Ai(a, t.childLanes);
          if (H) {
            if (ee)
              return Qx(e, t, a);
            t.flags |= ft;
          }
          var re = t.memoizedState;
          if (re !== null && (re.rendering = null, re.tail = null, re.lastEffect = null), Cu(t, Ys.current), ee)
            break;
          return null;
        }
        case Ke:
        case Jt:
          return t.lanes = Se, $x(e, t, a);
      }
      return Tl(e, t, a);
    }
    function Zx(e, t, a) {
      if (t._debugNeedsRemount && e !== null)
        return mA(e, t, CE(t.type, t.key, t.pendingProps, t._debugOwner || null, t.mode, t.lanes));
      if (e !== null) {
        var u = e.memoizedProps, f = t.pendingProps;
        if (u !== f || xg() || // Force a re-render if the implementation changed due to hot reload:
        t.type !== e.type)
          Js = !0;
        else {
          var m = JS(e, a);
          if (!m && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (t.flags & ft) === pt)
            return Js = !1, vA(e, t, a);
          (e.flags & Cf) !== pt ? Js = !0 : Js = !1;
        }
      } else if (Js = !1, hi() && $O(t)) {
        var y = t.index, S = BO();
        T_(t, S, y);
      }
      switch (t.lanes = Se, t.tag) {
        case N:
          return KN(e, t, t.type, a);
        case wt: {
          var w = t.elementType;
          return JN(e, t, w, a);
        }
        case _: {
          var k = t.type, M = t.pendingProps, q = t.elementType === k ? M : Gs(k, M);
          return $S(e, t, k, q, a);
        }
        case x: {
          var H = t.type, ee = t.pendingProps, re = t.elementType === H ? ee : Gs(H, ee);
          return Hx(e, t, H, re, a);
        }
        case O:
          return YN(e, t, a);
        case z:
          return WN(e, t, a);
        case B:
          return GN(e, t);
        case Re:
          return Yx(e, t, a);
        case P:
          return dA(e, t, a);
        case ve: {
          var ce = t.type, Ie = t.pendingProps, yt = t.elementType === ce ? Ie : Gs(ce, Ie);
          return Fx(e, t, ce, yt, a);
        }
        case ie:
          return HN(e, t, a);
        case K:
          return VN(e, t, a);
        case De:
          return qN(e, t, a);
        case ae:
          return hA(e, t, a);
        case be:
          return pA(e, t, a);
        case lt: {
          var ut = t.type, tn = t.pendingProps, Qt = Gs(ut, tn);
          if (t.type !== t.elementType) {
            var J = ut.propTypes;
            J && Hs(
              J,
              Qt,
              // Resolved for outer only
              "prop",
              rn(ut)
            );
          }
          return Qt = Gs(ut.type, Qt), Ix(e, t, ut, Qt, a);
        }
        case Ve:
          return zx(e, t, t.type, t.pendingProps, a);
        case Rt: {
          var fe = t.type, Q = t.pendingProps, xe = t.elementType === fe ? Q : Gs(fe, Q);
          return QN(e, t, fe, xe, a);
        }
        case it:
          return Qx(e, t, a);
        case Bt:
          break;
        case Ke:
          return $x(e, t, a);
      }
      throw new Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Fd(e) {
      e.flags |= Xt;
    }
    function eC(e) {
      e.flags |= tr, e.flags |= iu;
    }
    var tC, QS, nC, rC;
    tC = function(e, t, a, u) {
      for (var f = t.child; f !== null; ) {
        if (f.tag === z || f.tag === B)
          Fk(e, f.stateNode);
        else if (f.tag !== P) {
          if (f.child !== null) {
            f.child.return = f, f = f.child;
            continue;
          }
        }
        if (f === t)
          return;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === t)
            return;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
    }, QS = function(e, t) {
    }, nC = function(e, t, a, u, f) {
      var m = e.memoizedProps;
      if (m !== u) {
        var y = t.stateNode, S = Vb(), w = zk(y, a, m, u, f, S);
        t.updateQueue = w, w && Fd(t);
      }
    }, rC = function(e, t, a, u) {
      a !== u && Fd(t);
    };
    function Kp(e, t) {
      if (!hi())
        switch (e.tailMode) {
          case "hidden": {
            for (var a = e.tail, u = null; a !== null; )
              a.alternate !== null && (u = a), a = a.sibling;
            u === null ? e.tail = null : u.sibling = null;
            break;
          }
          case "collapsed": {
            for (var f = e.tail, m = null; f !== null; )
              f.alternate !== null && (m = f), f = f.sibling;
            m === null ? !t && e.tail !== null ? e.tail.sibling = null : e.tail = null : m.sibling = null;
            break;
          }
        }
    }
    function mi(e) {
      var t = e.alternate !== null && e.alternate.child === e.child, a = Se, u = pt;
      if (t) {
        if ((e.mode & fn) !== mt) {
          for (var w = e.selfBaseDuration, k = e.child; k !== null; )
            a = It(a, It(k.lanes, k.childLanes)), u |= k.subtreeFlags & gr, u |= k.flags & gr, w += k.treeBaseDuration, k = k.sibling;
          e.treeBaseDuration = w;
        } else
          for (var M = e.child; M !== null; )
            a = It(a, It(M.lanes, M.childLanes)), u |= M.subtreeFlags & gr, u |= M.flags & gr, M.return = e, M = M.sibling;
        e.subtreeFlags |= u;
      } else {
        if ((e.mode & fn) !== mt) {
          for (var f = e.actualDuration, m = e.selfBaseDuration, y = e.child; y !== null; )
            a = It(a, It(y.lanes, y.childLanes)), u |= y.subtreeFlags, u |= y.flags, f += y.actualDuration, m += y.treeBaseDuration, y = y.sibling;
          e.actualDuration = f, e.treeBaseDuration = m;
        } else
          for (var S = e.child; S !== null; )
            a = It(a, It(S.lanes, S.childLanes)), u |= S.subtreeFlags, u |= S.flags, S.return = e, S = S.sibling;
        e.subtreeFlags |= u;
      }
      return e.childLanes = a, t;
    }
    function gA(e, t, a) {
      if (tN() && (t.mode & qt) !== mt && (t.flags & ft) === pt)
        return j_(t), Td(), t.flags |= Ci | rc | Ti, !1;
      var u = Ag(t);
      if (a !== null && a.dehydrated !== null)
        if (e === null) {
          if (!u)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (ZO(t), mi(t), (t.mode & fn) !== mt) {
            var f = a !== null;
            if (f) {
              var m = t.child;
              m !== null && (t.treeBaseDuration -= m.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Td(), (t.flags & ft) === pt && (t.memoizedState = null), t.flags |= Xt, mi(t), (t.mode & fn) !== mt) {
            var y = a !== null;
            if (y) {
              var S = t.child;
              S !== null && (t.treeBaseDuration -= S.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return L_(), !0;
    }
    function iC(e, t, a) {
      var u = t.pendingProps;
      switch (wb(t), t.tag) {
        case N:
        case wt:
        case Ve:
        case _:
        case ve:
        case ie:
        case K:
        case De:
        case be:
        case lt:
          return mi(t), null;
        case x: {
          var f = t.type;
          return Mo(f) && Cg(t), mi(t), null;
        }
        case O: {
          var m = t.stateNode;
          if (Ad(t), yb(t), Jb(), m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null), e === null || e.child === null) {
            var y = Ag(t);
            if (y)
              Fd(t);
            else if (e !== null) {
              var S = e.memoizedState;
              // Check if this is a client root
              (!S.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (t.flags & Ci) !== pt) && (t.flags |= Rr, L_());
            }
          }
          return QS(e, t), mi(t), null;
        }
        case z: {
          qb(t);
          var w = Q_(), k = t.type;
          if (e !== null && t.stateNode != null)
            nC(e, t, k, u, w), e.ref !== t.ref && eC(t);
          else {
            if (!u) {
              if (t.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return mi(t), null;
            }
            var M = Vb(), q = Ag(t);
            if (q)
              KO(t, w, M) && Fd(t);
            else {
              var H = Uk(k, u, w, M, t);
              tC(H, t, !1, !1), t.stateNode = H, Ik(H, k, u, w) && Fd(t);
            }
            t.ref !== null && eC(t);
          }
          return mi(t), null;
        }
        case B: {
          var ee = u;
          if (e && t.stateNode != null) {
            var re = e.memoizedProps;
            rC(e, t, re, ee);
          } else {
            if (typeof ee != "string" && t.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var ce = Q_(), Ie = Vb(), yt = Ag(t);
            yt ? XO(t) && Fd(t) : t.stateNode = $k(ee, ce, Ie, t);
          }
          return mi(t), null;
        }
        case Re: {
          Md(t);
          var ut = t.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var tn = gA(e, t, ut);
            if (!tn)
              return t.flags & Ti ? t : null;
          }
          if ((t.flags & ft) !== pt)
            return t.lanes = a, (t.mode & fn) !== mt && SS(t), t;
          var Qt = ut !== null, J = e !== null && e.memoizedState !== null;
          if (Qt !== J && Qt) {
            var fe = t.child;
            if (fe.flags |= vr, (t.mode & qt) !== mt) {
              var Q = e === null && (t.memoizedProps.unstable_avoidThisFallback !== !0 || !0);
              Q || Yb(Ys.current, Z_) ? yD() : pE();
            }
          }
          var xe = t.updateQueue;
          if (xe !== null && (t.flags |= Xt), mi(t), (t.mode & fn) !== mt && Qt) {
            var Qe = t.child;
            Qe !== null && (t.treeBaseDuration -= Qe.treeBaseDuration);
          }
          return null;
        }
        case P:
          return Ad(t), QS(e, t), e === null && jO(t.stateNode.containerInfo), mi(t), null;
        case ae:
          var He = t.type._context;
          return Pb(He, t), mi(t), null;
        case Rt: {
          var kt = t.type;
          return Mo(kt) && Cg(t), mi(t), null;
        }
        case it: {
          Md(t);
          var Mt = t.memoizedState;
          if (Mt === null)
            return mi(t), null;
          var An = (t.flags & ft) !== pt, pn = Mt.rendering;
          if (pn === null)
            if (An)
              Kp(Mt, !1);
            else {
              var Nr = SD() && (e === null || (e.flags & ft) === pt);
              if (!Nr)
                for (var mn = t.child; mn !== null; ) {
                  var _r = Wg(mn);
                  if (_r !== null) {
                    An = !0, t.flags |= ft, Kp(Mt, !1);
                    var Fi = _r.updateQueue;
                    return Fi !== null && (t.updateQueue = Fi, t.flags |= Xt), t.subtreeFlags = pt, lN(t, a), Cu(t, Wb(Ys.current, Fp)), t.child;
                  }
                  mn = mn.sibling;
                }
              Mt.tail !== null && Tr() > CC() && (t.flags |= ft, An = !0, Kp(Mt, !1), t.lanes = Hh);
            }
          else {
            if (!An) {
              var Si = Wg(pn);
              if (Si !== null) {
                t.flags |= ft, An = !0;
                var Ya = Si.updateQueue;
                if (Ya !== null && (t.updateQueue = Ya, t.flags |= Xt), Kp(Mt, !0), Mt.tail === null && Mt.tailMode === "hidden" && !pn.alternate && !hi())
                  return mi(t), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              Tr() * 2 - Mt.renderingStartTime > CC() && a !== Qi && (t.flags |= ft, An = !0, Kp(Mt, !1), t.lanes = Hh);
            }
            if (Mt.isBackwards)
              pn.sibling = t.child, t.child = pn;
            else {
              var na = Mt.last;
              na !== null ? na.sibling = pn : t.child = pn, Mt.last = pn;
            }
          }
          if (Mt.tail !== null) {
            var ra = Mt.tail;
            Mt.rendering = ra, Mt.tail = ra.sibling, Mt.renderingStartTime = Tr(), ra.sibling = null;
            var Ii = Ys.current;
            return An ? Ii = Wb(Ii, Fp) : Ii = Dd(Ii), Cu(t, Ii), ra;
          }
          return mi(t), null;
        }
        case Bt:
          break;
        case Ke:
        case Jt: {
          hE(t);
          var Dl = t.memoizedState, Yd = Dl !== null;
          if (e !== null) {
            var hm = e.memoizedState, $o = hm !== null;
            $o !== Yd && (t.flags |= vr);
          }
          return !Yd || (t.mode & qt) === mt ? mi(t) : Ai(zo, Qi) && (mi(t), t.subtreeFlags & (ir | Xt) && (t.flags |= vr)), null;
        }
        case jt:
          return null;
        case Ht:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function yA(e, t, a) {
      switch (wb(t), t.tag) {
        case x: {
          var u = t.type;
          Mo(u) && Cg(t);
          var f = t.flags;
          return f & Ti ? (t.flags = f & -65537 | ft, (t.mode & fn) !== mt && SS(t), t) : null;
        }
        case O: {
          t.stateNode, Ad(t), yb(t), Jb();
          var m = t.flags;
          return (m & Ti) !== pt && (m & ft) === pt ? (t.flags = m & -65537 | ft, t) : null;
        }
        case z:
          return qb(t), null;
        case Re: {
          Md(t);
          var y = t.memoizedState;
          if (y !== null && y.dehydrated !== null) {
            if (t.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Td();
          }
          var S = t.flags;
          return S & Ti ? (t.flags = S & -65537 | ft, (t.mode & fn) !== mt && SS(t), t) : null;
        }
        case it:
          return Md(t), null;
        case P:
          return Ad(t), null;
        case ae:
          var w = t.type._context;
          return Pb(w, t), null;
        case Ke:
        case Jt:
          return hE(t), null;
        case jt:
          return null;
        default:
          return null;
      }
    }
    function aC(e, t, a) {
      switch (wb(t), t.tag) {
        case x: {
          var u = t.type.childContextTypes;
          u != null && Cg(t);
          break;
        }
        case O: {
          t.stateNode, Ad(t), yb(t), Jb();
          break;
        }
        case z: {
          qb(t);
          break;
        }
        case P:
          Ad(t);
          break;
        case Re:
          Md(t);
          break;
        case it:
          Md(t);
          break;
        case ae:
          var f = t.type._context;
          Pb(f, t);
          break;
        case Ke:
        case Jt:
          hE(t);
          break;
      }
    }
    var sC = null;
    sC = /* @__PURE__ */ new Set();
    var gy = !1, vi = !1, bA = typeof WeakSet == "function" ? WeakSet : Set, tt = null, Id = null, zd = null;
    function SA(e) {
      mo(null, function() {
        throw e;
      }), nc();
    }
    var EA = function(e, t) {
      if (t.props = e.memoizedProps, t.state = e.memoizedState, e.mode & fn)
        try {
          Fo(), t.componentWillUnmount();
        } finally {
          Uo(e);
        }
      else
        t.componentWillUnmount();
    };
    function oC(e, t) {
      try {
        ku(Yr, e);
      } catch (a) {
        zn(e, t, a);
      }
    }
    function KS(e, t, a) {
      try {
        EA(e, a);
      } catch (u) {
        zn(e, t, u);
      }
    }
    function wA(e, t, a) {
      try {
        a.componentDidMount();
      } catch (u) {
        zn(e, t, u);
      }
    }
    function lC(e, t) {
      try {
        cC(e);
      } catch (a) {
        zn(e, t, a);
      }
    }
    function $d(e, t) {
      var a = e.ref;
      if (a !== null)
        if (typeof a == "function") {
          var u;
          try {
            if (dt && ot && e.mode & fn)
              try {
                Fo(), u = a(null);
              } finally {
                Uo(e);
              }
            else
              u = a(null);
          } catch (f) {
            zn(e, t, f);
          }
          typeof u == "function" && p("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Nt(e));
        } else
          a.current = null;
    }
    function yy(e, t, a) {
      try {
        a();
      } catch (u) {
        zn(e, t, u);
      }
    }
    var uC = !1;
    function _A(e, t) {
      Lk(e.containerInfo), tt = t, xA();
      var a = uC;
      return uC = !1, a;
    }
    function xA() {
      for (; tt !== null; ) {
        var e = tt, t = e.child;
        (e.subtreeFlags & go) !== pt && t !== null ? (t.return = e, tt = t) : CA();
      }
    }
    function CA() {
      for (; tt !== null; ) {
        var e = tt;
        Rn(e);
        try {
          RA(e);
        } catch (a) {
          zn(e, e.return, a);
        }
        In();
        var t = e.sibling;
        if (t !== null) {
          t.return = e.return, tt = t;
          return;
        }
        tt = e.return;
      }
    }
    function RA(e) {
      var t = e.alternate, a = e.flags;
      if ((a & Rr) !== pt) {
        switch (Rn(e), e.tag) {
          case _:
          case ve:
          case Ve:
            break;
          case x: {
            if (t !== null) {
              var u = t.memoizedProps, f = t.memoizedState, m = e.stateNode;
              e.type === e.elementType && !Jc && (m.props !== e.memoizedProps && p("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Nt(e) || "instance"), m.state !== e.memoizedState && p("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Nt(e) || "instance"));
              var y = m.getSnapshotBeforeUpdate(e.elementType === e.type ? u : Gs(e.type, u), f);
              {
                var S = sC;
                y === void 0 && !S.has(e.type) && (S.add(e.type), p("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Nt(e)));
              }
              m.__reactInternalSnapshotBeforeUpdate = y;
            }
            break;
          }
          case O: {
            {
              var w = e.stateNode;
              sO(w.containerInfo);
            }
            break;
          }
          case z:
          case B:
          case P:
          case Rt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        In();
      }
    }
    function Qs(e, t, a) {
      var u = t.updateQueue, f = u !== null ? u.lastEffect : null;
      if (f !== null) {
        var m = f.next, y = m;
        do {
          if ((y.tag & e) === e) {
            var S = y.destroy;
            y.destroy = void 0, S !== void 0 && ((e & pi) !== Ca ? Us(t) : (e & Yr) !== Ca && ac(t), (e & jo) !== Ca && cm(!0), yy(t, a, S), (e & jo) !== Ca && cm(!1), (e & pi) !== Ca ? Eo() : (e & Yr) !== Ca && $h());
          }
          y = y.next;
        } while (y !== m);
      }
    }
    function ku(e, t) {
      var a = t.updateQueue, u = a !== null ? a.lastEffect : null;
      if (u !== null) {
        var f = u.next, m = f;
        do {
          if ((m.tag & e) === e) {
            (e & pi) !== Ca ? zh(t) : (e & Yr) !== Ca && Af(t);
            var y = m.create;
            (e & jo) !== Ca && cm(!0), m.destroy = y(), (e & jo) !== Ca && cm(!1), (e & pi) !== Ca ? Cv() : (e & Yr) !== Ca && Rv();
            {
              var S = m.destroy;
              if (S !== void 0 && typeof S != "function") {
                var w = void 0;
                (m.tag & Yr) !== pt ? w = "useLayoutEffect" : (m.tag & jo) !== pt ? w = "useInsertionEffect" : w = "useEffect";
                var k = void 0;
                S === null ? k = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof S.then == "function" ? k = `

It looks like you wrote ` + w + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + w + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : k = " You returned: " + S, p("%s must not return anything besides a function, which is used for clean-up.%s", w, k);
              }
            }
          }
          m = m.next;
        } while (m !== f);
      }
    }
    function TA(e, t) {
      if ((t.flags & Xt) !== pt)
        switch (t.tag) {
          case De: {
            var a = t.stateNode.passiveEffectDuration, u = t.memoizedProps, f = u.id, m = u.onPostCommit, y = Cx(), S = t.alternate === null ? "mount" : "update";
            xx() && (S = "nested-update"), typeof m == "function" && m(f, S, a, y);
            var w = t.return;
            e: for (; w !== null; ) {
              switch (w.tag) {
                case O:
                  var k = w.stateNode;
                  k.passiveEffectDuration += a;
                  break e;
                case De:
                  var M = w.stateNode;
                  M.passiveEffectDuration += a;
                  break e;
              }
              w = w.return;
            }
            break;
          }
        }
    }
    function kA(e, t, a, u) {
      if ((a.flags & bo) !== pt)
        switch (a.tag) {
          case _:
          case ve:
          case Ve: {
            if (!vi)
              if (a.mode & fn)
                try {
                  Fo(), ku(Yr | qr, a);
                } finally {
                  Uo(a);
                }
              else
                ku(Yr | qr, a);
            break;
          }
          case x: {
            var f = a.stateNode;
            if (a.flags & Xt && !vi)
              if (t === null)
                if (a.type === a.elementType && !Jc && (f.props !== a.memoizedProps && p("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Nt(a) || "instance"), f.state !== a.memoizedState && p("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Nt(a) || "instance")), a.mode & fn)
                  try {
                    Fo(), f.componentDidMount();
                  } finally {
                    Uo(a);
                  }
                else
                  f.componentDidMount();
              else {
                var m = a.elementType === a.type ? t.memoizedProps : Gs(a.type, t.memoizedProps), y = t.memoizedState;
                if (a.type === a.elementType && !Jc && (f.props !== a.memoizedProps && p("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Nt(a) || "instance"), f.state !== a.memoizedState && p("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Nt(a) || "instance")), a.mode & fn)
                  try {
                    Fo(), f.componentDidUpdate(m, y, f.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Uo(a);
                  }
                else
                  f.componentDidUpdate(m, y, f.__reactInternalSnapshotBeforeUpdate);
              }
            var S = a.updateQueue;
            S !== null && (a.type === a.elementType && !Jc && (f.props !== a.memoizedProps && p("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Nt(a) || "instance"), f.state !== a.memoizedState && p("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Nt(a) || "instance")), J_(a, S, f));
            break;
          }
          case O: {
            var w = a.updateQueue;
            if (w !== null) {
              var k = null;
              if (a.child !== null)
                switch (a.child.tag) {
                  case z:
                    k = a.child.stateNode;
                    break;
                  case x:
                    k = a.child.stateNode;
                    break;
                }
              J_(a, w, k);
            }
            break;
          }
          case z: {
            var M = a.stateNode;
            if (t === null && a.flags & Xt) {
              var q = a.type, H = a.memoizedProps;
              Yk(M, q, H);
            }
            break;
          }
          case B:
            break;
          case P:
            break;
          case De: {
            {
              var ee = a.memoizedProps, re = ee.onCommit, ce = ee.onRender, Ie = a.stateNode.effectDuration, yt = Cx(), ut = t === null ? "mount" : "update";
              xx() && (ut = "nested-update"), typeof ce == "function" && ce(a.memoizedProps.id, ut, a.actualDuration, a.treeBaseDuration, a.actualStartTime, yt);
              {
                typeof re == "function" && re(a.memoizedProps.id, ut, Ie, yt), CD(a);
                var tn = a.return;
                e: for (; tn !== null; ) {
                  switch (tn.tag) {
                    case O:
                      var Qt = tn.stateNode;
                      Qt.effectDuration += Ie;
                      break e;
                    case De:
                      var J = tn.stateNode;
                      J.effectDuration += Ie;
                      break e;
                  }
                  tn = tn.return;
                }
              }
            }
            break;
          }
          case Re: {
            PA(e, a);
            break;
          }
          case it:
          case Rt:
          case Bt:
          case Ke:
          case Jt:
          case Ht:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      vi || a.flags & tr && cC(a);
    }
    function OA(e) {
      switch (e.tag) {
        case _:
        case ve:
        case Ve: {
          if (e.mode & fn)
            try {
              Fo(), oC(e, e.return);
            } finally {
              Uo(e);
            }
          else
            oC(e, e.return);
          break;
        }
        case x: {
          var t = e.stateNode;
          typeof t.componentDidMount == "function" && wA(e, e.return, t), lC(e, e.return);
          break;
        }
        case z: {
          lC(e, e.return);
          break;
        }
      }
    }
    function NA(e, t) {
      for (var a = null, u = e; ; ) {
        if (u.tag === z) {
          if (a === null) {
            a = u;
            try {
              var f = u.stateNode;
              t ? nO(f) : iO(u.stateNode, u.memoizedProps);
            } catch (y) {
              zn(e, e.return, y);
            }
          }
        } else if (u.tag === B) {
          if (a === null)
            try {
              var m = u.stateNode;
              t ? rO(m) : aO(m, u.memoizedProps);
            } catch (y) {
              zn(e, e.return, y);
            }
        } else if (!((u.tag === Ke || u.tag === Jt) && u.memoizedState !== null && u !== e)) {
          if (u.child !== null) {
            u.child.return = u, u = u.child;
            continue;
          }
        }
        if (u === e)
          return;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === e)
            return;
          a === u && (a = null), u = u.return;
        }
        a === u && (a = null), u.sibling.return = u.return, u = u.sibling;
      }
    }
    function cC(e) {
      var t = e.ref;
      if (t !== null) {
        var a = e.stateNode, u;
        switch (e.tag) {
          case z:
            u = a;
            break;
          default:
            u = a;
        }
        if (typeof t == "function") {
          var f;
          if (e.mode & fn)
            try {
              Fo(), f = t(u);
            } finally {
              Uo(e);
            }
          else
            f = t(u);
          typeof f == "function" && p("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Nt(e));
        } else
          t.hasOwnProperty("current") || p("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Nt(e)), t.current = u;
      }
    }
    function AA(e) {
      var t = e.alternate;
      t !== null && (t.return = null), e.return = null;
    }
    function fC(e) {
      var t = e.alternate;
      t !== null && (e.alternate = null, fC(t));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === z) {
          var a = e.stateNode;
          a !== null && UO(a);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function DA(e) {
      for (var t = e.return; t !== null; ) {
        if (dC(t))
          return t;
        t = t.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function dC(e) {
      return e.tag === z || e.tag === O || e.tag === P;
    }
    function hC(e) {
      var t = e;
      e: for (; ; ) {
        for (; t.sibling === null; ) {
          if (t.return === null || dC(t.return))
            return null;
          t = t.return;
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== z && t.tag !== B && t.tag !== zt; ) {
          if (t.flags & ir || t.child === null || t.tag === P)
            continue e;
          t.child.return = t, t = t.child;
        }
        if (!(t.flags & ir))
          return t.stateNode;
      }
    }
    function MA(e) {
      var t = DA(e);
      switch (t.tag) {
        case z: {
          var a = t.stateNode;
          t.flags & Ia && (m_(a), t.flags &= -33);
          var u = hC(e);
          ZS(e, u, a);
          break;
        }
        case O:
        case P: {
          var f = t.stateNode.containerInfo, m = hC(e);
          XS(e, m, f);
          break;
        }
        // eslint-disable-next-line-no-fallthrough
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function XS(e, t, a) {
      var u = e.tag, f = u === z || u === B;
      if (f) {
        var m = e.stateNode;
        t ? Xk(a, m, t) : Qk(a, m);
      } else if (u !== P) {
        var y = e.child;
        if (y !== null) {
          XS(y, t, a);
          for (var S = y.sibling; S !== null; )
            XS(S, t, a), S = S.sibling;
        }
      }
    }
    function ZS(e, t, a) {
      var u = e.tag, f = u === z || u === B;
      if (f) {
        var m = e.stateNode;
        t ? Kk(a, m, t) : Jk(a, m);
      } else if (u !== P) {
        var y = e.child;
        if (y !== null) {
          ZS(y, t, a);
          for (var S = y.sibling; S !== null; )
            ZS(S, t, a), S = S.sibling;
        }
      }
    }
    var gi = null, Ks = !1;
    function jA(e, t, a) {
      {
        var u = t;
        e: for (; u !== null; ) {
          switch (u.tag) {
            case z: {
              gi = u.stateNode, Ks = !1;
              break e;
            }
            case O: {
              gi = u.stateNode.containerInfo, Ks = !0;
              break e;
            }
            case P: {
              gi = u.stateNode.containerInfo, Ks = !0;
              break e;
            }
          }
          u = u.return;
        }
        if (gi === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        pC(e, t, a), gi = null, Ks = !1;
      }
      AA(a);
    }
    function Ou(e, t, a) {
      for (var u = a.child; u !== null; )
        pC(e, t, u), u = u.sibling;
    }
    function pC(e, t, a) {
      switch (Uh(a), a.tag) {
        case z:
          vi || $d(a, t);
        // eslint-disable-next-line-no-fallthrough
        case B: {
          {
            var u = gi, f = Ks;
            gi = null, Ou(e, t, a), gi = u, Ks = f, gi !== null && (Ks ? eO(gi, a.stateNode) : Zk(gi, a.stateNode));
          }
          return;
        }
        case zt: {
          gi !== null && (Ks ? tO(gi, a.stateNode) : cb(gi, a.stateNode));
          return;
        }
        case P: {
          {
            var m = gi, y = Ks;
            gi = a.stateNode.containerInfo, Ks = !0, Ou(e, t, a), gi = m, Ks = y;
          }
          return;
        }
        case _:
        case ve:
        case lt:
        case Ve: {
          if (!vi) {
            var S = a.updateQueue;
            if (S !== null) {
              var w = S.lastEffect;
              if (w !== null) {
                var k = w.next, M = k;
                do {
                  var q = M, H = q.destroy, ee = q.tag;
                  H !== void 0 && ((ee & jo) !== Ca ? yy(a, t, H) : (ee & Yr) !== Ca && (ac(a), a.mode & fn ? (Fo(), yy(a, t, H), Uo(a)) : yy(a, t, H), $h())), M = M.next;
                } while (M !== k);
              }
            }
          }
          Ou(e, t, a);
          return;
        }
        case x: {
          if (!vi) {
            $d(a, t);
            var re = a.stateNode;
            typeof re.componentWillUnmount == "function" && KS(a, t, re);
          }
          Ou(e, t, a);
          return;
        }
        case Bt: {
          Ou(e, t, a);
          return;
        }
        case Ke: {
          if (
            // TODO: Remove this dead flag
            a.mode & qt
          ) {
            var ce = vi;
            vi = ce || a.memoizedState !== null, Ou(e, t, a), vi = ce;
          } else
            Ou(e, t, a);
          break;
        }
        default: {
          Ou(e, t, a);
          return;
        }
      }
    }
    function LA(e) {
      e.memoizedState;
    }
    function PA(e, t) {
      var a = t.memoizedState;
      if (a === null) {
        var u = t.alternate;
        if (u !== null) {
          var f = u.memoizedState;
          if (f !== null) {
            var m = f.dehydrated;
            m !== null && SO(m);
          }
        }
      }
    }
    function mC(e) {
      var t = e.updateQueue;
      if (t !== null) {
        e.updateQueue = null;
        var a = e.stateNode;
        a === null && (a = e.stateNode = new bA()), t.forEach(function(u) {
          var f = DD.bind(null, e, u);
          if (!a.has(u)) {
            if (a.add(u), Ni)
              if (Id !== null && zd !== null)
                um(zd, Id);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            u.then(f, f);
          }
        });
      }
    }
    function UA(e, t, a) {
      Id = a, zd = e, Rn(t), vC(t, e), Rn(t), Id = null, zd = null;
    }
    function Xs(e, t, a) {
      var u = t.deletions;
      if (u !== null)
        for (var f = 0; f < u.length; f++) {
          var m = u[f];
          try {
            jA(e, t, m);
          } catch (w) {
            zn(m, t, w);
          }
        }
      var y = oo();
      if (t.subtreeFlags & yo)
        for (var S = t.child; S !== null; )
          Rn(S), vC(S, e), S = S.sibling;
      Rn(y);
    }
    function vC(e, t, a) {
      var u = e.alternate, f = e.flags;
      switch (e.tag) {
        case _:
        case ve:
        case lt:
        case Ve: {
          if (Xs(t, e), Io(e), f & Xt) {
            try {
              Qs(jo | qr, e, e.return), ku(jo | qr, e);
            } catch (kt) {
              zn(e, e.return, kt);
            }
            if (e.mode & fn) {
              try {
                Fo(), Qs(Yr | qr, e, e.return);
              } catch (kt) {
                zn(e, e.return, kt);
              }
              Uo(e);
            } else
              try {
                Qs(Yr | qr, e, e.return);
              } catch (kt) {
                zn(e, e.return, kt);
              }
          }
          return;
        }
        case x: {
          Xs(t, e), Io(e), f & tr && u !== null && $d(u, u.return);
          return;
        }
        case z: {
          Xs(t, e), Io(e), f & tr && u !== null && $d(u, u.return);
          {
            if (e.flags & Ia) {
              var m = e.stateNode;
              try {
                m_(m);
              } catch (kt) {
                zn(e, e.return, kt);
              }
            }
            if (f & Xt) {
              var y = e.stateNode;
              if (y != null) {
                var S = e.memoizedProps, w = u !== null ? u.memoizedProps : S, k = e.type, M = e.updateQueue;
                if (e.updateQueue = null, M !== null)
                  try {
                    Wk(y, M, k, w, S, e);
                  } catch (kt) {
                    zn(e, e.return, kt);
                  }
              }
            }
          }
          return;
        }
        case B: {
          if (Xs(t, e), Io(e), f & Xt) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var q = e.stateNode, H = e.memoizedProps, ee = u !== null ? u.memoizedProps : H;
            try {
              Gk(q, ee, H);
            } catch (kt) {
              zn(e, e.return, kt);
            }
          }
          return;
        }
        case O: {
          if (Xs(t, e), Io(e), f & Xt && u !== null) {
            var re = u.memoizedState;
            if (re.isDehydrated)
              try {
                bO(t.containerInfo);
              } catch (kt) {
                zn(e, e.return, kt);
              }
          }
          return;
        }
        case P: {
          Xs(t, e), Io(e);
          return;
        }
        case Re: {
          Xs(t, e), Io(e);
          var ce = e.child;
          if (ce.flags & vr) {
            var Ie = ce.stateNode, yt = ce.memoizedState, ut = yt !== null;
            if (Ie.isHidden = ut, ut) {
              var tn = ce.alternate !== null && ce.alternate.memoizedState !== null;
              tn || gD();
            }
          }
          if (f & Xt) {
            try {
              LA(e);
            } catch (kt) {
              zn(e, e.return, kt);
            }
            mC(e);
          }
          return;
        }
        case Ke: {
          var Qt = u !== null && u.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & qt
          ) {
            var J = vi;
            vi = J || Qt, Xs(t, e), vi = J;
          } else
            Xs(t, e);
          if (Io(e), f & vr) {
            var fe = e.stateNode, Q = e.memoizedState, xe = Q !== null, Qe = e;
            if (fe.isHidden = xe, xe && !Qt && (Qe.mode & qt) !== mt) {
              tt = Qe;
              for (var He = Qe.child; He !== null; )
                tt = He, IA(He), He = He.sibling;
            }
            NA(Qe, xe);
          }
          return;
        }
        case it: {
          Xs(t, e), Io(e), f & Xt && mC(e);
          return;
        }
        case Bt:
          return;
        default: {
          Xs(t, e), Io(e);
          return;
        }
      }
    }
    function Io(e) {
      var t = e.flags;
      if (t & ir) {
        try {
          MA(e);
        } catch (a) {
          zn(e, e.return, a);
        }
        e.flags &= -3;
      }
      t & ma && (e.flags &= -4097);
    }
    function FA(e, t, a) {
      Id = a, zd = t, tt = e, gC(e, t, a), Id = null, zd = null;
    }
    function gC(e, t, a) {
      for (var u = (e.mode & qt) !== mt; tt !== null; ) {
        var f = tt, m = f.child;
        if (f.tag === Ke && u) {
          var y = f.memoizedState !== null, S = y || gy;
          if (S) {
            eE(e, t, a);
            continue;
          } else {
            var w = f.alternate, k = w !== null && w.memoizedState !== null, M = k || vi, q = gy, H = vi;
            gy = S, vi = M, vi && !H && (tt = f, zA(f));
            for (var ee = m; ee !== null; )
              tt = ee, gC(
                ee,
                // New root; bubble back up to here and stop.
                t,
                a
              ), ee = ee.sibling;
            tt = f, gy = q, vi = H, eE(e, t, a);
            continue;
          }
        }
        (f.subtreeFlags & bo) !== pt && m !== null ? (m.return = f, tt = m) : eE(e, t, a);
      }
    }
    function eE(e, t, a) {
      for (; tt !== null; ) {
        var u = tt;
        if ((u.flags & bo) !== pt) {
          var f = u.alternate;
          Rn(u);
          try {
            kA(t, f, u, a);
          } catch (y) {
            zn(u, u.return, y);
          }
          In();
        }
        if (u === e) {
          tt = null;
          return;
        }
        var m = u.sibling;
        if (m !== null) {
          m.return = u.return, tt = m;
          return;
        }
        tt = u.return;
      }
    }
    function IA(e) {
      for (; tt !== null; ) {
        var t = tt, a = t.child;
        switch (t.tag) {
          case _:
          case ve:
          case lt:
          case Ve: {
            if (t.mode & fn)
              try {
                Fo(), Qs(Yr, t, t.return);
              } finally {
                Uo(t);
              }
            else
              Qs(Yr, t, t.return);
            break;
          }
          case x: {
            $d(t, t.return);
            var u = t.stateNode;
            typeof u.componentWillUnmount == "function" && KS(t, t.return, u);
            break;
          }
          case z: {
            $d(t, t.return);
            break;
          }
          case Ke: {
            var f = t.memoizedState !== null;
            if (f) {
              yC(e);
              continue;
            }
            break;
          }
        }
        a !== null ? (a.return = t, tt = a) : yC(e);
      }
    }
    function yC(e) {
      for (; tt !== null; ) {
        var t = tt;
        if (t === e) {
          tt = null;
          return;
        }
        var a = t.sibling;
        if (a !== null) {
          a.return = t.return, tt = a;
          return;
        }
        tt = t.return;
      }
    }
    function zA(e) {
      for (; tt !== null; ) {
        var t = tt, a = t.child;
        if (t.tag === Ke) {
          var u = t.memoizedState !== null;
          if (u) {
            bC(e);
            continue;
          }
        }
        a !== null ? (a.return = t, tt = a) : bC(e);
      }
    }
    function bC(e) {
      for (; tt !== null; ) {
        var t = tt;
        Rn(t);
        try {
          OA(t);
        } catch (u) {
          zn(t, t.return, u);
        }
        if (In(), t === e) {
          tt = null;
          return;
        }
        var a = t.sibling;
        if (a !== null) {
          a.return = t.return, tt = a;
          return;
        }
        tt = t.return;
      }
    }
    function $A(e, t, a, u) {
      tt = t, BA(t, e, a, u);
    }
    function BA(e, t, a, u) {
      for (; tt !== null; ) {
        var f = tt, m = f.child;
        (f.subtreeFlags & Ls) !== pt && m !== null ? (m.return = f, tt = m) : HA(e, t, a, u);
      }
    }
    function HA(e, t, a, u) {
      for (; tt !== null; ) {
        var f = tt;
        if ((f.flags & Ri) !== pt) {
          Rn(f);
          try {
            VA(t, f, a, u);
          } catch (y) {
            zn(f, f.return, y);
          }
          In();
        }
        if (f === e) {
          tt = null;
          return;
        }
        var m = f.sibling;
        if (m !== null) {
          m.return = f.return, tt = m;
          return;
        }
        tt = f.return;
      }
    }
    function VA(e, t, a, u) {
      switch (t.tag) {
        case _:
        case ve:
        case Ve: {
          if (t.mode & fn) {
            bS();
            try {
              ku(pi | qr, t);
            } finally {
              yS(t);
            }
          } else
            ku(pi | qr, t);
          break;
        }
      }
    }
    function qA(e) {
      tt = e, YA();
    }
    function YA() {
      for (; tt !== null; ) {
        var e = tt, t = e.child;
        if ((tt.flags & pa) !== pt) {
          var a = e.deletions;
          if (a !== null) {
            for (var u = 0; u < a.length; u++) {
              var f = a[u];
              tt = f, JA(f, e);
            }
            {
              var m = e.alternate;
              if (m !== null) {
                var y = m.child;
                if (y !== null) {
                  m.child = null;
                  do {
                    var S = y.sibling;
                    y.sibling = null, y = S;
                  } while (y !== null);
                }
              }
            }
            tt = e;
          }
        }
        (e.subtreeFlags & Ls) !== pt && t !== null ? (t.return = e, tt = t) : WA();
      }
    }
    function WA() {
      for (; tt !== null; ) {
        var e = tt;
        (e.flags & Ri) !== pt && (Rn(e), GA(e), In());
        var t = e.sibling;
        if (t !== null) {
          t.return = e.return, tt = t;
          return;
        }
        tt = e.return;
      }
    }
    function GA(e) {
      switch (e.tag) {
        case _:
        case ve:
        case Ve: {
          e.mode & fn ? (bS(), Qs(pi | qr, e, e.return), yS(e)) : Qs(pi | qr, e, e.return);
          break;
        }
      }
    }
    function JA(e, t) {
      for (; tt !== null; ) {
        var a = tt;
        Rn(a), KA(a, t), In();
        var u = a.child;
        u !== null ? (u.return = a, tt = u) : QA(e);
      }
    }
    function QA(e) {
      for (; tt !== null; ) {
        var t = tt, a = t.sibling, u = t.return;
        if (fC(t), t === e) {
          tt = null;
          return;
        }
        if (a !== null) {
          a.return = u, tt = a;
          return;
        }
        tt = u;
      }
    }
    function KA(e, t) {
      switch (e.tag) {
        case _:
        case ve:
        case Ve: {
          e.mode & fn ? (bS(), Qs(pi, e, t), yS(e)) : Qs(pi, e, t);
          break;
        }
      }
    }
    function XA(e) {
      switch (e.tag) {
        case _:
        case ve:
        case Ve: {
          try {
            ku(Yr | qr, e);
          } catch (a) {
            zn(e, e.return, a);
          }
          break;
        }
        case x: {
          var t = e.stateNode;
          try {
            t.componentDidMount();
          } catch (a) {
            zn(e, e.return, a);
          }
          break;
        }
      }
    }
    function ZA(e) {
      switch (e.tag) {
        case _:
        case ve:
        case Ve: {
          try {
            ku(pi | qr, e);
          } catch (t) {
            zn(e, e.return, t);
          }
          break;
        }
      }
    }
    function eD(e) {
      switch (e.tag) {
        case _:
        case ve:
        case Ve: {
          try {
            Qs(Yr | qr, e, e.return);
          } catch (a) {
            zn(e, e.return, a);
          }
          break;
        }
        case x: {
          var t = e.stateNode;
          typeof t.componentWillUnmount == "function" && KS(e, e.return, t);
          break;
        }
      }
    }
    function tD(e) {
      switch (e.tag) {
        case _:
        case ve:
        case Ve:
          try {
            Qs(pi | qr, e, e.return);
          } catch (t) {
            zn(e, e.return, t);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Xp = Symbol.for;
      Xp("selector.component"), Xp("selector.has_pseudo_class"), Xp("selector.role"), Xp("selector.test_id"), Xp("selector.text");
    }
    var nD = [];
    function rD() {
      nD.forEach(function(e) {
        return e();
      });
    }
    var iD = s.ReactCurrentActQueue;
    function aD(e) {
      {
        var t = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), a = typeof jest < "u";
        return a && t !== !1;
      }
    }
    function SC() {
      {
        var e = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && iD.current !== null && p("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var sD = Math.ceil, tE = s.ReactCurrentDispatcher, nE = s.ReactCurrentOwner, yi = s.ReactCurrentBatchConfig, Zs = s.ReactCurrentActQueue, Jr = (
      /*             */
      0
    ), EC = (
      /*               */
      1
    ), bi = (
      /*                */
      2
    ), Es = (
      /*                */
      4
    ), kl = 0, Zp = 1, Qc = 2, by = 3, em = 4, wC = 5, rE = 6, en = Jr, ea = null, cr = null, Qr = Se, zo = Se, iE = bu(Se), Kr = kl, tm = null, Sy = Se, nm = Se, Ey = Se, rm = null, Ra = null, aE = 0, _C = 500, xC = 1 / 0, oD = 500, Ol = null;
    function im() {
      xC = Tr() + oD;
    }
    function CC() {
      return xC;
    }
    var wy = !1, sE = null, Bd = null, Kc = !1, Nu = null, am = Se, oE = [], lE = null, lD = 50, sm = 0, uE = null, cE = !1, _y = !1, uD = 50, Hd = 0, xy = null, om = Mn, Cy = Se, RC = !1;
    function Ry() {
      return ea;
    }
    function ta() {
      return (en & (bi | Es)) !== Jr ? Tr() : (om !== Mn || (om = Tr()), om);
    }
    function Au(e) {
      var t = e.mode;
      if ((t & qt) === mt)
        return Ct;
      if ((en & bi) !== Jr && Qr !== Se)
        return yc(Qr);
      var a = iN() !== rN;
      if (a) {
        if (yi.transition !== null) {
          var u = yi.transition;
          u._updatedFibers || (u._updatedFibers = /* @__PURE__ */ new Set()), u._updatedFibers.add(e);
        }
        return Cy === ln && (Cy = Jh()), Cy;
      }
      var f = Ea();
      if (f !== ln)
        return f;
      var m = Bk();
      return m;
    }
    function cD(e) {
      var t = e.mode;
      return (t & qt) === mt ? Ct : Dv();
    }
    function Xr(e, t, a, u) {
      jD(), RC && p("useInsertionEffect must not schedule updates."), cE && (_y = !0), lu(e, a, u), (en & bi) !== Se && e === ea ? UD(t) : (Ni && Ec(e, t, a), FD(t), e === ea && ((en & bi) === Jr && (nm = It(nm, a)), Kr === em && Du(e, Qr)), Ta(e, u), a === Ct && en === Jr && (t.mode & qt) === mt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Zs.isBatchingLegacy && (im(), R_()));
    }
    function fD(e, t, a) {
      var u = e.current;
      u.lanes = t, lu(e, t, a), Ta(e, a);
    }
    function dD(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (en & bi) !== Jr
      );
    }
    function Ta(e, t) {
      var a = e.callbackNode;
      Kf(e, t);
      var u = Qf(e, e === ea ? Qr : Se);
      if (u === Se) {
        a !== null && BC(a), e.callbackNode = null, e.callbackPriority = ln;
        return;
      }
      var f = xo(u), m = e.callbackPriority;
      if (m === f && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Zs.current !== null && a !== gE)) {
        a == null && m !== Ct && p("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      a != null && BC(a);
      var y;
      if (f === Ct)
        e.tag === Su ? (Zs.isBatchingLegacy !== null && (Zs.didScheduleLegacyUpdate = !0), zO(OC.bind(null, e))) : C_(OC.bind(null, e)), Zs.current !== null ? Zs.current.push(Eu) : Vk(function() {
          (en & (bi | Es)) === Jr && Eu();
        }), y = null;
      else {
        var S;
        switch (Iv(u)) {
          case li:
            S = ic;
            break;
          case fs:
            S = So;
            break;
          case ba:
            S = Ps;
            break;
          case Sa:
            S = rl;
            break;
          default:
            S = Ps;
            break;
        }
        y = yE(S, TC.bind(null, e));
      }
      e.callbackPriority = f, e.callbackNode = y;
    }
    function TC(e, t) {
      if (NN(), om = Mn, Cy = Se, (en & (bi | Es)) !== Jr)
        throw new Error("Should not already be working.");
      var a = e.callbackNode, u = Al();
      if (u && e.callbackNode !== a)
        return null;
      var f = Qf(e, e === ea ? Qr : Se);
      if (f === Se)
        return null;
      var m = !Zf(e, f) && !Av(e, f) && !t, y = m ? wD(e, f) : ky(e, f);
      if (y !== kl) {
        if (y === Qc) {
          var S = Xf(e);
          S !== Se && (f = S, y = fE(e, S));
        }
        if (y === Zp) {
          var w = tm;
          throw Xc(e, Se), Du(e, f), Ta(e, Tr()), w;
        }
        if (y === rE)
          Du(e, f);
        else {
          var k = !Zf(e, f), M = e.current.alternate;
          if (k && !pD(M)) {
            if (y = ky(e, f), y === Qc) {
              var q = Xf(e);
              q !== Se && (f = q, y = fE(e, q));
            }
            if (y === Zp) {
              var H = tm;
              throw Xc(e, Se), Du(e, f), Ta(e, Tr()), H;
            }
          }
          e.finishedWork = M, e.finishedLanes = f, hD(e, y, f);
        }
      }
      return Ta(e, Tr()), e.callbackNode === a ? TC.bind(null, e) : null;
    }
    function fE(e, t) {
      var a = rm;
      if (nd(e)) {
        var u = Xc(e, t);
        u.flags |= Ci, MO(e.containerInfo);
      }
      var f = ky(e, t);
      if (f !== Qc) {
        var m = Ra;
        Ra = a, m !== null && kC(m);
      }
      return f;
    }
    function kC(e) {
      Ra === null ? Ra = e : Ra.push.apply(Ra, e);
    }
    function hD(e, t, a) {
      switch (t) {
        case kl:
        case Zp:
          throw new Error("Root did not complete. This is a bug in React.");
        // Flow knows about invariant, so it complains if I add a break
        // statement, but eslint doesn't know about invariant, so it complains
        // if I do. eslint-disable-next-line no-fallthrough
        case Qc: {
          Zc(e, Ra, Ol);
          break;
        }
        case by: {
          if (Du(e, a), pl(a) && // do not delay if we're inside an act() scope
          !HC()) {
            var u = aE + _C - Tr();
            if (u > 10) {
              var f = Qf(e, Se);
              if (f !== Se)
                break;
              var m = e.suspendedLanes;
              if (!ml(m, a)) {
                ta(), ed(e, m);
                break;
              }
              e.timeoutHandle = lb(Zc.bind(null, e, Ra, Ol), u);
              break;
            }
          }
          Zc(e, Ra, Ol);
          break;
        }
        case em: {
          if (Du(e, a), Wh(a))
            break;
          if (!HC()) {
            var y = $a(e, a), S = y, w = Tr() - S, k = MD(w) - w;
            if (k > 10) {
              e.timeoutHandle = lb(Zc.bind(null, e, Ra, Ol), k);
              break;
            }
          }
          Zc(e, Ra, Ol);
          break;
        }
        case wC: {
          Zc(e, Ra, Ol);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function pD(e) {
      for (var t = e; ; ) {
        if (t.flags & ru) {
          var a = t.updateQueue;
          if (a !== null) {
            var u = a.stores;
            if (u !== null)
              for (var f = 0; f < u.length; f++) {
                var m = u[f], y = m.getSnapshot, S = m.value;
                try {
                  if (!Be(y(), S))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var w = t.child;
        if (t.subtreeFlags & ru && w !== null) {
          w.return = t, t = w;
          continue;
        }
        if (t === e)
          return !0;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
            return !0;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      return !0;
    }
    function Du(e, t) {
      t = bc(t, Ey), t = bc(t, nm), Lv(e, t);
    }
    function OC(e) {
      if (AN(), (en & (bi | Es)) !== Jr)
        throw new Error("Should not already be working.");
      Al();
      var t = Qf(e, Se);
      if (!Ai(t, Ct))
        return Ta(e, Tr()), null;
      var a = ky(e, t);
      if (e.tag !== Su && a === Qc) {
        var u = Xf(e);
        u !== Se && (t = u, a = fE(e, u));
      }
      if (a === Zp) {
        var f = tm;
        throw Xc(e, Se), Du(e, t), Ta(e, Tr()), f;
      }
      if (a === rE)
        throw new Error("Root did not complete. This is a bug in React.");
      var m = e.current.alternate;
      return e.finishedWork = m, e.finishedLanes = t, Zc(e, Ra, Ol), Ta(e, Tr()), null;
    }
    function mD(e, t) {
      t !== Se && (td(e, It(t, Ct)), Ta(e, Tr()), (en & (bi | Es)) === Jr && (im(), Eu()));
    }
    function dE(e, t) {
      var a = en;
      en |= EC;
      try {
        return e(t);
      } finally {
        en = a, en === Jr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Zs.isBatchingLegacy && (im(), R_());
      }
    }
    function vD(e, t, a, u, f) {
      var m = Ea(), y = yi.transition;
      try {
        return yi.transition = null, Sr(li), e(t, a, u, f);
      } finally {
        Sr(m), yi.transition = y, en === Jr && im();
      }
    }
    function Nl(e) {
      Nu !== null && Nu.tag === Su && (en & (bi | Es)) === Jr && Al();
      var t = en;
      en |= EC;
      var a = yi.transition, u = Ea();
      try {
        return yi.transition = null, Sr(li), e ? e() : void 0;
      } finally {
        Sr(u), yi.transition = a, en = t, (en & (bi | Es)) === Jr && Eu();
      }
    }
    function NC() {
      return (en & (bi | Es)) !== Jr;
    }
    function Ty(e, t) {
      Pi(iE, zo, e), zo = It(zo, t);
    }
    function hE(e) {
      zo = iE.current, Li(iE, e);
    }
    function Xc(e, t) {
      e.finishedWork = null, e.finishedLanes = Se;
      var a = e.timeoutHandle;
      if (a !== ub && (e.timeoutHandle = ub, Hk(a)), cr !== null)
        for (var u = cr.return; u !== null; ) {
          var f = u.alternate;
          aC(f, u), u = u.return;
        }
      ea = e;
      var m = ef(e.current, null);
      return cr = m, Qr = zo = t, Kr = kl, tm = null, Sy = Se, nm = Se, Ey = Se, rm = null, Ra = null, fN(), qs.discardPendingWarnings(), m;
    }
    function AC(e, t) {
      do {
        var a = cr;
        try {
          if (Ug(), tx(), In(), nE.current = null, a === null || a.return === null) {
            Kr = Zp, tm = t, cr = null;
            return;
          }
          if (dt && a.mode & fn && dy(a, !0), st)
            if (Ji(), t !== null && typeof t == "object" && typeof t.then == "function") {
              var u = t;
              cs(a, u, Qr);
            } else
              sc(a, t, Qr);
          zN(e, a.return, a, t, Qr), LC(a);
        } catch (f) {
          t = f, cr === a && a !== null ? (a = a.return, cr = a) : a = cr;
          continue;
        }
        return;
      } while (!0);
    }
    function DC() {
      var e = tE.current;
      return tE.current = oy, e === null ? oy : e;
    }
    function MC(e) {
      tE.current = e;
    }
    function gD() {
      aE = Tr();
    }
    function lm(e) {
      Sy = It(e, Sy);
    }
    function yD() {
      Kr === kl && (Kr = by);
    }
    function pE() {
      (Kr === kl || Kr === by || Kr === Qc) && (Kr = em), ea !== null && (gc(Sy) || gc(nm)) && Du(ea, Qr);
    }
    function bD(e) {
      Kr !== em && (Kr = Qc), rm === null ? rm = [e] : rm.push(e);
    }
    function SD() {
      return Kr === kl;
    }
    function ky(e, t) {
      var a = en;
      en |= bi;
      var u = DC();
      if (ea !== e || Qr !== t) {
        if (Ni) {
          var f = e.memoizedUpdaters;
          f.size > 0 && (um(e, Qr), f.clear()), Pv(e, t);
        }
        Ol = Zh(), Xc(e, t);
      }
      ol(t);
      do
        try {
          ED();
          break;
        } catch (m) {
          AC(e, m);
        }
      while (!0);
      if (Ug(), en = a, MC(u), cr !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Df(), ea = null, Qr = Se, Kr;
    }
    function ED() {
      for (; cr !== null; )
        jC(cr);
    }
    function wD(e, t) {
      var a = en;
      en |= bi;
      var u = DC();
      if (ea !== e || Qr !== t) {
        if (Ni) {
          var f = e.memoizedUpdaters;
          f.size > 0 && (um(e, Qr), f.clear()), Pv(e, t);
        }
        Ol = Zh(), im(), Xc(e, t);
      }
      ol(t);
      do
        try {
          _D();
          break;
        } catch (m) {
          AC(e, m);
        }
      while (!0);
      return Ug(), MC(u), en = a, cr !== null ? (Tv(), kl) : (Df(), ea = null, Qr = Se, Kr);
    }
    function _D() {
      for (; cr !== null && !Dh(); )
        jC(cr);
    }
    function jC(e) {
      var t = e.alternate;
      Rn(e);
      var a;
      (e.mode & fn) !== mt ? (gS(e), a = mE(t, e, zo), dy(e, !0)) : a = mE(t, e, zo), In(), e.memoizedProps = e.pendingProps, a === null ? LC(e) : cr = a, nE.current = null;
    }
    function LC(e) {
      var t = e;
      do {
        var a = t.alternate, u = t.return;
        if ((t.flags & rc) === pt) {
          Rn(t);
          var f = void 0;
          if ((t.mode & fn) === mt ? f = iC(a, t, zo) : (gS(t), f = iC(a, t, zo), dy(t, !1)), In(), f !== null) {
            cr = f;
            return;
          }
        } else {
          var m = yA(a, t);
          if (m !== null) {
            m.flags &= Ev, cr = m;
            return;
          }
          if ((t.mode & fn) !== mt) {
            dy(t, !1);
            for (var y = t.actualDuration, S = t.child; S !== null; )
              y += S.actualDuration, S = S.sibling;
            t.actualDuration = y;
          }
          if (u !== null)
            u.flags |= rc, u.subtreeFlags = pt, u.deletions = null;
          else {
            Kr = rE, cr = null;
            return;
          }
        }
        var w = t.sibling;
        if (w !== null) {
          cr = w;
          return;
        }
        t = u, cr = t;
      } while (t !== null);
      Kr === kl && (Kr = wC);
    }
    function Zc(e, t, a) {
      var u = Ea(), f = yi.transition;
      try {
        yi.transition = null, Sr(li), xD(e, t, a, u);
      } finally {
        yi.transition = f, Sr(u);
      }
      return null;
    }
    function xD(e, t, a, u) {
      do
        Al();
      while (Nu !== null);
      if (LD(), (en & (bi | Es)) !== Jr)
        throw new Error("Should not already be working.");
      var f = e.finishedWork, m = e.finishedLanes;
      if (Fh(m), f === null)
        return Ih(), null;
      if (m === Se && p("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = Se, f === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = ln;
      var y = It(f.lanes, f.childLanes);
      Kh(e, y), e === ea && (ea = null, cr = null, Qr = Se), ((f.subtreeFlags & Ls) !== pt || (f.flags & Ls) !== pt) && (Kc || (Kc = !0, lE = a, yE(Ps, function() {
        return Al(), null;
      })));
      var S = (f.subtreeFlags & (go | yo | bo | Ls)) !== pt, w = (f.flags & (go | yo | bo | Ls)) !== pt;
      if (S || w) {
        var k = yi.transition;
        yi.transition = null;
        var M = Ea();
        Sr(li);
        var q = en;
        en |= Es, nE.current = null, _A(e, f), Rx(), UA(e, f, m), Pk(e.containerInfo), e.current = f, oc(m), FA(f, e, m), lc(), Mh(), en = q, Sr(M), yi.transition = k;
      } else
        e.current = f, Rx();
      var H = Kc;
      if (Kc ? (Kc = !1, Nu = e, am = m) : (Hd = 0, xy = null), y = e.pendingLanes, y === Se && (Bd = null), H || IC(e.current, !1), Lh(f.stateNode, u), Ni && e.memoizedUpdaters.clear(), rD(), Ta(e, Tr()), t !== null)
        for (var ee = e.onRecoverableError, re = 0; re < t.length; re++) {
          var ce = t[re], Ie = ce.stack, yt = ce.digest;
          ee(ce.value, {
            componentStack: Ie,
            digest: yt
          });
        }
      if (wy) {
        wy = !1;
        var ut = sE;
        throw sE = null, ut;
      }
      return Ai(am, Ct) && e.tag !== Su && Al(), y = e.pendingLanes, Ai(y, Ct) ? (ON(), e === uE ? sm++ : (sm = 0, uE = e)) : sm = 0, Eu(), Ih(), null;
    }
    function Al() {
      if (Nu !== null) {
        var e = Iv(am), t = _c(ba, e), a = yi.transition, u = Ea();
        try {
          return yi.transition = null, Sr(t), RD();
        } finally {
          Sr(u), yi.transition = a;
        }
      }
      return !1;
    }
    function CD(e) {
      oE.push(e), Kc || (Kc = !0, yE(Ps, function() {
        return Al(), null;
      }));
    }
    function RD() {
      if (Nu === null)
        return !1;
      var e = lE;
      lE = null;
      var t = Nu, a = am;
      if (Nu = null, am = Se, (en & (bi | Es)) !== Jr)
        throw new Error("Cannot flush passive effects while already rendering.");
      cE = !0, _y = !1, sl(a);
      var u = en;
      en |= Es, qA(t.current), $A(t, t.current, a, e);
      {
        var f = oE;
        oE = [];
        for (var m = 0; m < f.length; m++) {
          var y = f[m];
          TA(t, y);
        }
      }
      Bh(), IC(t.current, !0), en = u, Eu(), _y ? t === xy ? Hd++ : (Hd = 0, xy = t) : Hd = 0, cE = !1, _y = !1, Ph(t);
      {
        var S = t.current.stateNode;
        S.effectDuration = 0, S.passiveEffectDuration = 0;
      }
      return !0;
    }
    function PC(e) {
      return Bd !== null && Bd.has(e);
    }
    function TD(e) {
      Bd === null ? Bd = /* @__PURE__ */ new Set([e]) : Bd.add(e);
    }
    function kD(e) {
      wy || (wy = !0, sE = e);
    }
    var OD = kD;
    function UC(e, t, a) {
      var u = Gc(a, t), f = jx(e, u, Ct), m = _u(e, f, Ct), y = ta();
      m !== null && (lu(m, Ct, y), Ta(m, y));
    }
    function zn(e, t, a) {
      if (SA(a), cm(!1), e.tag === O) {
        UC(e, e, a);
        return;
      }
      var u = null;
      for (u = t; u !== null; ) {
        if (u.tag === O) {
          UC(u, e, a);
          return;
        } else if (u.tag === x) {
          var f = u.type, m = u.stateNode;
          if (typeof f.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && !PC(m)) {
            var y = Gc(a, e), S = LS(u, y, Ct), w = _u(u, S, Ct), k = ta();
            w !== null && (lu(w, Ct, k), Ta(w, k));
            return;
          }
        }
        u = u.return;
      }
      p(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, a);
    }
    function ND(e, t, a) {
      var u = e.pingCache;
      u !== null && u.delete(t);
      var f = ta();
      ed(e, a), ID(e), ea === e && ml(Qr, a) && (Kr === em || Kr === by && pl(Qr) && Tr() - aE < _C ? Xc(e, Se) : Ey = It(Ey, a)), Ta(e, f);
    }
    function FC(e, t) {
      t === ln && (t = cD(e));
      var a = ta(), u = xa(e, t);
      u !== null && (lu(u, t, a), Ta(u, a));
    }
    function AD(e) {
      var t = e.memoizedState, a = ln;
      t !== null && (a = t.retryLane), FC(e, a);
    }
    function DD(e, t) {
      var a = ln, u;
      switch (e.tag) {
        case Re:
          u = e.stateNode;
          var f = e.memoizedState;
          f !== null && (a = f.retryLane);
          break;
        case it:
          u = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      u !== null && u.delete(t), FC(e, a);
    }
    function MD(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : sD(e / 1960) * 1960;
    }
    function jD() {
      if (sm > lD)
        throw sm = 0, uE = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Hd > uD && (Hd = 0, xy = null, p("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function LD() {
      qs.flushLegacyContextWarning(), qs.flushPendingUnsafeLifecycleWarnings();
    }
    function IC(e, t) {
      Rn(e), Oy(e, vo, eD), t && Oy(e, os, tD), Oy(e, vo, XA), t && Oy(e, os, ZA), In();
    }
    function Oy(e, t, a) {
      for (var u = e, f = null; u !== null; ) {
        var m = u.subtreeFlags & t;
        u !== f && u.child !== null && m !== pt ? u = u.child : ((u.flags & t) !== pt && a(u), u.sibling !== null ? u = u.sibling : u = f = u.return);
      }
    }
    var Ny = null;
    function zC(e) {
      {
        if ((en & bi) !== Jr || !(e.mode & qt))
          return;
        var t = e.tag;
        if (t !== N && t !== O && t !== x && t !== _ && t !== ve && t !== lt && t !== Ve)
          return;
        var a = Nt(e) || "ReactComponent";
        if (Ny !== null) {
          if (Ny.has(a))
            return;
          Ny.add(a);
        } else
          Ny = /* @__PURE__ */ new Set([a]);
        var u = zr;
        try {
          Rn(e), p("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          u ? Rn(e) : In();
        }
      }
    }
    var mE;
    {
      var PD = null;
      mE = function(e, t, a) {
        var u = GC(PD, t);
        try {
          return Zx(e, t, a);
        } catch (m) {
          if (GO() || m !== null && typeof m == "object" && typeof m.then == "function")
            throw m;
          if (Ug(), tx(), aC(e, t), GC(t, u), t.mode & fn && gS(t), mo(null, Zx, null, e, t, a), Ms()) {
            var f = nc();
            typeof f == "object" && f !== null && f._suppressLogging && typeof m == "object" && m !== null && !m._suppressLogging && (m._suppressLogging = !0);
          }
          throw m;
        }
      };
    }
    var $C = !1, vE;
    vE = /* @__PURE__ */ new Set();
    function UD(e) {
      if (es && !RN())
        switch (e.tag) {
          case _:
          case ve:
          case Ve: {
            var t = cr && Nt(cr) || "Unknown", a = t;
            if (!vE.has(a)) {
              vE.add(a);
              var u = Nt(e) || "Unknown";
              p("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", u, t, t);
            }
            break;
          }
          case x: {
            $C || (p("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), $C = !0);
            break;
          }
        }
    }
    function um(e, t) {
      if (Ni) {
        var a = e.memoizedUpdaters;
        a.forEach(function(u) {
          Ec(e, u, t);
        });
      }
    }
    var gE = {};
    function yE(e, t) {
      {
        var a = Zs.current;
        return a !== null ? (a.push(t), gE) : Ah(e, t);
      }
    }
    function BC(e) {
      if (e !== gE)
        return _v(e);
    }
    function HC() {
      return Zs.current !== null;
    }
    function FD(e) {
      {
        if (e.mode & qt) {
          if (!SC())
            return;
        } else if (!aD() || en !== Jr || e.tag !== _ && e.tag !== ve && e.tag !== Ve)
          return;
        if (Zs.current === null) {
          var t = zr;
          try {
            Rn(e), p(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Nt(e));
          } finally {
            t ? Rn(e) : In();
          }
        }
      }
    }
    function ID(e) {
      e.tag !== Su && SC() && Zs.current === null && p(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function cm(e) {
      RC = e;
    }
    var ws = null, Vd = null, zD = function(e) {
      ws = e;
    };
    function qd(e) {
      {
        if (ws === null)
          return e;
        var t = ws(e);
        return t === void 0 ? e : t.current;
      }
    }
    function bE(e) {
      return qd(e);
    }
    function SE(e) {
      {
        if (ws === null)
          return e;
        var t = ws(e);
        if (t === void 0) {
          if (e != null && typeof e.render == "function") {
            var a = qd(e.render);
            if (e.render !== a) {
              var u = {
                $$typeof: ye,
                render: a
              };
              return e.displayName !== void 0 && (u.displayName = e.displayName), u;
            }
          }
          return e;
        }
        return t.current;
      }
    }
    function VC(e, t) {
      {
        if (ws === null)
          return !1;
        var a = e.elementType, u = t.type, f = !1, m = typeof u == "object" && u !== null ? u.$$typeof : null;
        switch (e.tag) {
          case x: {
            typeof u == "function" && (f = !0);
            break;
          }
          case _: {
            (typeof u == "function" || m === _t) && (f = !0);
            break;
          }
          case ve: {
            (m === ye || m === _t) && (f = !0);
            break;
          }
          case lt:
          case Ve: {
            (m === Et || m === _t) && (f = !0);
            break;
          }
          default:
            return !1;
        }
        if (f) {
          var y = ws(a);
          if (y !== void 0 && y === ws(u))
            return !0;
        }
        return !1;
      }
    }
    function qC(e) {
      {
        if (ws === null || typeof WeakSet != "function")
          return;
        Vd === null && (Vd = /* @__PURE__ */ new WeakSet()), Vd.add(e);
      }
    }
    var $D = function(e, t) {
      {
        if (ws === null)
          return;
        var a = t.staleFamilies, u = t.updatedFamilies;
        Al(), Nl(function() {
          EE(e.current, u, a);
        });
      }
    }, BD = function(e, t) {
      {
        if (e.context !== Va)
          return;
        Al(), Nl(function() {
          fm(t, e, null, null);
        });
      }
    };
    function EE(e, t, a) {
      {
        var u = e.alternate, f = e.child, m = e.sibling, y = e.tag, S = e.type, w = null;
        switch (y) {
          case _:
          case Ve:
          case x:
            w = S;
            break;
          case ve:
            w = S.render;
            break;
        }
        if (ws === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var k = !1, M = !1;
        if (w !== null) {
          var q = ws(w);
          q !== void 0 && (a.has(q) ? M = !0 : t.has(q) && (y === x ? M = !0 : k = !0));
        }
        if (Vd !== null && (Vd.has(e) || u !== null && Vd.has(u)) && (M = !0), M && (e._debugNeedsRemount = !0), M || k) {
          var H = xa(e, Ct);
          H !== null && Xr(H, e, Ct, Mn);
        }
        f !== null && !M && EE(f, t, a), m !== null && EE(m, t, a);
      }
    }
    var HD = function(e, t) {
      {
        var a = /* @__PURE__ */ new Set(), u = new Set(t.map(function(f) {
          return f.current;
        }));
        return wE(e.current, u, a), a;
      }
    };
    function wE(e, t, a) {
      {
        var u = e.child, f = e.sibling, m = e.tag, y = e.type, S = null;
        switch (m) {
          case _:
          case Ve:
          case x:
            S = y;
            break;
          case ve:
            S = y.render;
            break;
        }
        var w = !1;
        S !== null && t.has(S) && (w = !0), w ? VD(e, a) : u !== null && wE(u, t, a), f !== null && wE(f, t, a);
      }
    }
    function VD(e, t) {
      {
        var a = qD(e, t);
        if (a)
          return;
        for (var u = e; ; ) {
          switch (u.tag) {
            case z:
              t.add(u.stateNode);
              return;
            case P:
              t.add(u.stateNode.containerInfo);
              return;
            case O:
              t.add(u.stateNode.containerInfo);
              return;
          }
          if (u.return === null)
            throw new Error("Expected to reach root first.");
          u = u.return;
        }
      }
    }
    function qD(e, t) {
      for (var a = e, u = !1; ; ) {
        if (a.tag === z)
          u = !0, t.add(a.stateNode);
        else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === e)
          return u;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === e)
            return u;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return !1;
    }
    var _E;
    {
      _E = !1;
      try {
        var YC = Object.preventExtensions({});
      } catch {
        _E = !0;
      }
    }
    function YD(e, t, a, u) {
      this.tag = e, this.key = a, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = t, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = u, this.flags = pt, this.subtreeFlags = pt, this.deletions = null, this.lanes = Se, this.childLanes = Se, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !_E && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var qa = function(e, t, a, u) {
      return new YD(e, t, a, u);
    };
    function xE(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function WD(e) {
      return typeof e == "function" && !xE(e) && e.defaultProps === void 0;
    }
    function GD(e) {
      if (typeof e == "function")
        return xE(e) ? x : _;
      if (e != null) {
        var t = e.$$typeof;
        if (t === ye)
          return ve;
        if (t === Et)
          return lt;
      }
      return N;
    }
    function ef(e, t) {
      var a = e.alternate;
      a === null ? (a = qa(e.tag, t, e.key, e.mode), a.elementType = e.elementType, a.type = e.type, a.stateNode = e.stateNode, a._debugSource = e._debugSource, a._debugOwner = e._debugOwner, a._debugHookTypes = e._debugHookTypes, a.alternate = e, e.alternate = a) : (a.pendingProps = t, a.type = e.type, a.flags = pt, a.subtreeFlags = pt, a.deletions = null, a.actualDuration = 0, a.actualStartTime = -1), a.flags = e.flags & gr, a.childLanes = e.childLanes, a.lanes = e.lanes, a.child = e.child, a.memoizedProps = e.memoizedProps, a.memoizedState = e.memoizedState, a.updateQueue = e.updateQueue;
      var u = e.dependencies;
      switch (a.dependencies = u === null ? null : {
        lanes: u.lanes,
        firstContext: u.firstContext
      }, a.sibling = e.sibling, a.index = e.index, a.ref = e.ref, a.selfBaseDuration = e.selfBaseDuration, a.treeBaseDuration = e.treeBaseDuration, a._debugNeedsRemount = e._debugNeedsRemount, a.tag) {
        case N:
        case _:
        case Ve:
          a.type = qd(e.type);
          break;
        case x:
          a.type = bE(e.type);
          break;
        case ve:
          a.type = SE(e.type);
          break;
      }
      return a;
    }
    function JD(e, t) {
      e.flags &= gr | ir;
      var a = e.alternate;
      if (a === null)
        e.childLanes = Se, e.lanes = t, e.child = null, e.subtreeFlags = pt, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = a.childLanes, e.lanes = a.lanes, e.child = a.child, e.subtreeFlags = pt, e.deletions = null, e.memoizedProps = a.memoizedProps, e.memoizedState = a.memoizedState, e.updateQueue = a.updateQueue, e.type = a.type;
        var u = a.dependencies;
        e.dependencies = u === null ? null : {
          lanes: u.lanes,
          firstContext: u.firstContext
        }, e.selfBaseDuration = a.selfBaseDuration, e.treeBaseDuration = a.treeBaseDuration;
      }
      return e;
    }
    function QD(e, t, a) {
      var u;
      return e === Tg ? (u = qt, t === !0 && (u |= On, u |= dn)) : u = mt, Ni && (u |= fn), qa(O, null, null, u);
    }
    function CE(e, t, a, u, f, m) {
      var y = N, S = e;
      if (typeof e == "function")
        xE(e) ? (y = x, S = bE(S)) : S = qd(S);
      else if (typeof e == "string")
        y = z;
      else
        e: switch (e) {
          case ei:
            return Mu(a.children, f, m, t);
          case Ir:
            y = K, f |= On, (f & qt) !== mt && (f |= dn);
            break;
          case _i:
            return KD(a, f, m, t);
          case Ne:
            return XD(a, f, m, t);
          case Ue:
            return ZD(a, f, m, t);
          case Yn:
            return WC(a, f, m, t);
          case Vt:
          // eslint-disable-next-line no-fallthrough
          case Ut:
          // eslint-disable-next-line no-fallthrough
          case Cn:
          // eslint-disable-next-line no-fallthrough
          case T:
          // eslint-disable-next-line no-fallthrough
          case Ft:
          // eslint-disable-next-line no-fallthrough
          default: {
            if (typeof e == "object" && e !== null)
              switch (e.$$typeof) {
                case Vi:
                  y = ae;
                  break e;
                case I:
                  y = be;
                  break e;
                case ye:
                  y = ve, S = SE(S);
                  break e;
                case Et:
                  y = lt;
                  break e;
                case _t:
                  y = wt, S = null;
                  break e;
              }
            var w = "";
            {
              (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (w += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var k = u ? Nt(u) : null;
              k && (w += `

Check the render method of \`` + k + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + w));
          }
        }
      var M = qa(y, a, t, f);
      return M.elementType = e, M.type = S, M.lanes = m, M._debugOwner = u, M;
    }
    function RE(e, t, a) {
      var u = null;
      u = e._owner;
      var f = e.type, m = e.key, y = e.props, S = CE(f, m, y, u, t, a);
      return S._debugSource = e._source, S._debugOwner = e._owner, S;
    }
    function Mu(e, t, a, u) {
      var f = qa(ie, e, u, t);
      return f.lanes = a, f;
    }
    function KD(e, t, a, u) {
      typeof e.id != "string" && p('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var f = qa(De, e, u, t | fn);
      return f.elementType = _i, f.lanes = a, f.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, f;
    }
    function XD(e, t, a, u) {
      var f = qa(Re, e, u, t);
      return f.elementType = Ne, f.lanes = a, f;
    }
    function ZD(e, t, a, u) {
      var f = qa(it, e, u, t);
      return f.elementType = Ue, f.lanes = a, f;
    }
    function WC(e, t, a, u) {
      var f = qa(Ke, e, u, t);
      f.elementType = Yn, f.lanes = a;
      var m = {
        isHidden: !1
      };
      return f.stateNode = m, f;
    }
    function TE(e, t, a) {
      var u = qa(B, e, null, t);
      return u.lanes = a, u;
    }
    function eM() {
      var e = qa(z, null, null, mt);
      return e.elementType = "DELETED", e;
    }
    function tM(e) {
      var t = qa(zt, null, null, mt);
      return t.stateNode = e, t;
    }
    function kE(e, t, a) {
      var u = e.children !== null ? e.children : [], f = qa(P, u, e.key, t);
      return f.lanes = a, f.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, f;
    }
    function GC(e, t) {
      return e === null && (e = qa(N, null, null, mt)), e.tag = t.tag, e.key = t.key, e.elementType = t.elementType, e.type = t.type, e.stateNode = t.stateNode, e.return = t.return, e.child = t.child, e.sibling = t.sibling, e.index = t.index, e.ref = t.ref, e.pendingProps = t.pendingProps, e.memoizedProps = t.memoizedProps, e.updateQueue = t.updateQueue, e.memoizedState = t.memoizedState, e.dependencies = t.dependencies, e.mode = t.mode, e.flags = t.flags, e.subtreeFlags = t.subtreeFlags, e.deletions = t.deletions, e.lanes = t.lanes, e.childLanes = t.childLanes, e.alternate = t.alternate, e.actualDuration = t.actualDuration, e.actualStartTime = t.actualStartTime, e.selfBaseDuration = t.selfBaseDuration, e.treeBaseDuration = t.treeBaseDuration, e._debugSource = t._debugSource, e._debugOwner = t._debugOwner, e._debugNeedsRemount = t._debugNeedsRemount, e._debugHookTypes = t._debugHookTypes, e;
    }
    function nM(e, t, a, u, f) {
      this.tag = t, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = ub, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = ln, this.eventTimes = Sc(Se), this.expirationTimes = Sc(Mn), this.pendingLanes = Se, this.suspendedLanes = Se, this.pingedLanes = Se, this.expiredLanes = Se, this.mutableReadLanes = Se, this.finishedLanes = Se, this.entangledLanes = Se, this.entanglements = Sc(Se), this.identifierPrefix = u, this.onRecoverableError = f, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var m = this.pendingUpdatersLaneMap = [], y = 0; y < ll; y++)
          m.push(/* @__PURE__ */ new Set());
      }
      switch (t) {
        case Tg:
          this._debugRootType = a ? "hydrateRoot()" : "createRoot()";
          break;
        case Su:
          this._debugRootType = a ? "hydrate()" : "render()";
          break;
      }
    }
    function JC(e, t, a, u, f, m, y, S, w, k) {
      var M = new nM(e, t, a, S, w), q = QD(t, m);
      M.current = q, q.stateNode = M;
      {
        var H = {
          element: u,
          isDehydrated: a,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        q.memoizedState = H;
      }
      return $b(q), M;
    }
    var OE = "18.3.1";
    function rM(e, t, a) {
      var u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return xr(u), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: er,
        key: u == null ? null : "" + u,
        children: e,
        containerInfo: t,
        implementation: a
      };
    }
    var NE, AE;
    NE = !1, AE = {};
    function QC(e) {
      if (!e)
        return Va;
      var t = nu(e), a = IO(t);
      if (t.tag === x) {
        var u = t.type;
        if (Mo(u))
          return __(t, u, a);
      }
      return a;
    }
    function iM(e, t) {
      {
        var a = nu(e);
        if (a === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var u = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + u);
        }
        var f = ki(a);
        if (f === null)
          return null;
        if (f.mode & On) {
          var m = Nt(a) || "Component";
          if (!AE[m]) {
            AE[m] = !0;
            var y = zr;
            try {
              Rn(f), a.mode & On ? p("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t, t, m) : p("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", t, t, m);
            } finally {
              y ? Rn(y) : In();
            }
          }
        }
        return f.stateNode;
      }
    }
    function KC(e, t, a, u, f, m, y, S) {
      var w = !1, k = null;
      return JC(e, t, w, k, a, u, f, m, y);
    }
    function XC(e, t, a, u, f, m, y, S, w, k) {
      var M = !0, q = JC(a, u, M, e, f, m, y, S, w);
      q.context = QC(null);
      var H = q.current, ee = ta(), re = Au(H), ce = Rl(ee, re);
      return ce.callback = t ?? null, _u(H, ce, re), fD(q, re, ee), q;
    }
    function fm(e, t, a, u) {
      jh(t, e);
      var f = t.current, m = ta(), y = Au(f);
      Jn(y);
      var S = QC(a);
      t.context === null ? t.context = S : t.pendingContext = S, es && zr !== null && !NE && (NE = !0, p(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Nt(zr) || "Unknown"));
      var w = Rl(m, y);
      w.payload = {
        element: e
      }, u = u === void 0 ? null : u, u !== null && (typeof u != "function" && p("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", u), w.callback = u);
      var k = _u(f, w, y);
      return k !== null && (Xr(k, f, y, m), Bg(k, f, y)), y;
    }
    function Ay(e) {
      var t = e.current;
      if (!t.child)
        return null;
      switch (t.child.tag) {
        case z:
          return t.child.stateNode;
        default:
          return t.child.stateNode;
      }
    }
    function aM(e) {
      switch (e.tag) {
        case O: {
          var t = e.stateNode;
          if (nd(t)) {
            var a = Ov(t);
            mD(t, a);
          }
          break;
        }
        case Re: {
          Nl(function() {
            var f = xa(e, Ct);
            if (f !== null) {
              var m = ta();
              Xr(f, e, Ct, m);
            }
          });
          var u = Ct;
          DE(e, u);
          break;
        }
      }
    }
    function ZC(e, t) {
      var a = e.memoizedState;
      a !== null && a.dehydrated !== null && (a.retryLane = jv(a.retryLane, t));
    }
    function DE(e, t) {
      ZC(e, t);
      var a = e.alternate;
      a && ZC(a, t);
    }
    function sM(e) {
      if (e.tag === Re) {
        var t = pc, a = xa(e, t);
        if (a !== null) {
          var u = ta();
          Xr(a, e, t, u);
        }
        DE(e, t);
      }
    }
    function oM(e) {
      if (e.tag === Re) {
        var t = Au(e), a = xa(e, t);
        if (a !== null) {
          var u = ta();
          Xr(a, e, t, u);
        }
        DE(e, t);
      }
    }
    function eR(e) {
      var t = Hn(e);
      return t === null ? null : t.stateNode;
    }
    var tR = function(e) {
      return null;
    };
    function lM(e) {
      return tR(e);
    }
    var nR = function(e) {
      return !1;
    };
    function uM(e) {
      return nR(e);
    }
    var rR = null, iR = null, aR = null, sR = null, oR = null, lR = null, uR = null, cR = null, fR = null;
    {
      var dR = function(e, t, a) {
        var u = t[a], f = $t(e) ? e.slice() : U({}, e);
        return a + 1 === t.length ? ($t(f) ? f.splice(u, 1) : delete f[u], f) : (f[u] = dR(e[u], t, a + 1), f);
      }, hR = function(e, t) {
        return dR(e, t, 0);
      }, pR = function(e, t, a, u) {
        var f = t[u], m = $t(e) ? e.slice() : U({}, e);
        if (u + 1 === t.length) {
          var y = a[u];
          m[y] = m[f], $t(m) ? m.splice(f, 1) : delete m[f];
        } else
          m[f] = pR(
            // $FlowFixMe number or string is fine here
            e[f],
            t,
            a,
            u + 1
          );
        return m;
      }, mR = function(e, t, a) {
        if (t.length !== a.length) {
          v("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var u = 0; u < a.length - 1; u++)
            if (t[u] !== a[u]) {
              v("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return pR(e, t, a, 0);
      }, vR = function(e, t, a, u) {
        if (a >= t.length)
          return u;
        var f = t[a], m = $t(e) ? e.slice() : U({}, e);
        return m[f] = vR(e[f], t, a + 1, u), m;
      }, gR = function(e, t, a) {
        return vR(e, t, 0, a);
      }, ME = function(e, t) {
        for (var a = e.memoizedState; a !== null && t > 0; )
          a = a.next, t--;
        return a;
      };
      rR = function(e, t, a, u) {
        var f = ME(e, t);
        if (f !== null) {
          var m = gR(f.memoizedState, a, u);
          f.memoizedState = m, f.baseState = m, e.memoizedProps = U({}, e.memoizedProps);
          var y = xa(e, Ct);
          y !== null && Xr(y, e, Ct, Mn);
        }
      }, iR = function(e, t, a) {
        var u = ME(e, t);
        if (u !== null) {
          var f = hR(u.memoizedState, a);
          u.memoizedState = f, u.baseState = f, e.memoizedProps = U({}, e.memoizedProps);
          var m = xa(e, Ct);
          m !== null && Xr(m, e, Ct, Mn);
        }
      }, aR = function(e, t, a, u) {
        var f = ME(e, t);
        if (f !== null) {
          var m = mR(f.memoizedState, a, u);
          f.memoizedState = m, f.baseState = m, e.memoizedProps = U({}, e.memoizedProps);
          var y = xa(e, Ct);
          y !== null && Xr(y, e, Ct, Mn);
        }
      }, sR = function(e, t, a) {
        e.pendingProps = gR(e.memoizedProps, t, a), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var u = xa(e, Ct);
        u !== null && Xr(u, e, Ct, Mn);
      }, oR = function(e, t) {
        e.pendingProps = hR(e.memoizedProps, t), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var a = xa(e, Ct);
        a !== null && Xr(a, e, Ct, Mn);
      }, lR = function(e, t, a) {
        e.pendingProps = mR(e.memoizedProps, t, a), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var u = xa(e, Ct);
        u !== null && Xr(u, e, Ct, Mn);
      }, uR = function(e) {
        var t = xa(e, Ct);
        t !== null && Xr(t, e, Ct, Mn);
      }, cR = function(e) {
        tR = e;
      }, fR = function(e) {
        nR = e;
      };
    }
    function cM(e) {
      var t = ki(e);
      return t === null ? null : t.stateNode;
    }
    function fM(e) {
      return null;
    }
    function dM() {
      return zr;
    }
    function hM(e) {
      var t = e.findFiberByHostInstance, a = s.ReactCurrentDispatcher;
      return au({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: rR,
        overrideHookStateDeletePath: iR,
        overrideHookStateRenamePath: aR,
        overrideProps: sR,
        overridePropsDeletePath: oR,
        overridePropsRenamePath: lR,
        setErrorHandler: cR,
        setSuspenseHandler: fR,
        scheduleUpdate: uR,
        currentDispatcherRef: a,
        findHostInstanceByFiber: cM,
        findFiberByHostInstance: t || fM,
        // React Refresh
        findHostInstancesForRefresh: HD,
        scheduleRefresh: $D,
        scheduleRoot: BD,
        setRefreshHandler: zD,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: dM,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: OE
      });
    }
    var yR = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function jE(e) {
      this._internalRoot = e;
    }
    Dy.prototype.render = jE.prototype.render = function(e) {
      var t = this._internalRoot;
      if (t === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? p("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : My(arguments[1]) ? p("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && p("You passed a second argument to root.render(...) but it only accepts one argument.");
        var a = t.containerInfo;
        if (a.nodeType !== mr) {
          var u = eR(t.current);
          u && u.parentNode !== a && p("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      fm(e, t, null, null);
    }, Dy.prototype.unmount = jE.prototype.unmount = function() {
      typeof arguments[0] == "function" && p("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        NC() && p("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Nl(function() {
          fm(null, e, null, null);
        }), y_(t);
      }
    };
    function pM(e, t) {
      if (!My(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      bR(e);
      var a = !1, u = !1, f = "", m = yR;
      t != null && (t.hydrate ? v("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof t == "object" && t !== null && t.$$typeof === rr && p(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), t.unstable_strictMode === !0 && (a = !0), t.identifierPrefix !== void 0 && (f = t.identifierPrefix), t.onRecoverableError !== void 0 && (m = t.onRecoverableError), t.transitionCallbacks !== void 0 && t.transitionCallbacks);
      var y = KC(e, Tg, null, a, u, f, m);
      Sg(y.current, e);
      var S = e.nodeType === mr ? e.parentNode : e;
      return gp(S), new jE(y);
    }
    function Dy(e) {
      this._internalRoot = e;
    }
    function mM(e) {
      e && Vv(e);
    }
    Dy.prototype.unstable_scheduleHydration = mM;
    function vM(e, t, a) {
      if (!My(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      bR(e), t === void 0 && p("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var u = a ?? null, f = a != null && a.hydratedSources || null, m = !1, y = !1, S = "", w = yR;
      a != null && (a.unstable_strictMode === !0 && (m = !0), a.identifierPrefix !== void 0 && (S = a.identifierPrefix), a.onRecoverableError !== void 0 && (w = a.onRecoverableError));
      var k = XC(t, null, e, Tg, u, m, y, S, w);
      if (Sg(k.current, e), gp(e), f)
        for (var M = 0; M < f.length; M++) {
          var q = f[M];
          SN(k, q);
        }
      return new Dy(k);
    }
    function My(e) {
      return !!(e && (e.nodeType === xi || e.nodeType === Ds || e.nodeType === bh));
    }
    function dm(e) {
      return !!(e && (e.nodeType === xi || e.nodeType === Ds || e.nodeType === bh || e.nodeType === mr && e.nodeValue === " react-mount-point-unstable "));
    }
    function bR(e) {
      e.nodeType === xi && e.tagName && e.tagName.toUpperCase() === "BODY" && p("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), kp(e) && (e._reactRootContainer ? p("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : p("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var gM = s.ReactCurrentOwner, SR;
    SR = function(e) {
      if (e._reactRootContainer && e.nodeType !== mr) {
        var t = eR(e._reactRootContainer.current);
        t && t.parentNode !== e && p("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var a = !!e._reactRootContainer, u = LE(e), f = !!(u && yu(u));
      f && !a && p("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === xi && e.tagName && e.tagName.toUpperCase() === "BODY" && p("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function LE(e) {
      return e ? e.nodeType === Ds ? e.documentElement : e.firstChild : null;
    }
    function ER() {
    }
    function yM(e, t, a, u, f) {
      if (f) {
        if (typeof u == "function") {
          var m = u;
          u = function() {
            var H = Ay(y);
            m.call(H);
          };
        }
        var y = XC(
          t,
          u,
          e,
          Su,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          ER
        );
        e._reactRootContainer = y, Sg(y.current, e);
        var S = e.nodeType === mr ? e.parentNode : e;
        return gp(S), Nl(), y;
      } else {
        for (var w; w = e.lastChild; )
          e.removeChild(w);
        if (typeof u == "function") {
          var k = u;
          u = function() {
            var H = Ay(M);
            k.call(H);
          };
        }
        var M = KC(
          e,
          Su,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          ER
        );
        e._reactRootContainer = M, Sg(M.current, e);
        var q = e.nodeType === mr ? e.parentNode : e;
        return gp(q), Nl(function() {
          fm(t, M, a, u);
        }), M;
      }
    }
    function bM(e, t) {
      e !== null && typeof e != "function" && p("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", t, e);
    }
    function jy(e, t, a, u, f) {
      SR(a), bM(f === void 0 ? null : f, "render");
      var m = a._reactRootContainer, y;
      if (!m)
        y = yM(a, t, e, f, u);
      else {
        if (y = m, typeof f == "function") {
          var S = f;
          f = function() {
            var w = Ay(y);
            S.call(w);
          };
        }
        fm(t, y, e, f);
      }
      return Ay(y);
    }
    var wR = !1;
    function SM(e) {
      {
        wR || (wR = !0, p("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var t = gM.current;
        if (t !== null && t.stateNode !== null) {
          var a = t.stateNode._warnedAboutRefsInRender;
          a || p("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", rn(t.type) || "A component"), t.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === xi ? e : iM(e, "findDOMNode");
    }
    function EM(e, t, a) {
      if (p("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !dm(t))
        throw new Error("Target container is not a DOM element.");
      {
        var u = kp(t) && t._reactRootContainer === void 0;
        u && p("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return jy(null, e, t, !0, a);
    }
    function wM(e, t, a) {
      if (p("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !dm(t))
        throw new Error("Target container is not a DOM element.");
      {
        var u = kp(t) && t._reactRootContainer === void 0;
        u && p("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return jy(null, e, t, !1, a);
    }
    function _M(e, t, a, u) {
      if (p("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !dm(a))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !A0(e))
        throw new Error("parentComponent must be a valid React Component");
      return jy(e, t, a, !1, u);
    }
    var _R = !1;
    function xM(e) {
      if (_R || (_R = !0, p("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !dm(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var t = kp(e) && e._reactRootContainer === void 0;
        t && p("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var a = LE(e), u = a && !yu(a);
          u && p("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Nl(function() {
          jy(null, null, e, !1, function() {
            e._reactRootContainer = null, y_(e);
          });
        }), !0;
      } else {
        {
          var f = LE(e), m = !!(f && yu(f)), y = e.nodeType === xi && dm(e.parentNode) && !!e.parentNode._reactRootContainer;
          m && p("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", y ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    ni(aM), uu(sM), zv(oM), Cc(Ea), ep(Uv), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && p("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), bf(Rk), N0(dE, vD, Nl);
    function CM(e, t) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!My(t))
        throw new Error("Target container is not a DOM element.");
      return rM(e, t, null, a);
    }
    function RM(e, t, a, u) {
      return _M(e, t, a, u);
    }
    var PE = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [yu, wd, Eg, Xl, Sf, dE]
    };
    function TM(e, t) {
      return PE.usingClientEntryPoint || p('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), pM(e, t);
    }
    function kM(e, t, a) {
      return PE.usingClientEntryPoint || p('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), vM(e, t, a);
    }
    function OM(e) {
      return NC() && p("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Nl(e);
    }
    var NM = hM({
      findFiberByHostInstance: Ic,
      bundleType: 1,
      version: OE,
      rendererPackageName: "react-dom"
    });
    if (!NM && Un && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var xR = window.location.protocol;
      /^(https?|file):$/.test(xR) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (xR === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Oa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = PE, Oa.createPortal = CM, Oa.createRoot = TM, Oa.findDOMNode = SM, Oa.flushSync = OM, Oa.hydrate = EM, Oa.hydrateRoot = kM, Oa.render = wM, Oa.unmountComponentAtNode = xM, Oa.unstable_batchedUpdates = dE, Oa.unstable_renderSubtreeIntoContainer = RM, Oa.version = OE, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Oa;
}
var PR;
function I1() {
  if (PR) return Uy.exports;
  PR = 1;
  function o() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(o);
      } catch (n) {
        console.error(n);
      }
    }
  }
  return process.env.NODE_ENV === "production" ? (o(), Uy.exports = $M()) : Uy.exports = BM(), Uy.exports;
}
var UR;
function HM() {
  if (UR) return Wd;
  UR = 1;
  var o = I1();
  if (process.env.NODE_ENV === "production")
    Wd.createRoot = o.createRoot, Wd.hydrateRoot = o.hydrateRoot;
  else {
    var n = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    Wd.createRoot = function(s, l) {
      n.usingClientEntryPoint = !0;
      try {
        return o.createRoot(s, l);
      } finally {
        n.usingClientEntryPoint = !1;
      }
    }, Wd.hydrateRoot = function(s, l, d) {
      n.usingClientEntryPoint = !0;
      try {
        return o.hydrateRoot(s, l, d);
      } finally {
        n.usingClientEntryPoint = !1;
      }
    };
  }
  return Wd;
}
var VM = HM();
const qM = /* @__PURE__ */ U1(VM);
var se = Um();
const YM = /* @__PURE__ */ U1(se), WM = /* @__PURE__ */ MM({
  __proto__: null,
  default: YM
}, [se]);
I1();
/**
 * @remix-run/router v1.21.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function km() {
  return km = Object.assign ? Object.assign.bind() : function(o) {
    for (var n = 1; n < arguments.length; n++) {
      var s = arguments[n];
      for (var l in s)
        Object.prototype.hasOwnProperty.call(s, l) && (o[l] = s[l]);
    }
    return o;
  }, km.apply(this, arguments);
}
var ju;
(function(o) {
  o.Pop = "POP", o.Push = "PUSH", o.Replace = "REPLACE";
})(ju || (ju = {}));
const FR = "popstate";
function GM(o) {
  o === void 0 && (o = {});
  function n(l, d) {
    let {
      pathname: v,
      search: p,
      hash: E
    } = l.location;
    return nw(
      "",
      {
        pathname: v,
        search: p,
        hash: E
      },
      // state defaults to `null` because `window.history.state` does
      d.state && d.state.usr || null,
      d.state && d.state.key || "default"
    );
  }
  function s(l, d) {
    return typeof d == "string" ? d : Om(d);
  }
  return QM(n, s, null, o);
}
function Wt(o, n) {
  if (o === !1 || o === null || typeof o > "u")
    throw new Error(n);
}
function ro(o, n) {
  if (!o) {
    typeof console < "u" && console.warn(n);
    try {
      throw new Error(n);
    } catch {
    }
  }
}
function JM() {
  return Math.random().toString(36).substr(2, 8);
}
function IR(o, n) {
  return {
    usr: o.state,
    key: o.key,
    idx: n
  };
}
function nw(o, n, s, l) {
  return s === void 0 && (s = null), km({
    pathname: typeof o == "string" ? o : o.pathname,
    search: "",
    hash: ""
  }, typeof n == "string" ? ih(n) : n, {
    state: s,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: n && n.key || l || JM()
  });
}
function Om(o) {
  let {
    pathname: n = "/",
    search: s = "",
    hash: l = ""
  } = o;
  return s && s !== "?" && (n += s.charAt(0) === "?" ? s : "?" + s), l && l !== "#" && (n += l.charAt(0) === "#" ? l : "#" + l), n;
}
function ih(o) {
  let n = {};
  if (o) {
    let s = o.indexOf("#");
    s >= 0 && (n.hash = o.substr(s), o = o.substr(0, s));
    let l = o.indexOf("?");
    l >= 0 && (n.search = o.substr(l), o = o.substr(0, l)), o && (n.pathname = o);
  }
  return n;
}
function QM(o, n, s, l) {
  l === void 0 && (l = {});
  let {
    window: d = document.defaultView,
    v5Compat: v = !1
  } = l, p = d.history, E = ju.Pop, _ = null, x = N();
  x == null && (x = 0, p.replaceState(km({}, p.state, {
    idx: x
  }), ""));
  function N() {
    return (p.state || {
      idx: null
    }).idx;
  }
  function O() {
    E = ju.Pop;
    let K = N(), be = K == null ? null : K - x;
    x = K, _ && _({
      action: E,
      location: ie.location,
      delta: be
    });
  }
  function P(K, be) {
    E = ju.Push;
    let ae = nw(ie.location, K, be);
    x = N() + 1;
    let ve = IR(ae, x), De = ie.createHref(ae);
    try {
      p.pushState(ve, "", De);
    } catch (Re) {
      if (Re instanceof DOMException && Re.name === "DataCloneError")
        throw Re;
      d.location.assign(De);
    }
    v && _ && _({
      action: E,
      location: ie.location,
      delta: 1
    });
  }
  function z(K, be) {
    E = ju.Replace;
    let ae = nw(ie.location, K, be);
    x = N();
    let ve = IR(ae, x), De = ie.createHref(ae);
    p.replaceState(ve, "", De), v && _ && _({
      action: E,
      location: ie.location,
      delta: 0
    });
  }
  function B(K) {
    let be = d.location.origin !== "null" ? d.location.origin : d.location.href, ae = typeof K == "string" ? K : Om(K);
    return ae = ae.replace(/ $/, "%20"), Wt(be, "No window.location.(origin|href) available to create URL for href: " + ae), new URL(ae, be);
  }
  let ie = {
    get action() {
      return E;
    },
    get location() {
      return o(d, p);
    },
    listen(K) {
      if (_)
        throw new Error("A history only accepts one active listener");
      return d.addEventListener(FR, O), _ = K, () => {
        d.removeEventListener(FR, O), _ = null;
      };
    },
    createHref(K) {
      return n(d, K);
    },
    createURL: B,
    encodeLocation(K) {
      let be = B(K);
      return {
        pathname: be.pathname,
        search: be.search,
        hash: be.hash
      };
    },
    push: P,
    replace: z,
    go(K) {
      return p.go(K);
    }
  };
  return ie;
}
var zR;
(function(o) {
  o.data = "data", o.deferred = "deferred", o.redirect = "redirect", o.error = "error";
})(zR || (zR = {}));
function KM(o, n, s) {
  return s === void 0 && (s = "/"), XM(o, n, s);
}
function XM(o, n, s, l) {
  let d = typeof n == "string" ? ih(n) : n, v = Fu(d.pathname || "/", s);
  if (v == null)
    return null;
  let p = z1(o);
  ZM(p);
  let E = null;
  for (let _ = 0; E == null && _ < p.length; ++_) {
    let x = cj(v);
    E = lj(p[_], x);
  }
  return E;
}
function z1(o, n, s, l) {
  n === void 0 && (n = []), s === void 0 && (s = []), l === void 0 && (l = "");
  let d = (v, p, E) => {
    let _ = {
      relativePath: E === void 0 ? v.path || "" : E,
      caseSensitive: v.caseSensitive === !0,
      childrenIndex: p,
      route: v
    };
    _.relativePath.startsWith("/") && (Wt(_.relativePath.startsWith(l), 'Absolute route path "' + _.relativePath + '" nested under path ' + ('"' + l + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), _.relativePath = _.relativePath.slice(l.length));
    let x = Ll([l, _.relativePath]), N = s.concat(_);
    v.children && v.children.length > 0 && (Wt(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      v.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + x + '".')
    ), z1(v.children, n, N, x)), !(v.path == null && !v.index) && n.push({
      path: x,
      score: sj(x, v.index),
      routesMeta: N
    });
  };
  return o.forEach((v, p) => {
    var E;
    if (v.path === "" || !((E = v.path) != null && E.includes("?")))
      d(v, p);
    else
      for (let _ of $1(v.path))
        d(v, p, _);
  }), n;
}
function $1(o) {
  let n = o.split("/");
  if (n.length === 0) return [];
  let [s, ...l] = n, d = s.endsWith("?"), v = s.replace(/\?$/, "");
  if (l.length === 0)
    return d ? [v, ""] : [v];
  let p = $1(l.join("/")), E = [];
  return E.push(...p.map((_) => _ === "" ? v : [v, _].join("/"))), d && E.push(...p), E.map((_) => o.startsWith("/") && _ === "" ? "/" : _);
}
function ZM(o) {
  o.sort((n, s) => n.score !== s.score ? s.score - n.score : oj(n.routesMeta.map((l) => l.childrenIndex), s.routesMeta.map((l) => l.childrenIndex)));
}
const ej = /^:[\w-]+$/, tj = 3, nj = 2, rj = 1, ij = 10, aj = -2, $R = (o) => o === "*";
function sj(o, n) {
  let s = o.split("/"), l = s.length;
  return s.some($R) && (l += aj), n && (l += nj), s.filter((d) => !$R(d)).reduce((d, v) => d + (ej.test(v) ? tj : v === "" ? rj : ij), l);
}
function oj(o, n) {
  return o.length === n.length && o.slice(0, -1).every((l, d) => l === n[d]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    o[o.length - 1] - n[n.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function lj(o, n, s) {
  let {
    routesMeta: l
  } = o, d = {}, v = "/", p = [];
  for (let E = 0; E < l.length; ++E) {
    let _ = l[E], x = E === l.length - 1, N = v === "/" ? n : n.slice(v.length) || "/", O = rw({
      path: _.relativePath,
      caseSensitive: _.caseSensitive,
      end: x
    }, N), P = _.route;
    if (!O)
      return null;
    Object.assign(d, O.params), p.push({
      // TODO: Can this as be avoided?
      params: d,
      pathname: Ll([v, O.pathname]),
      pathnameBase: pj(Ll([v, O.pathnameBase])),
      route: P
    }), O.pathnameBase !== "/" && (v = Ll([v, O.pathnameBase]));
  }
  return p;
}
function rw(o, n) {
  typeof o == "string" && (o = {
    path: o,
    caseSensitive: !1,
    end: !0
  });
  let [s, l] = uj(o.path, o.caseSensitive, o.end), d = n.match(s);
  if (!d) return null;
  let v = d[0], p = v.replace(/(.)\/+$/, "$1"), E = d.slice(1);
  return {
    params: l.reduce((x, N, O) => {
      let {
        paramName: P,
        isOptional: z
      } = N;
      if (P === "*") {
        let ie = E[O] || "";
        p = v.slice(0, v.length - ie.length).replace(/(.)\/+$/, "$1");
      }
      const B = E[O];
      return z && !B ? x[P] = void 0 : x[P] = (B || "").replace(/%2F/g, "/"), x;
    }, {}),
    pathname: v,
    pathnameBase: p,
    pattern: o
  };
}
function uj(o, n, s) {
  n === void 0 && (n = !1), s === void 0 && (s = !0), ro(o === "*" || !o.endsWith("*") || o.endsWith("/*"), 'Route path "' + o + '" will be treated as if it were ' + ('"' + o.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + o.replace(/\*$/, "/*") + '".'));
  let l = [], d = "^" + o.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (p, E, _) => (l.push({
    paramName: E,
    isOptional: _ != null
  }), _ ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return o.endsWith("*") ? (l.push({
    paramName: "*"
  }), d += o === "*" || o === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : s ? d += "\\/*$" : o !== "" && o !== "/" && (d += "(?:(?=\\/|$))"), [new RegExp(d, n ? void 0 : "i"), l];
}
function cj(o) {
  try {
    return o.split("/").map((n) => decodeURIComponent(n).replace(/\//g, "%2F")).join("/");
  } catch (n) {
    return ro(!1, 'The URL path "' + o + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + n + ").")), o;
  }
}
function Fu(o, n) {
  if (n === "/") return o;
  if (!o.toLowerCase().startsWith(n.toLowerCase()))
    return null;
  let s = n.endsWith("/") ? n.length - 1 : n.length, l = o.charAt(s);
  return l && l !== "/" ? null : o.slice(s) || "/";
}
function fj(o, n) {
  n === void 0 && (n = "/");
  let {
    pathname: s,
    search: l = "",
    hash: d = ""
  } = typeof o == "string" ? ih(o) : o;
  return {
    pathname: s ? s.startsWith("/") ? s : dj(s, n) : n,
    search: mj(l),
    hash: vj(d)
  };
}
function dj(o, n) {
  let s = n.replace(/\/+$/, "").split("/");
  return o.split("/").forEach((d) => {
    d === ".." ? s.length > 1 && s.pop() : d !== "." && s.push(d);
  }), s.length > 1 ? s.join("/") : "/";
}
function IE(o, n, s, l) {
  return "Cannot include a '" + o + "' character in a manually specified " + ("`to." + n + "` field [" + JSON.stringify(l) + "].  Please separate it out to the ") + ("`to." + s + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function hj(o) {
  return o.filter((n, s) => s === 0 || n.route.path && n.route.path.length > 0);
}
function xw(o, n) {
  let s = hj(o);
  return n ? s.map((l, d) => d === s.length - 1 ? l.pathname : l.pathnameBase) : s.map((l) => l.pathnameBase);
}
function Cw(o, n, s, l) {
  l === void 0 && (l = !1);
  let d;
  typeof o == "string" ? d = ih(o) : (d = km({}, o), Wt(!d.pathname || !d.pathname.includes("?"), IE("?", "pathname", "search", d)), Wt(!d.pathname || !d.pathname.includes("#"), IE("#", "pathname", "hash", d)), Wt(!d.search || !d.search.includes("#"), IE("#", "search", "hash", d)));
  let v = o === "" || d.pathname === "", p = v ? "/" : d.pathname, E;
  if (p == null)
    E = s;
  else {
    let O = n.length - 1;
    if (!l && p.startsWith("..")) {
      let P = p.split("/");
      for (; P[0] === ".."; )
        P.shift(), O -= 1;
      d.pathname = P.join("/");
    }
    E = O >= 0 ? n[O] : "/";
  }
  let _ = fj(d, E), x = p && p !== "/" && p.endsWith("/"), N = (v || p === ".") && s.endsWith("/");
  return !_.pathname.endsWith("/") && (x || N) && (_.pathname += "/"), _;
}
const Ll = (o) => o.join("/").replace(/\/\/+/g, "/"), pj = (o) => o.replace(/\/+$/, "").replace(/^\/*/, "/"), mj = (o) => !o || o === "?" ? "" : o.startsWith("?") ? o : "?" + o, vj = (o) => !o || o === "#" ? "" : o.startsWith("#") ? o : "#" + o;
function gj(o) {
  return o != null && typeof o.status == "number" && typeof o.statusText == "string" && typeof o.internal == "boolean" && "data" in o;
}
const B1 = ["post", "put", "patch", "delete"];
new Set(B1);
const yj = ["get", ...B1];
new Set(yj);
/**
 * React Router v6.28.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Nm() {
  return Nm = Object.assign ? Object.assign.bind() : function(o) {
    for (var n = 1; n < arguments.length; n++) {
      var s = arguments[n];
      for (var l in s)
        Object.prototype.hasOwnProperty.call(s, l) && (o[l] = s[l]);
    }
    return o;
  }, Nm.apply(this, arguments);
}
const Fm = /* @__PURE__ */ se.createContext(null);
process.env.NODE_ENV !== "production" && (Fm.displayName = "DataRouter");
const Rw = /* @__PURE__ */ se.createContext(null);
process.env.NODE_ENV !== "production" && (Rw.displayName = "DataRouterState");
const bj = /* @__PURE__ */ se.createContext(null);
process.env.NODE_ENV !== "production" && (bj.displayName = "Await");
const Cs = /* @__PURE__ */ se.createContext(null);
process.env.NODE_ENV !== "production" && (Cs.displayName = "Navigation");
const Im = /* @__PURE__ */ se.createContext(null);
process.env.NODE_ENV !== "production" && (Im.displayName = "Location");
const Vo = /* @__PURE__ */ se.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (Vo.displayName = "Route");
const Tw = /* @__PURE__ */ se.createContext(null);
process.env.NODE_ENV !== "production" && (Tw.displayName = "RouteError");
function Sj(o, n) {
  let {
    relative: s
  } = n === void 0 ? {} : n;
  ah() || (process.env.NODE_ENV !== "production" ? Wt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : Wt(!1));
  let {
    basename: l,
    navigator: d
  } = se.useContext(Cs), {
    hash: v,
    pathname: p,
    search: E
  } = $m(o, {
    relative: s
  }), _ = p;
  return l !== "/" && (_ = p === "/" ? l : Ll([l, p])), d.createHref({
    pathname: _,
    search: E,
    hash: v
  });
}
function ah() {
  return se.useContext(Im) != null;
}
function zu() {
  return ah() || (process.env.NODE_ENV !== "production" ? Wt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : Wt(!1)), se.useContext(Im).location;
}
const H1 = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function V1(o) {
  se.useContext(Cs).static || se.useLayoutEffect(o);
}
function zm() {
  let {
    isDataRoute: o
  } = se.useContext(Vo);
  return o ? jj() : Ej();
}
function Ej() {
  ah() || (process.env.NODE_ENV !== "production" ? Wt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : Wt(!1));
  let o = se.useContext(Fm), {
    basename: n,
    future: s,
    navigator: l
  } = se.useContext(Cs), {
    matches: d
  } = se.useContext(Vo), {
    pathname: v
  } = zu(), p = JSON.stringify(xw(d, s.v7_relativeSplatPath)), E = se.useRef(!1);
  return V1(() => {
    E.current = !0;
  }), se.useCallback(function(x, N) {
    if (N === void 0 && (N = {}), process.env.NODE_ENV !== "production" && ro(E.current, H1), !E.current) return;
    if (typeof x == "number") {
      l.go(x);
      return;
    }
    let O = Cw(x, JSON.parse(p), v, N.relative === "path");
    o == null && n !== "/" && (O.pathname = O.pathname === "/" ? n : Ll([n, O.pathname])), (N.replace ? l.replace : l.push)(O, N.state, N);
  }, [n, l, p, v, o]);
}
function $m(o, n) {
  let {
    relative: s
  } = n === void 0 ? {} : n, {
    future: l
  } = se.useContext(Cs), {
    matches: d
  } = se.useContext(Vo), {
    pathname: v
  } = zu(), p = JSON.stringify(xw(d, l.v7_relativeSplatPath));
  return se.useMemo(() => Cw(o, JSON.parse(p), v, s === "path"), [o, p, v, s]);
}
function wj(o, n) {
  return _j(o, n);
}
function _j(o, n, s, l) {
  ah() || (process.env.NODE_ENV !== "production" ? Wt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : Wt(!1));
  let {
    navigator: d
  } = se.useContext(Cs), {
    matches: v
  } = se.useContext(Vo), p = v[v.length - 1], E = p ? p.params : {}, _ = p ? p.pathname : "/", x = p ? p.pathnameBase : "/", N = p && p.route;
  if (process.env.NODE_ENV !== "production") {
    let ae = N && N.path || "";
    Y1(_, !N || ae.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + _ + '" (under <Route path="' + ae + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + ae + '"> to <Route ') + ('path="' + (ae === "/" ? "*" : ae + "/*") + '">.'));
  }
  let O = zu(), P;
  if (n) {
    var z;
    let ae = typeof n == "string" ? ih(n) : n;
    x === "/" || (z = ae.pathname) != null && z.startsWith(x) || (process.env.NODE_ENV !== "production" ? Wt(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + x + '" ') + ('but pathname "' + ae.pathname + '" was given in the `location` prop.')) : Wt(!1)), P = ae;
  } else
    P = O;
  let B = P.pathname || "/", ie = B;
  if (x !== "/") {
    let ae = x.replace(/^\//, "").split("/");
    ie = "/" + B.replace(/^\//, "").split("/").slice(ae.length).join("/");
  }
  let K = KM(o, {
    pathname: ie
  });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && ro(N || K != null, 'No routes matched location "' + P.pathname + P.search + P.hash + '" '), process.env.NODE_ENV !== "production" && ro(K == null || K[K.length - 1].route.element !== void 0 || K[K.length - 1].route.Component !== void 0 || K[K.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + P.pathname + P.search + P.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let be = kj(K && K.map((ae) => Object.assign({}, ae, {
    params: Object.assign({}, E, ae.params),
    pathname: Ll([
      x,
      // Re-encode pathnames that were decoded inside matchRoutes
      d.encodeLocation ? d.encodeLocation(ae.pathname).pathname : ae.pathname
    ]),
    pathnameBase: ae.pathnameBase === "/" ? x : Ll([
      x,
      // Re-encode pathnames that were decoded inside matchRoutes
      d.encodeLocation ? d.encodeLocation(ae.pathnameBase).pathname : ae.pathnameBase
    ])
  })), v, s, l);
  return n && be ? /* @__PURE__ */ se.createElement(Im.Provider, {
    value: {
      location: Nm({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, P),
      navigationType: ju.Pop
    }
  }, be) : be;
}
function xj() {
  let o = Mj(), n = gj(o) ? o.status + " " + o.statusText : o instanceof Error ? o.message : JSON.stringify(o), s = o instanceof Error ? o.stack : null, l = "rgba(200,200,200, 0.5)", d = {
    padding: "0.5rem",
    backgroundColor: l
  }, v = {
    padding: "2px 4px",
    backgroundColor: l
  }, p = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", o), p = /* @__PURE__ */ se.createElement(se.Fragment, null, /* @__PURE__ */ se.createElement("p", null, " Hey developer "), /* @__PURE__ */ se.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ se.createElement("code", {
    style: v
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ se.createElement("code", {
    style: v
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ se.createElement(se.Fragment, null, /* @__PURE__ */ se.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ se.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, n), s ? /* @__PURE__ */ se.createElement("pre", {
    style: d
  }, s) : null, p);
}
const Cj = /* @__PURE__ */ se.createElement(xj, null);
class Rj extends se.Component {
  constructor(n) {
    super(n), this.state = {
      location: n.location,
      revalidation: n.revalidation,
      error: n.error
    };
  }
  static getDerivedStateFromError(n) {
    return {
      error: n
    };
  }
  static getDerivedStateFromProps(n, s) {
    return s.location !== n.location || s.revalidation !== "idle" && n.revalidation === "idle" ? {
      error: n.error,
      location: n.location,
      revalidation: n.revalidation
    } : {
      error: n.error !== void 0 ? n.error : s.error,
      location: s.location,
      revalidation: n.revalidation || s.revalidation
    };
  }
  componentDidCatch(n, s) {
    console.error("React Router caught the following error during render", n, s);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ se.createElement(Vo.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ se.createElement(Tw.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function Tj(o) {
  let {
    routeContext: n,
    match: s,
    children: l
  } = o, d = se.useContext(Fm);
  return d && d.static && d.staticContext && (s.route.errorElement || s.route.ErrorBoundary) && (d.staticContext._deepestRenderedBoundaryId = s.route.id), /* @__PURE__ */ se.createElement(Vo.Provider, {
    value: n
  }, l);
}
function kj(o, n, s, l) {
  var d;
  if (n === void 0 && (n = []), s === void 0 && (s = null), l === void 0 && (l = null), o == null) {
    var v;
    if (!s)
      return null;
    if (s.errors)
      o = s.matches;
    else if ((v = l) != null && v.v7_partialHydration && n.length === 0 && !s.initialized && s.matches.length > 0)
      o = s.matches;
    else
      return null;
  }
  let p = o, E = (d = s) == null ? void 0 : d.errors;
  if (E != null) {
    let N = p.findIndex((O) => O.route.id && E?.[O.route.id] !== void 0);
    N >= 0 || (process.env.NODE_ENV !== "production" ? Wt(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(E).join(",")) : Wt(!1)), p = p.slice(0, Math.min(p.length, N + 1));
  }
  let _ = !1, x = -1;
  if (s && l && l.v7_partialHydration)
    for (let N = 0; N < p.length; N++) {
      let O = p[N];
      if ((O.route.HydrateFallback || O.route.hydrateFallbackElement) && (x = N), O.route.id) {
        let {
          loaderData: P,
          errors: z
        } = s, B = O.route.loader && P[O.route.id] === void 0 && (!z || z[O.route.id] === void 0);
        if (O.route.lazy || B) {
          _ = !0, x >= 0 ? p = p.slice(0, x + 1) : p = [p[0]];
          break;
        }
      }
    }
  return p.reduceRight((N, O, P) => {
    let z, B = !1, ie = null, K = null;
    s && (z = E && O.route.id ? E[O.route.id] : void 0, ie = O.route.errorElement || Cj, _ && (x < 0 && P === 0 ? (Y1("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), B = !0, K = null) : x === P && (B = !0, K = O.route.hydrateFallbackElement || null)));
    let be = n.concat(p.slice(0, P + 1)), ae = () => {
      let ve;
      return z ? ve = ie : B ? ve = K : O.route.Component ? ve = /* @__PURE__ */ se.createElement(O.route.Component, null) : O.route.element ? ve = O.route.element : ve = N, /* @__PURE__ */ se.createElement(Tj, {
        match: O,
        routeContext: {
          outlet: N,
          matches: be,
          isDataRoute: s != null
        },
        children: ve
      });
    };
    return s && (O.route.ErrorBoundary || O.route.errorElement || P === 0) ? /* @__PURE__ */ se.createElement(Rj, {
      location: s.location,
      revalidation: s.revalidation,
      component: ie,
      error: z,
      children: ae(),
      routeContext: {
        outlet: null,
        matches: be,
        isDataRoute: !0
      }
    }) : ae();
  }, null);
}
var q1 = /* @__PURE__ */ function(o) {
  return o.UseBlocker = "useBlocker", o.UseRevalidator = "useRevalidator", o.UseNavigateStable = "useNavigate", o;
}(q1 || {}), Am = /* @__PURE__ */ function(o) {
  return o.UseBlocker = "useBlocker", o.UseLoaderData = "useLoaderData", o.UseActionData = "useActionData", o.UseRouteError = "useRouteError", o.UseNavigation = "useNavigation", o.UseRouteLoaderData = "useRouteLoaderData", o.UseMatches = "useMatches", o.UseRevalidator = "useRevalidator", o.UseNavigateStable = "useNavigate", o.UseRouteId = "useRouteId", o;
}(Am || {});
function kw(o) {
  return o + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function Oj(o) {
  let n = se.useContext(Fm);
  return n || (process.env.NODE_ENV !== "production" ? Wt(!1, kw(o)) : Wt(!1)), n;
}
function Nj(o) {
  let n = se.useContext(Rw);
  return n || (process.env.NODE_ENV !== "production" ? Wt(!1, kw(o)) : Wt(!1)), n;
}
function Aj(o) {
  let n = se.useContext(Vo);
  return n || (process.env.NODE_ENV !== "production" ? Wt(!1, kw(o)) : Wt(!1)), n;
}
function Ow(o) {
  let n = Aj(o), s = n.matches[n.matches.length - 1];
  return s.route.id || (process.env.NODE_ENV !== "production" ? Wt(!1, o + ' can only be used on routes that contain a unique "id"') : Wt(!1)), s.route.id;
}
function Dj() {
  return Ow(Am.UseRouteId);
}
function Mj() {
  var o;
  let n = se.useContext(Tw), s = Nj(Am.UseRouteError), l = Ow(Am.UseRouteError);
  return n !== void 0 ? n : (o = s.errors) == null ? void 0 : o[l];
}
function jj() {
  let {
    router: o
  } = Oj(q1.UseNavigateStable), n = Ow(Am.UseNavigateStable), s = se.useRef(!1);
  return V1(() => {
    s.current = !0;
  }), se.useCallback(function(d, v) {
    v === void 0 && (v = {}), process.env.NODE_ENV !== "production" && ro(s.current, H1), s.current && (typeof d == "number" ? o.navigate(d) : o.navigate(d, Nm({
      fromRouteId: n
    }, v)));
  }, [o, n]);
}
const BR = {};
function Y1(o, n, s) {
  !n && !BR[o] && (BR[o] = !0, process.env.NODE_ENV !== "production" && ro(!1, s));
}
const HR = {};
function Lj(o, n) {
  HR[n] || (HR[n] = !0, console.warn(n));
}
const VR = (o, n, s) => Lj(o, " React Router Future Flag Warning: " + n + ". " + ("You can use the `" + o + "` future flag to opt-in early. ") + ("For more information, see " + s + "."));
function Pj(o, n) {
  o?.v7_startTransition === void 0 && VR("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition"), o?.v7_relativeSplatPath === void 0 && VR("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
}
function Uj(o) {
  let {
    to: n,
    replace: s,
    state: l,
    relative: d
  } = o;
  ah() || (process.env.NODE_ENV !== "production" ? Wt(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : Wt(!1));
  let {
    future: v,
    static: p
  } = se.useContext(Cs);
  process.env.NODE_ENV !== "production" && ro(!p, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let {
    matches: E
  } = se.useContext(Vo), {
    pathname: _
  } = zu(), x = zm(), N = Cw(n, xw(E, v.v7_relativeSplatPath), _, d === "path"), O = JSON.stringify(N);
  return se.useEffect(() => x(JSON.parse(O), {
    replace: s,
    state: l,
    relative: d
  }), [x, O, d, s, l]), null;
}
function iw(o) {
  process.env.NODE_ENV !== "production" ? Wt(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : Wt(!1);
}
function Fj(o) {
  let {
    basename: n = "/",
    children: s = null,
    location: l,
    navigationType: d = ju.Pop,
    navigator: v,
    static: p = !1,
    future: E
  } = o;
  ah() && (process.env.NODE_ENV !== "production" ? Wt(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : Wt(!1));
  let _ = n.replace(/^\/*/, "/"), x = se.useMemo(() => ({
    basename: _,
    navigator: v,
    static: p,
    future: Nm({
      v7_relativeSplatPath: !1
    }, E)
  }), [_, E, v, p]);
  typeof l == "string" && (l = ih(l));
  let {
    pathname: N = "/",
    search: O = "",
    hash: P = "",
    state: z = null,
    key: B = "default"
  } = l, ie = se.useMemo(() => {
    let K = Fu(N, _);
    return K == null ? null : {
      location: {
        pathname: K,
        search: O,
        hash: P,
        state: z,
        key: B
      },
      navigationType: d
    };
  }, [_, N, O, P, z, B, d]);
  return process.env.NODE_ENV !== "production" && ro(ie != null, '<Router basename="' + _ + '"> is not able to match the URL ' + ('"' + N + O + P + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), ie == null ? null : /* @__PURE__ */ se.createElement(Cs.Provider, {
    value: x
  }, /* @__PURE__ */ se.createElement(Im.Provider, {
    children: s,
    value: ie
  }));
}
function Ij(o) {
  let {
    children: n,
    location: s
  } = o;
  return wj(aw(n), s);
}
new Promise(() => {
});
function aw(o, n) {
  n === void 0 && (n = []);
  let s = [];
  return se.Children.forEach(o, (l, d) => {
    if (!/* @__PURE__ */ se.isValidElement(l))
      return;
    let v = [...n, d];
    if (l.type === se.Fragment) {
      s.push.apply(s, aw(l.props.children, v));
      return;
    }
    l.type !== iw && (process.env.NODE_ENV !== "production" ? Wt(!1, "[" + (typeof l.type == "string" ? l.type : l.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : Wt(!1)), !l.props.index || !l.props.children || (process.env.NODE_ENV !== "production" ? Wt(!1, "An index route cannot have child routes.") : Wt(!1));
    let p = {
      id: l.props.id || v.join("-"),
      caseSensitive: l.props.caseSensitive,
      element: l.props.element,
      Component: l.props.Component,
      index: l.props.index,
      path: l.props.path,
      loader: l.props.loader,
      action: l.props.action,
      errorElement: l.props.errorElement,
      ErrorBoundary: l.props.ErrorBoundary,
      hasErrorBoundary: l.props.ErrorBoundary != null || l.props.errorElement != null,
      shouldRevalidate: l.props.shouldRevalidate,
      handle: l.props.handle,
      lazy: l.props.lazy
    };
    l.props.children && (p.children = aw(l.props.children, v)), s.push(p);
  }), s;
}
/**
 * React Router DOM v6.28.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function eh() {
  return eh = Object.assign ? Object.assign.bind() : function(o) {
    for (var n = 1; n < arguments.length; n++) {
      var s = arguments[n];
      for (var l in s)
        Object.prototype.hasOwnProperty.call(s, l) && (o[l] = s[l]);
    }
    return o;
  }, eh.apply(this, arguments);
}
function Nw(o, n) {
  if (o == null) return {};
  var s = {}, l = Object.keys(o), d, v;
  for (v = 0; v < l.length; v++)
    d = l[v], !(n.indexOf(d) >= 0) && (s[d] = o[d]);
  return s;
}
const Vy = "get", qy = "application/x-www-form-urlencoded";
function c0(o) {
  return o != null && typeof o.tagName == "string";
}
function zj(o) {
  return c0(o) && o.tagName.toLowerCase() === "button";
}
function $j(o) {
  return c0(o) && o.tagName.toLowerCase() === "form";
}
function Bj(o) {
  return c0(o) && o.tagName.toLowerCase() === "input";
}
function Hj(o) {
  return !!(o.metaKey || o.altKey || o.ctrlKey || o.shiftKey);
}
function Vj(o, n) {
  return o.button === 0 && // Ignore everything but left clicks
  (!n || n === "_self") && // Let browser handle "target=_blank" etc.
  !Hj(o);
}
let Iy = null;
function qj() {
  if (Iy === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Iy = !1;
    } catch {
      Iy = !0;
    }
  return Iy;
}
const Yj = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function zE(o) {
  return o != null && !Yj.has(o) ? (process.env.NODE_ENV !== "production" && ro(!1, '"' + o + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + qy + '"')), null) : o;
}
function Wj(o, n) {
  let s, l, d, v, p;
  if ($j(o)) {
    let E = o.getAttribute("action");
    l = E ? Fu(E, n) : null, s = o.getAttribute("method") || Vy, d = zE(o.getAttribute("enctype")) || qy, v = new FormData(o);
  } else if (zj(o) || Bj(o) && (o.type === "submit" || o.type === "image")) {
    let E = o.form;
    if (E == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let _ = o.getAttribute("formaction") || E.getAttribute("action");
    if (l = _ ? Fu(_, n) : null, s = o.getAttribute("formmethod") || E.getAttribute("method") || Vy, d = zE(o.getAttribute("formenctype")) || zE(E.getAttribute("enctype")) || qy, v = new FormData(E, o), !qj()) {
      let {
        name: x,
        type: N,
        value: O
      } = o;
      if (N === "image") {
        let P = x ? x + "." : "";
        v.append(P + "x", "0"), v.append(P + "y", "0");
      } else x && v.append(x, O);
    }
  } else {
    if (c0(o))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    s = Vy, l = null, d = qy, p = o;
  }
  return v && d === "text/plain" && (p = v, v = void 0), {
    action: l,
    method: s.toLowerCase(),
    encType: d,
    formData: v,
    body: p
  };
}
const Gj = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], Jj = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], Qj = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"], Kj = "6";
try {
  window.__reactRouterVersion = Kj;
} catch {
}
const W1 = /* @__PURE__ */ se.createContext({
  isTransitioning: !1
});
process.env.NODE_ENV !== "production" && (W1.displayName = "ViewTransition");
const Xj = /* @__PURE__ */ se.createContext(/* @__PURE__ */ new Map());
process.env.NODE_ENV !== "production" && (Xj.displayName = "Fetchers");
const Zj = "startTransition", qR = WM[Zj];
function eL(o) {
  let {
    basename: n,
    children: s,
    future: l,
    window: d
  } = o, v = se.useRef();
  v.current == null && (v.current = GM({
    window: d,
    v5Compat: !0
  }));
  let p = v.current, [E, _] = se.useState({
    action: p.action,
    location: p.location
  }), {
    v7_startTransition: x
  } = l || {}, N = se.useCallback((O) => {
    x && qR ? qR(() => _(O)) : _(O);
  }, [_, x]);
  return se.useLayoutEffect(() => p.listen(N), [p, N]), se.useEffect(() => Pj(l), [l]), /* @__PURE__ */ se.createElement(Fj, {
    basename: n,
    children: s,
    location: E.location,
    navigationType: E.action,
    navigator: p,
    future: l
  });
}
process.env.NODE_ENV;
const tL = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", nL = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, G1 = /* @__PURE__ */ se.forwardRef(function(n, s) {
  let {
    onClick: l,
    relative: d,
    reloadDocument: v,
    replace: p,
    state: E,
    target: _,
    to: x,
    preventScrollReset: N,
    viewTransition: O
  } = n, P = Nw(n, Gj), {
    basename: z
  } = se.useContext(Cs), B, ie = !1;
  if (typeof x == "string" && nL.test(x) && (B = x, tL))
    try {
      let ve = new URL(window.location.href), De = x.startsWith("//") ? new URL(ve.protocol + x) : new URL(x), Re = Fu(De.pathname, z);
      De.origin === ve.origin && Re != null ? x = Re + De.search + De.hash : ie = !0;
    } catch {
      process.env.NODE_ENV !== "production" && ro(!1, '<Link to="' + x + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let K = Sj(x, {
    relative: d
  }), be = sL(x, {
    replace: p,
    state: E,
    target: _,
    preventScrollReset: N,
    relative: d,
    viewTransition: O
  });
  function ae(ve) {
    l && l(ve), ve.defaultPrevented || be(ve);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ se.createElement("a", eh({}, P, {
      href: B || K,
      onClick: ie || v ? l : ae,
      ref: s,
      target: _
    }))
  );
});
process.env.NODE_ENV !== "production" && (G1.displayName = "Link");
const rL = /* @__PURE__ */ se.forwardRef(function(n, s) {
  let {
    "aria-current": l = "page",
    caseSensitive: d = !1,
    className: v = "",
    end: p = !1,
    style: E,
    to: _,
    viewTransition: x,
    children: N
  } = n, O = Nw(n, Jj), P = $m(_, {
    relative: O.relative
  }), z = zu(), B = se.useContext(Rw), {
    navigator: ie,
    basename: K
  } = se.useContext(Cs), be = B != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  dL(P) && x === !0, ae = ie.encodeLocation ? ie.encodeLocation(P).pathname : P.pathname, ve = z.pathname, De = B && B.navigation && B.navigation.location ? B.navigation.location.pathname : null;
  d || (ve = ve.toLowerCase(), De = De ? De.toLowerCase() : null, ae = ae.toLowerCase()), De && K && (De = Fu(De, K) || De);
  const Re = ae !== "/" && ae.endsWith("/") ? ae.length - 1 : ae.length;
  let lt = ve === ae || !p && ve.startsWith(ae) && ve.charAt(Re) === "/", Ve = De != null && (De === ae || !p && De.startsWith(ae) && De.charAt(ae.length) === "/"), wt = {
    isActive: lt,
    isPending: Ve,
    isTransitioning: be
  }, Rt = lt ? l : void 0, zt;
  typeof v == "function" ? zt = v(wt) : zt = [v, lt ? "active" : null, Ve ? "pending" : null, be ? "transitioning" : null].filter(Boolean).join(" ");
  let it = typeof E == "function" ? E(wt) : E;
  return /* @__PURE__ */ se.createElement(G1, eh({}, O, {
    "aria-current": Rt,
    className: zt,
    ref: s,
    style: it,
    to: _,
    viewTransition: x
  }), typeof N == "function" ? N(wt) : N);
});
process.env.NODE_ENV !== "production" && (rL.displayName = "NavLink");
const iL = /* @__PURE__ */ se.forwardRef((o, n) => {
  let {
    fetcherKey: s,
    navigate: l,
    reloadDocument: d,
    replace: v,
    state: p,
    method: E = Vy,
    action: _,
    onSubmit: x,
    relative: N,
    preventScrollReset: O,
    viewTransition: P
  } = o, z = Nw(o, Qj), B = cL(), ie = fL(_, {
    relative: N
  }), K = E.toLowerCase() === "get" ? "get" : "post", be = (ae) => {
    if (x && x(ae), ae.defaultPrevented) return;
    ae.preventDefault();
    let ve = ae.nativeEvent.submitter, De = ve?.getAttribute("formmethod") || E;
    B(ve || ae.currentTarget, {
      fetcherKey: s,
      method: De,
      navigate: l,
      replace: v,
      state: p,
      relative: N,
      preventScrollReset: O,
      viewTransition: P
    });
  };
  return /* @__PURE__ */ se.createElement("form", eh({
    ref: n,
    method: K,
    action: ie,
    onSubmit: d ? x : be
  }, z));
});
process.env.NODE_ENV !== "production" && (iL.displayName = "Form");
process.env.NODE_ENV;
var Ky;
(function(o) {
  o.UseScrollRestoration = "useScrollRestoration", o.UseSubmit = "useSubmit", o.UseSubmitFetcher = "useSubmitFetcher", o.UseFetcher = "useFetcher", o.useViewTransitionState = "useViewTransitionState";
})(Ky || (Ky = {}));
var YR;
(function(o) {
  o.UseFetcher = "useFetcher", o.UseFetchers = "useFetchers", o.UseScrollRestoration = "useScrollRestoration";
})(YR || (YR = {}));
function aL(o) {
  return o + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function J1(o) {
  let n = se.useContext(Fm);
  return n || (process.env.NODE_ENV !== "production" ? Wt(!1, aL(o)) : Wt(!1)), n;
}
function sL(o, n) {
  let {
    target: s,
    replace: l,
    state: d,
    preventScrollReset: v,
    relative: p,
    viewTransition: E
  } = n === void 0 ? {} : n, _ = zm(), x = zu(), N = $m(o, {
    relative: p
  });
  return se.useCallback((O) => {
    if (Vj(O, s)) {
      O.preventDefault();
      let P = l !== void 0 ? l : Om(x) === Om(N);
      _(o, {
        replace: P,
        state: d,
        preventScrollReset: v,
        relative: p,
        viewTransition: E
      });
    }
  }, [x, _, N, l, d, s, o, v, p, E]);
}
function oL() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let lL = 0, uL = () => "__" + String(++lL) + "__";
function cL() {
  let {
    router: o
  } = J1(Ky.UseSubmit), {
    basename: n
  } = se.useContext(Cs), s = Dj();
  return se.useCallback(function(l, d) {
    d === void 0 && (d = {}), oL();
    let {
      action: v,
      method: p,
      encType: E,
      formData: _,
      body: x
    } = Wj(l, n);
    if (d.navigate === !1) {
      let N = d.fetcherKey || uL();
      o.fetch(N, s, d.action || v, {
        preventScrollReset: d.preventScrollReset,
        formData: _,
        body: x,
        formMethod: d.method || p,
        formEncType: d.encType || E,
        flushSync: d.flushSync
      });
    } else
      o.navigate(d.action || v, {
        preventScrollReset: d.preventScrollReset,
        formData: _,
        body: x,
        formMethod: d.method || p,
        formEncType: d.encType || E,
        replace: d.replace,
        state: d.state,
        fromRouteId: s,
        flushSync: d.flushSync,
        viewTransition: d.viewTransition
      });
  }, [o, n, s]);
}
function fL(o, n) {
  let {
    relative: s
  } = n === void 0 ? {} : n, {
    basename: l
  } = se.useContext(Cs), d = se.useContext(Vo);
  d || (process.env.NODE_ENV !== "production" ? Wt(!1, "useFormAction must be used inside a RouteContext") : Wt(!1));
  let [v] = d.matches.slice(-1), p = eh({}, $m(o || ".", {
    relative: s
  })), E = zu();
  if (o == null) {
    p.search = E.search;
    let _ = new URLSearchParams(p.search), x = _.getAll("index");
    if (x.some((O) => O === "")) {
      _.delete("index"), x.filter((P) => P).forEach((P) => _.append("index", P));
      let O = _.toString();
      p.search = O ? "?" + O : "";
    }
  }
  return (!o || o === ".") && v.route.index && (p.search = p.search ? p.search.replace(/^\?/, "?index&") : "?index"), l !== "/" && (p.pathname = p.pathname === "/" ? l : Ll([l, p.pathname])), Om(p);
}
function dL(o, n) {
  n === void 0 && (n = {});
  let s = se.useContext(W1);
  s == null && (process.env.NODE_ENV !== "production" ? Wt(!1, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : Wt(!1));
  let {
    basename: l
  } = J1(Ky.useViewTransitionState), d = $m(o, {
    relative: n.relative
  });
  if (!s.isTransitioning)
    return !1;
  let v = Fu(s.currentLocation.pathname, l) || s.currentLocation.pathname, p = Fu(s.nextLocation.pathname, l) || s.nextLocation.pathname;
  return rw(d.pathname, p) != null || rw(d.pathname, v) != null;
}
class hL extends se.Component {
  constructor(n) {
    super(n), this.state = {
      hasError: !1,
      errorMessage: ""
    };
  }
  static getDerivedStateFromError(n) {
    return n.message.includes("login") ? { hasError: !0, errorMessage: "Ocurri un error inesperado. Redirigiendo al login..." } : { hasError: !1, errorMessage: "" };
  }
  componentDidCatch(n, s) {
    console.warn("ErrorBoundary captur un error:", n, s);
  }
  render() {
    return this.state.hasError ? /* @__PURE__ */ me.jsx(Uj, { to: "/", state: { errorMessage: this.state.errorMessage } }) : this.props.children;
  }
}
function Q1(o, n) {
  return function() {
    return o.apply(n, arguments);
  };
}
const { toString: pL } = Object.prototype, { getPrototypeOf: Aw } = Object, f0 = /* @__PURE__ */ ((o) => (n) => {
  const s = pL.call(n);
  return o[s] || (o[s] = s.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), io = (o) => (o = o.toLowerCase(), (n) => f0(n) === o), d0 = (o) => (n) => typeof n === o, { isArray: sh } = Array, Dm = d0("undefined");
function mL(o) {
  return o !== null && !Dm(o) && o.constructor !== null && !Dm(o.constructor) && Ja(o.constructor.isBuffer) && o.constructor.isBuffer(o);
}
const K1 = io("ArrayBuffer");
function vL(o) {
  let n;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? n = ArrayBuffer.isView(o) : n = o && o.buffer && K1(o.buffer), n;
}
const gL = d0("string"), Ja = d0("function"), X1 = d0("number"), h0 = (o) => o !== null && typeof o == "object", yL = (o) => o === !0 || o === !1, Yy = (o) => {
  if (f0(o) !== "object")
    return !1;
  const n = Aw(o);
  return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in o) && !(Symbol.iterator in o);
}, bL = io("Date"), SL = io("File"), EL = io("Blob"), wL = io("FileList"), _L = (o) => h0(o) && Ja(o.pipe), xL = (o) => {
  let n;
  return o && (typeof FormData == "function" && o instanceof FormData || Ja(o.append) && ((n = f0(o)) === "formdata" || // detect form-data instance
  n === "object" && Ja(o.toString) && o.toString() === "[object FormData]"));
}, CL = io("URLSearchParams"), [RL, TL, kL, OL] = ["ReadableStream", "Request", "Response", "Headers"].map(io), NL = (o) => o.trim ? o.trim() : o.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Bm(o, n, { allOwnKeys: s = !1 } = {}) {
  if (o === null || typeof o > "u")
    return;
  let l, d;
  if (typeof o != "object" && (o = [o]), sh(o))
    for (l = 0, d = o.length; l < d; l++)
      n.call(null, o[l], l, o);
  else {
    const v = s ? Object.getOwnPropertyNames(o) : Object.keys(o), p = v.length;
    let E;
    for (l = 0; l < p; l++)
      E = v[l], n.call(null, o[E], E, o);
  }
}
function Z1(o, n) {
  n = n.toLowerCase();
  const s = Object.keys(o);
  let l = s.length, d;
  for (; l-- > 0; )
    if (d = s[l], n === d.toLowerCase())
      return d;
  return null;
}
const tf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, eT = (o) => !Dm(o) && o !== tf;
function sw() {
  const { caseless: o } = eT(this) && this || {}, n = {}, s = (l, d) => {
    const v = o && Z1(n, d) || d;
    Yy(n[v]) && Yy(l) ? n[v] = sw(n[v], l) : Yy(l) ? n[v] = sw({}, l) : sh(l) ? n[v] = l.slice() : n[v] = l;
  };
  for (let l = 0, d = arguments.length; l < d; l++)
    arguments[l] && Bm(arguments[l], s);
  return n;
}
const AL = (o, n, s, { allOwnKeys: l } = {}) => (Bm(n, (d, v) => {
  s && Ja(d) ? o[v] = Q1(d, s) : o[v] = d;
}, { allOwnKeys: l }), o), DL = (o) => (o.charCodeAt(0) === 65279 && (o = o.slice(1)), o), ML = (o, n, s, l) => {
  o.prototype = Object.create(n.prototype, l), o.prototype.constructor = o, Object.defineProperty(o, "super", {
    value: n.prototype
  }), s && Object.assign(o.prototype, s);
}, jL = (o, n, s, l) => {
  let d, v, p;
  const E = {};
  if (n = n || {}, o == null) return n;
  do {
    for (d = Object.getOwnPropertyNames(o), v = d.length; v-- > 0; )
      p = d[v], (!l || l(p, o, n)) && !E[p] && (n[p] = o[p], E[p] = !0);
    o = s !== !1 && Aw(o);
  } while (o && (!s || s(o, n)) && o !== Object.prototype);
  return n;
}, LL = (o, n, s) => {
  o = String(o), (s === void 0 || s > o.length) && (s = o.length), s -= n.length;
  const l = o.indexOf(n, s);
  return l !== -1 && l === s;
}, PL = (o) => {
  if (!o) return null;
  if (sh(o)) return o;
  let n = o.length;
  if (!X1(n)) return null;
  const s = new Array(n);
  for (; n-- > 0; )
    s[n] = o[n];
  return s;
}, UL = /* @__PURE__ */ ((o) => (n) => o && n instanceof o)(typeof Uint8Array < "u" && Aw(Uint8Array)), FL = (o, n) => {
  const l = (o && o[Symbol.iterator]).call(o);
  let d;
  for (; (d = l.next()) && !d.done; ) {
    const v = d.value;
    n.call(o, v[0], v[1]);
  }
}, IL = (o, n) => {
  let s;
  const l = [];
  for (; (s = o.exec(n)) !== null; )
    l.push(s);
  return l;
}, zL = io("HTMLFormElement"), $L = (o) => o.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(s, l, d) {
    return l.toUpperCase() + d;
  }
), WR = (({ hasOwnProperty: o }) => (n, s) => o.call(n, s))(Object.prototype), BL = io("RegExp"), tT = (o, n) => {
  const s = Object.getOwnPropertyDescriptors(o), l = {};
  Bm(s, (d, v) => {
    let p;
    (p = n(d, v, o)) !== !1 && (l[v] = p || d);
  }), Object.defineProperties(o, l);
}, HL = (o) => {
  tT(o, (n, s) => {
    if (Ja(o) && ["arguments", "caller", "callee"].indexOf(s) !== -1)
      return !1;
    const l = o[s];
    if (Ja(l)) {
      if (n.enumerable = !1, "writable" in n) {
        n.writable = !1;
        return;
      }
      n.set || (n.set = () => {
        throw Error("Can not rewrite read-only method '" + s + "'");
      });
    }
  });
}, VL = (o, n) => {
  const s = {}, l = (d) => {
    d.forEach((v) => {
      s[v] = !0;
    });
  };
  return sh(o) ? l(o) : l(String(o).split(n)), s;
}, qL = () => {
}, YL = (o, n) => o != null && Number.isFinite(o = +o) ? o : n, $E = "abcdefghijklmnopqrstuvwxyz", GR = "0123456789", nT = {
  DIGIT: GR,
  ALPHA: $E,
  ALPHA_DIGIT: $E + $E.toUpperCase() + GR
}, WL = (o = 16, n = nT.ALPHA_DIGIT) => {
  let s = "";
  const { length: l } = n;
  for (; o--; )
    s += n[Math.random() * l | 0];
  return s;
};
function GL(o) {
  return !!(o && Ja(o.append) && o[Symbol.toStringTag] === "FormData" && o[Symbol.iterator]);
}
const JL = (o) => {
  const n = new Array(10), s = (l, d) => {
    if (h0(l)) {
      if (n.indexOf(l) >= 0)
        return;
      if (!("toJSON" in l)) {
        n[d] = l;
        const v = sh(l) ? [] : {};
        return Bm(l, (p, E) => {
          const _ = s(p, d + 1);
          !Dm(_) && (v[E] = _);
        }), n[d] = void 0, v;
      }
    }
    return l;
  };
  return s(o, 0);
}, QL = io("AsyncFunction"), KL = (o) => o && (h0(o) || Ja(o)) && Ja(o.then) && Ja(o.catch), rT = ((o, n) => o ? setImmediate : n ? ((s, l) => (tf.addEventListener("message", ({ source: d, data: v }) => {
  d === tf && v === s && l.length && l.shift()();
}, !1), (d) => {
  l.push(d), tf.postMessage(s, "*");
}))(`axios@${Math.random()}`, []) : (s) => setTimeout(s))(
  typeof setImmediate == "function",
  Ja(tf.postMessage)
), XL = typeof queueMicrotask < "u" ? queueMicrotask.bind(tf) : typeof process < "u" && process.nextTick || rT, le = {
  isArray: sh,
  isArrayBuffer: K1,
  isBuffer: mL,
  isFormData: xL,
  isArrayBufferView: vL,
  isString: gL,
  isNumber: X1,
  isBoolean: yL,
  isObject: h0,
  isPlainObject: Yy,
  isReadableStream: RL,
  isRequest: TL,
  isResponse: kL,
  isHeaders: OL,
  isUndefined: Dm,
  isDate: bL,
  isFile: SL,
  isBlob: EL,
  isRegExp: BL,
  isFunction: Ja,
  isStream: _L,
  isURLSearchParams: CL,
  isTypedArray: UL,
  isFileList: wL,
  forEach: Bm,
  merge: sw,
  extend: AL,
  trim: NL,
  stripBOM: DL,
  inherits: ML,
  toFlatObject: jL,
  kindOf: f0,
  kindOfTest: io,
  endsWith: LL,
  toArray: PL,
  forEachEntry: FL,
  matchAll: IL,
  isHTMLForm: zL,
  hasOwnProperty: WR,
  hasOwnProp: WR,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: tT,
  freezeMethods: HL,
  toObjectSet: VL,
  toCamelCase: $L,
  noop: qL,
  toFiniteNumber: YL,
  findKey: Z1,
  global: tf,
  isContextDefined: eT,
  ALPHABET: nT,
  generateString: WL,
  isSpecCompliantForm: GL,
  toJSONObject: JL,
  isAsyncFn: QL,
  isThenable: KL,
  setImmediate: rT,
  asap: XL
};
function Yt(o, n, s, l, d) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = o, this.name = "AxiosError", n && (this.code = n), s && (this.config = s), l && (this.request = l), d && (this.response = d, this.status = d.status ? d.status : null);
}
le.inherits(Yt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: le.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const iT = Yt.prototype, aT = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((o) => {
  aT[o] = { value: o };
});
Object.defineProperties(Yt, aT);
Object.defineProperty(iT, "isAxiosError", { value: !0 });
Yt.from = (o, n, s, l, d, v) => {
  const p = Object.create(iT);
  return le.toFlatObject(o, p, function(_) {
    return _ !== Error.prototype;
  }, (E) => E !== "isAxiosError"), Yt.call(p, o.message, n, s, l, d), p.cause = o, p.name = o.name, v && Object.assign(p, v), p;
};
const ZL = null;
function ow(o) {
  return le.isPlainObject(o) || le.isArray(o);
}
function sT(o) {
  return le.endsWith(o, "[]") ? o.slice(0, -2) : o;
}
function JR(o, n, s) {
  return o ? o.concat(n).map(function(d, v) {
    return d = sT(d), !s && v ? "[" + d + "]" : d;
  }).join(s ? "." : "") : n;
}
function eP(o) {
  return le.isArray(o) && !o.some(ow);
}
const tP = le.toFlatObject(le, {}, null, function(n) {
  return /^is[A-Z]/.test(n);
});
function p0(o, n, s) {
  if (!le.isObject(o))
    throw new TypeError("target must be an object");
  n = n || new FormData(), s = le.toFlatObject(s, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(ie, K) {
    return !le.isUndefined(K[ie]);
  });
  const l = s.metaTokens, d = s.visitor || N, v = s.dots, p = s.indexes, _ = (s.Blob || typeof Blob < "u" && Blob) && le.isSpecCompliantForm(n);
  if (!le.isFunction(d))
    throw new TypeError("visitor must be a function");
  function x(B) {
    if (B === null) return "";
    if (le.isDate(B))
      return B.toISOString();
    if (!_ && le.isBlob(B))
      throw new Yt("Blob is not supported. Use a Buffer instead.");
    return le.isArrayBuffer(B) || le.isTypedArray(B) ? _ && typeof Blob == "function" ? new Blob([B]) : Buffer.from(B) : B;
  }
  function N(B, ie, K) {
    let be = B;
    if (B && !K && typeof B == "object") {
      if (le.endsWith(ie, "{}"))
        ie = l ? ie : ie.slice(0, -2), B = JSON.stringify(B);
      else if (le.isArray(B) && eP(B) || (le.isFileList(B) || le.endsWith(ie, "[]")) && (be = le.toArray(B)))
        return ie = sT(ie), be.forEach(function(ve, De) {
          !(le.isUndefined(ve) || ve === null) && n.append(
            // eslint-disable-next-line no-nested-ternary
            p === !0 ? JR([ie], De, v) : p === null ? ie : ie + "[]",
            x(ve)
          );
        }), !1;
    }
    return ow(B) ? !0 : (n.append(JR(K, ie, v), x(B)), !1);
  }
  const O = [], P = Object.assign(tP, {
    defaultVisitor: N,
    convertValue: x,
    isVisitable: ow
  });
  function z(B, ie) {
    if (!le.isUndefined(B)) {
      if (O.indexOf(B) !== -1)
        throw Error("Circular reference detected in " + ie.join("."));
      O.push(B), le.forEach(B, function(be, ae) {
        (!(le.isUndefined(be) || be === null) && d.call(
          n,
          be,
          le.isString(ae) ? ae.trim() : ae,
          ie,
          P
        )) === !0 && z(be, ie ? ie.concat(ae) : [ae]);
      }), O.pop();
    }
  }
  if (!le.isObject(o))
    throw new TypeError("data must be an object");
  return z(o), n;
}
function QR(o) {
  const n = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(o).replace(/[!'()~]|%20|%00/g, function(l) {
    return n[l];
  });
}
function Dw(o, n) {
  this._pairs = [], o && p0(o, this, n);
}
const oT = Dw.prototype;
oT.append = function(n, s) {
  this._pairs.push([n, s]);
};
oT.toString = function(n) {
  const s = n ? function(l) {
    return n.call(this, l, QR);
  } : QR;
  return this._pairs.map(function(d) {
    return s(d[0]) + "=" + s(d[1]);
  }, "").join("&");
};
function nP(o) {
  return encodeURIComponent(o).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function lT(o, n, s) {
  if (!n)
    return o;
  const l = s && s.encode || nP;
  le.isFunction(s) && (s = {
    serialize: s
  });
  const d = s && s.serialize;
  let v;
  if (d ? v = d(n, s) : v = le.isURLSearchParams(n) ? n.toString() : new Dw(n, s).toString(l), v) {
    const p = o.indexOf("#");
    p !== -1 && (o = o.slice(0, p)), o += (o.indexOf("?") === -1 ? "?" : "&") + v;
  }
  return o;
}
class KR {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(n, s, l) {
    return this.handlers.push({
      fulfilled: n,
      rejected: s,
      synchronous: l ? l.synchronous : !1,
      runWhen: l ? l.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(n) {
    this.handlers[n] && (this.handlers[n] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(n) {
    le.forEach(this.handlers, function(l) {
      l !== null && n(l);
    });
  }
}
const uT = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, rP = typeof URLSearchParams < "u" ? URLSearchParams : Dw, iP = typeof FormData < "u" ? FormData : null, aP = typeof Blob < "u" ? Blob : null, sP = {
  isBrowser: !0,
  classes: {
    URLSearchParams: rP,
    FormData: iP,
    Blob: aP
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Mw = typeof window < "u" && typeof document < "u", lw = typeof navigator == "object" && navigator || void 0, oP = Mw && (!lw || ["ReactNative", "NativeScript", "NS"].indexOf(lw.product) < 0), lP = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", uP = Mw && window.location.href || "http://localhost", cP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Mw,
  hasStandardBrowserEnv: oP,
  hasStandardBrowserWebWorkerEnv: lP,
  navigator: lw,
  origin: uP
}, Symbol.toStringTag, { value: "Module" })), zi = {
  ...cP,
  ...sP
};
function fP(o, n) {
  return p0(o, new zi.classes.URLSearchParams(), Object.assign({
    visitor: function(s, l, d, v) {
      return zi.isNode && le.isBuffer(s) ? (this.append(l, s.toString("base64")), !1) : v.defaultVisitor.apply(this, arguments);
    }
  }, n));
}
function dP(o) {
  return le.matchAll(/\w+|\[(\w*)]/g, o).map((n) => n[0] === "[]" ? "" : n[1] || n[0]);
}
function hP(o) {
  const n = {}, s = Object.keys(o);
  let l;
  const d = s.length;
  let v;
  for (l = 0; l < d; l++)
    v = s[l], n[v] = o[v];
  return n;
}
function cT(o) {
  function n(s, l, d, v) {
    let p = s[v++];
    if (p === "__proto__") return !0;
    const E = Number.isFinite(+p), _ = v >= s.length;
    return p = !p && le.isArray(d) ? d.length : p, _ ? (le.hasOwnProp(d, p) ? d[p] = [d[p], l] : d[p] = l, !E) : ((!d[p] || !le.isObject(d[p])) && (d[p] = []), n(s, l, d[p], v) && le.isArray(d[p]) && (d[p] = hP(d[p])), !E);
  }
  if (le.isFormData(o) && le.isFunction(o.entries)) {
    const s = {};
    return le.forEachEntry(o, (l, d) => {
      n(dP(l), d, s, 0);
    }), s;
  }
  return null;
}
function pP(o, n, s) {
  if (le.isString(o))
    try {
      return (n || JSON.parse)(o), le.trim(o);
    } catch (l) {
      if (l.name !== "SyntaxError")
        throw l;
    }
  return (0, JSON.stringify)(o);
}
const Hm = {
  transitional: uT,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(n, s) {
    const l = s.getContentType() || "", d = l.indexOf("application/json") > -1, v = le.isObject(n);
    if (v && le.isHTMLForm(n) && (n = new FormData(n)), le.isFormData(n))
      return d ? JSON.stringify(cT(n)) : n;
    if (le.isArrayBuffer(n) || le.isBuffer(n) || le.isStream(n) || le.isFile(n) || le.isBlob(n) || le.isReadableStream(n))
      return n;
    if (le.isArrayBufferView(n))
      return n.buffer;
    if (le.isURLSearchParams(n))
      return s.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), n.toString();
    let E;
    if (v) {
      if (l.indexOf("application/x-www-form-urlencoded") > -1)
        return fP(n, this.formSerializer).toString();
      if ((E = le.isFileList(n)) || l.indexOf("multipart/form-data") > -1) {
        const _ = this.env && this.env.FormData;
        return p0(
          E ? { "files[]": n } : n,
          _ && new _(),
          this.formSerializer
        );
      }
    }
    return v || d ? (s.setContentType("application/json", !1), pP(n)) : n;
  }],
  transformResponse: [function(n) {
    const s = this.transitional || Hm.transitional, l = s && s.forcedJSONParsing, d = this.responseType === "json";
    if (le.isResponse(n) || le.isReadableStream(n))
      return n;
    if (n && le.isString(n) && (l && !this.responseType || d)) {
      const p = !(s && s.silentJSONParsing) && d;
      try {
        return JSON.parse(n);
      } catch (E) {
        if (p)
          throw E.name === "SyntaxError" ? Yt.from(E, Yt.ERR_BAD_RESPONSE, this, null, this.response) : E;
      }
    }
    return n;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: zi.classes.FormData,
    Blob: zi.classes.Blob
  },
  validateStatus: function(n) {
    return n >= 200 && n < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
le.forEach(["delete", "get", "head", "post", "put", "patch"], (o) => {
  Hm.headers[o] = {};
});
const mP = le.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), vP = (o) => {
  const n = {};
  let s, l, d;
  return o && o.split(`
`).forEach(function(p) {
    d = p.indexOf(":"), s = p.substring(0, d).trim().toLowerCase(), l = p.substring(d + 1).trim(), !(!s || n[s] && mP[s]) && (s === "set-cookie" ? n[s] ? n[s].push(l) : n[s] = [l] : n[s] = n[s] ? n[s] + ", " + l : l);
  }), n;
}, XR = Symbol("internals");
function vm(o) {
  return o && String(o).trim().toLowerCase();
}
function Wy(o) {
  return o === !1 || o == null ? o : le.isArray(o) ? o.map(Wy) : String(o);
}
function gP(o) {
  const n = /* @__PURE__ */ Object.create(null), s = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let l;
  for (; l = s.exec(o); )
    n[l[1]] = l[2];
  return n;
}
const yP = (o) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(o.trim());
function BE(o, n, s, l, d) {
  if (le.isFunction(l))
    return l.call(this, n, s);
  if (d && (n = s), !!le.isString(n)) {
    if (le.isString(l))
      return n.indexOf(l) !== -1;
    if (le.isRegExp(l))
      return l.test(n);
  }
}
function bP(o) {
  return o.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (n, s, l) => s.toUpperCase() + l);
}
function SP(o, n) {
  const s = le.toCamelCase(" " + n);
  ["get", "set", "has"].forEach((l) => {
    Object.defineProperty(o, l + s, {
      value: function(d, v, p) {
        return this[l].call(this, n, d, v, p);
      },
      configurable: !0
    });
  });
}
class Na {
  constructor(n) {
    n && this.set(n);
  }
  set(n, s, l) {
    const d = this;
    function v(E, _, x) {
      const N = vm(_);
      if (!N)
        throw new Error("header name must be a non-empty string");
      const O = le.findKey(d, N);
      (!O || d[O] === void 0 || x === !0 || x === void 0 && d[O] !== !1) && (d[O || _] = Wy(E));
    }
    const p = (E, _) => le.forEach(E, (x, N) => v(x, N, _));
    if (le.isPlainObject(n) || n instanceof this.constructor)
      p(n, s);
    else if (le.isString(n) && (n = n.trim()) && !yP(n))
      p(vP(n), s);
    else if (le.isHeaders(n))
      for (const [E, _] of n.entries())
        v(_, E, l);
    else
      n != null && v(s, n, l);
    return this;
  }
  get(n, s) {
    if (n = vm(n), n) {
      const l = le.findKey(this, n);
      if (l) {
        const d = this[l];
        if (!s)
          return d;
        if (s === !0)
          return gP(d);
        if (le.isFunction(s))
          return s.call(this, d, l);
        if (le.isRegExp(s))
          return s.exec(d);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(n, s) {
    if (n = vm(n), n) {
      const l = le.findKey(this, n);
      return !!(l && this[l] !== void 0 && (!s || BE(this, this[l], l, s)));
    }
    return !1;
  }
  delete(n, s) {
    const l = this;
    let d = !1;
    function v(p) {
      if (p = vm(p), p) {
        const E = le.findKey(l, p);
        E && (!s || BE(l, l[E], E, s)) && (delete l[E], d = !0);
      }
    }
    return le.isArray(n) ? n.forEach(v) : v(n), d;
  }
  clear(n) {
    const s = Object.keys(this);
    let l = s.length, d = !1;
    for (; l--; ) {
      const v = s[l];
      (!n || BE(this, this[v], v, n, !0)) && (delete this[v], d = !0);
    }
    return d;
  }
  normalize(n) {
    const s = this, l = {};
    return le.forEach(this, (d, v) => {
      const p = le.findKey(l, v);
      if (p) {
        s[p] = Wy(d), delete s[v];
        return;
      }
      const E = n ? bP(v) : String(v).trim();
      E !== v && delete s[v], s[E] = Wy(d), l[E] = !0;
    }), this;
  }
  concat(...n) {
    return this.constructor.concat(this, ...n);
  }
  toJSON(n) {
    const s = /* @__PURE__ */ Object.create(null);
    return le.forEach(this, (l, d) => {
      l != null && l !== !1 && (s[d] = n && le.isArray(l) ? l.join(", ") : l);
    }), s;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([n, s]) => n + ": " + s).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(n) {
    return n instanceof this ? n : new this(n);
  }
  static concat(n, ...s) {
    const l = new this(n);
    return s.forEach((d) => l.set(d)), l;
  }
  static accessor(n) {
    const l = (this[XR] = this[XR] = {
      accessors: {}
    }).accessors, d = this.prototype;
    function v(p) {
      const E = vm(p);
      l[E] || (SP(d, p), l[E] = !0);
    }
    return le.isArray(n) ? n.forEach(v) : v(n), this;
  }
}
Na.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
le.reduceDescriptors(Na.prototype, ({ value: o }, n) => {
  let s = n[0].toUpperCase() + n.slice(1);
  return {
    get: () => o,
    set(l) {
      this[s] = l;
    }
  };
});
le.freezeMethods(Na);
function HE(o, n) {
  const s = this || Hm, l = n || s, d = Na.from(l.headers);
  let v = l.data;
  return le.forEach(o, function(E) {
    v = E.call(s, v, d.normalize(), n ? n.status : void 0);
  }), d.normalize(), v;
}
function fT(o) {
  return !!(o && o.__CANCEL__);
}
function oh(o, n, s) {
  Yt.call(this, o ?? "canceled", Yt.ERR_CANCELED, n, s), this.name = "CanceledError";
}
le.inherits(oh, Yt, {
  __CANCEL__: !0
});
function dT(o, n, s) {
  const l = s.config.validateStatus;
  !s.status || !l || l(s.status) ? o(s) : n(new Yt(
    "Request failed with status code " + s.status,
    [Yt.ERR_BAD_REQUEST, Yt.ERR_BAD_RESPONSE][Math.floor(s.status / 100) - 4],
    s.config,
    s.request,
    s
  ));
}
function EP(o) {
  const n = /^([-+\w]{1,25})(:?\/\/|:)/.exec(o);
  return n && n[1] || "";
}
function wP(o, n) {
  o = o || 10;
  const s = new Array(o), l = new Array(o);
  let d = 0, v = 0, p;
  return n = n !== void 0 ? n : 1e3, function(_) {
    const x = Date.now(), N = l[v];
    p || (p = x), s[d] = _, l[d] = x;
    let O = v, P = 0;
    for (; O !== d; )
      P += s[O++], O = O % o;
    if (d = (d + 1) % o, d === v && (v = (v + 1) % o), x - p < n)
      return;
    const z = N && x - N;
    return z ? Math.round(P * 1e3 / z) : void 0;
  };
}
function _P(o, n) {
  let s = 0, l = 1e3 / n, d, v;
  const p = (x, N = Date.now()) => {
    s = N, d = null, v && (clearTimeout(v), v = null), o.apply(null, x);
  };
  return [(...x) => {
    const N = Date.now(), O = N - s;
    O >= l ? p(x, N) : (d = x, v || (v = setTimeout(() => {
      v = null, p(d);
    }, l - O)));
  }, () => d && p(d)];
}
const Xy = (o, n, s = 3) => {
  let l = 0;
  const d = wP(50, 250);
  return _P((v) => {
    const p = v.loaded, E = v.lengthComputable ? v.total : void 0, _ = p - l, x = d(_), N = p <= E;
    l = p;
    const O = {
      loaded: p,
      total: E,
      progress: E ? p / E : void 0,
      bytes: _,
      rate: x || void 0,
      estimated: x && E && N ? (E - p) / x : void 0,
      event: v,
      lengthComputable: E != null,
      [n ? "download" : "upload"]: !0
    };
    o(O);
  }, s);
}, ZR = (o, n) => {
  const s = o != null;
  return [(l) => n[0]({
    lengthComputable: s,
    total: o,
    loaded: l
  }), n[1]];
}, e1 = (o) => (...n) => le.asap(() => o(...n)), xP = zi.hasStandardBrowserEnv ? /* @__PURE__ */ ((o, n) => (s) => (s = new URL(s, zi.origin), o.protocol === s.protocol && o.host === s.host && (n || o.port === s.port)))(
  new URL(zi.origin),
  zi.navigator && /(msie|trident)/i.test(zi.navigator.userAgent)
) : () => !0, CP = zi.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(o, n, s, l, d, v) {
      const p = [o + "=" + encodeURIComponent(n)];
      le.isNumber(s) && p.push("expires=" + new Date(s).toGMTString()), le.isString(l) && p.push("path=" + l), le.isString(d) && p.push("domain=" + d), v === !0 && p.push("secure"), document.cookie = p.join("; ");
    },
    read(o) {
      const n = document.cookie.match(new RegExp("(^|;\\s*)(" + o + ")=([^;]*)"));
      return n ? decodeURIComponent(n[3]) : null;
    },
    remove(o) {
      this.write(o, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function RP(o) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(o);
}
function TP(o, n) {
  return n ? o.replace(/\/?\/$/, "") + "/" + n.replace(/^\/+/, "") : o;
}
function hT(o, n) {
  return o && !RP(n) ? TP(o, n) : n;
}
const t1 = (o) => o instanceof Na ? { ...o } : o;
function af(o, n) {
  n = n || {};
  const s = {};
  function l(x, N, O, P) {
    return le.isPlainObject(x) && le.isPlainObject(N) ? le.merge.call({ caseless: P }, x, N) : le.isPlainObject(N) ? le.merge({}, N) : le.isArray(N) ? N.slice() : N;
  }
  function d(x, N, O, P) {
    if (le.isUndefined(N)) {
      if (!le.isUndefined(x))
        return l(void 0, x, O, P);
    } else return l(x, N, O, P);
  }
  function v(x, N) {
    if (!le.isUndefined(N))
      return l(void 0, N);
  }
  function p(x, N) {
    if (le.isUndefined(N)) {
      if (!le.isUndefined(x))
        return l(void 0, x);
    } else return l(void 0, N);
  }
  function E(x, N, O) {
    if (O in n)
      return l(x, N);
    if (O in o)
      return l(void 0, x);
  }
  const _ = {
    url: v,
    method: v,
    data: v,
    baseURL: p,
    transformRequest: p,
    transformResponse: p,
    paramsSerializer: p,
    timeout: p,
    timeoutMessage: p,
    withCredentials: p,
    withXSRFToken: p,
    adapter: p,
    responseType: p,
    xsrfCookieName: p,
    xsrfHeaderName: p,
    onUploadProgress: p,
    onDownloadProgress: p,
    decompress: p,
    maxContentLength: p,
    maxBodyLength: p,
    beforeRedirect: p,
    transport: p,
    httpAgent: p,
    httpsAgent: p,
    cancelToken: p,
    socketPath: p,
    responseEncoding: p,
    validateStatus: E,
    headers: (x, N, O) => d(t1(x), t1(N), O, !0)
  };
  return le.forEach(Object.keys(Object.assign({}, o, n)), function(N) {
    const O = _[N] || d, P = O(o[N], n[N], N);
    le.isUndefined(P) && O !== E || (s[N] = P);
  }), s;
}
const pT = (o) => {
  const n = af({}, o);
  let { data: s, withXSRFToken: l, xsrfHeaderName: d, xsrfCookieName: v, headers: p, auth: E } = n;
  n.headers = p = Na.from(p), n.url = lT(hT(n.baseURL, n.url), o.params, o.paramsSerializer), E && p.set(
    "Authorization",
    "Basic " + btoa((E.username || "") + ":" + (E.password ? unescape(encodeURIComponent(E.password)) : ""))
  );
  let _;
  if (le.isFormData(s)) {
    if (zi.hasStandardBrowserEnv || zi.hasStandardBrowserWebWorkerEnv)
      p.setContentType(void 0);
    else if ((_ = p.getContentType()) !== !1) {
      const [x, ...N] = _ ? _.split(";").map((O) => O.trim()).filter(Boolean) : [];
      p.setContentType([x || "multipart/form-data", ...N].join("; "));
    }
  }
  if (zi.hasStandardBrowserEnv && (l && le.isFunction(l) && (l = l(n)), l || l !== !1 && xP(n.url))) {
    const x = d && v && CP.read(v);
    x && p.set(d, x);
  }
  return n;
}, kP = typeof XMLHttpRequest < "u", OP = kP && function(o) {
  return new Promise(function(s, l) {
    const d = pT(o);
    let v = d.data;
    const p = Na.from(d.headers).normalize();
    let { responseType: E, onUploadProgress: _, onDownloadProgress: x } = d, N, O, P, z, B;
    function ie() {
      z && z(), B && B(), d.cancelToken && d.cancelToken.unsubscribe(N), d.signal && d.signal.removeEventListener("abort", N);
    }
    let K = new XMLHttpRequest();
    K.open(d.method.toUpperCase(), d.url, !0), K.timeout = d.timeout;
    function be() {
      if (!K)
        return;
      const ve = Na.from(
        "getAllResponseHeaders" in K && K.getAllResponseHeaders()
      ), Re = {
        data: !E || E === "text" || E === "json" ? K.responseText : K.response,
        status: K.status,
        statusText: K.statusText,
        headers: ve,
        config: o,
        request: K
      };
      dT(function(Ve) {
        s(Ve), ie();
      }, function(Ve) {
        l(Ve), ie();
      }, Re), K = null;
    }
    "onloadend" in K ? K.onloadend = be : K.onreadystatechange = function() {
      !K || K.readyState !== 4 || K.status === 0 && !(K.responseURL && K.responseURL.indexOf("file:") === 0) || setTimeout(be);
    }, K.onabort = function() {
      K && (l(new Yt("Request aborted", Yt.ECONNABORTED, o, K)), K = null);
    }, K.onerror = function() {
      l(new Yt("Network Error", Yt.ERR_NETWORK, o, K)), K = null;
    }, K.ontimeout = function() {
      let De = d.timeout ? "timeout of " + d.timeout + "ms exceeded" : "timeout exceeded";
      const Re = d.transitional || uT;
      d.timeoutErrorMessage && (De = d.timeoutErrorMessage), l(new Yt(
        De,
        Re.clarifyTimeoutError ? Yt.ETIMEDOUT : Yt.ECONNABORTED,
        o,
        K
      )), K = null;
    }, v === void 0 && p.setContentType(null), "setRequestHeader" in K && le.forEach(p.toJSON(), function(De, Re) {
      K.setRequestHeader(Re, De);
    }), le.isUndefined(d.withCredentials) || (K.withCredentials = !!d.withCredentials), E && E !== "json" && (K.responseType = d.responseType), x && ([P, B] = Xy(x, !0), K.addEventListener("progress", P)), _ && K.upload && ([O, z] = Xy(_), K.upload.addEventListener("progress", O), K.upload.addEventListener("loadend", z)), (d.cancelToken || d.signal) && (N = (ve) => {
      K && (l(!ve || ve.type ? new oh(null, o, K) : ve), K.abort(), K = null);
    }, d.cancelToken && d.cancelToken.subscribe(N), d.signal && (d.signal.aborted ? N() : d.signal.addEventListener("abort", N)));
    const ae = EP(d.url);
    if (ae && zi.protocols.indexOf(ae) === -1) {
      l(new Yt("Unsupported protocol " + ae + ":", Yt.ERR_BAD_REQUEST, o));
      return;
    }
    K.send(v || null);
  });
}, NP = (o, n) => {
  const { length: s } = o = o ? o.filter(Boolean) : [];
  if (n || s) {
    let l = new AbortController(), d;
    const v = function(x) {
      if (!d) {
        d = !0, E();
        const N = x instanceof Error ? x : this.reason;
        l.abort(N instanceof Yt ? N : new oh(N instanceof Error ? N.message : N));
      }
    };
    let p = n && setTimeout(() => {
      p = null, v(new Yt(`timeout ${n} of ms exceeded`, Yt.ETIMEDOUT));
    }, n);
    const E = () => {
      o && (p && clearTimeout(p), p = null, o.forEach((x) => {
        x.unsubscribe ? x.unsubscribe(v) : x.removeEventListener("abort", v);
      }), o = null);
    };
    o.forEach((x) => x.addEventListener("abort", v));
    const { signal: _ } = l;
    return _.unsubscribe = () => le.asap(E), _;
  }
}, AP = function* (o, n) {
  let s = o.byteLength;
  if (s < n) {
    yield o;
    return;
  }
  let l = 0, d;
  for (; l < s; )
    d = l + n, yield o.slice(l, d), l = d;
}, DP = async function* (o, n) {
  for await (const s of MP(o))
    yield* AP(s, n);
}, MP = async function* (o) {
  if (o[Symbol.asyncIterator]) {
    yield* o;
    return;
  }
  const n = o.getReader();
  try {
    for (; ; ) {
      const { done: s, value: l } = await n.read();
      if (s)
        break;
      yield l;
    }
  } finally {
    await n.cancel();
  }
}, n1 = (o, n, s, l) => {
  const d = DP(o, n);
  let v = 0, p, E = (_) => {
    p || (p = !0, l && l(_));
  };
  return new ReadableStream({
    async pull(_) {
      try {
        const { done: x, value: N } = await d.next();
        if (x) {
          E(), _.close();
          return;
        }
        let O = N.byteLength;
        if (s) {
          let P = v += O;
          s(P);
        }
        _.enqueue(new Uint8Array(N));
      } catch (x) {
        throw E(x), x;
      }
    },
    cancel(_) {
      return E(_), d.return();
    }
  }, {
    highWaterMark: 2
  });
}, m0 = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", mT = m0 && typeof ReadableStream == "function", jP = m0 && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((o) => (n) => o.encode(n))(new TextEncoder()) : async (o) => new Uint8Array(await new Response(o).arrayBuffer())), vT = (o, ...n) => {
  try {
    return !!o(...n);
  } catch {
    return !1;
  }
}, LP = mT && vT(() => {
  let o = !1;
  const n = new Request(zi.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return o = !0, "half";
    }
  }).headers.has("Content-Type");
  return o && !n;
}), r1 = 64 * 1024, uw = mT && vT(() => le.isReadableStream(new Response("").body)), Zy = {
  stream: uw && ((o) => o.body)
};
m0 && ((o) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((n) => {
    !Zy[n] && (Zy[n] = le.isFunction(o[n]) ? (s) => s[n]() : (s, l) => {
      throw new Yt(`Response type '${n}' is not supported`, Yt.ERR_NOT_SUPPORT, l);
    });
  });
})(new Response());
const PP = async (o) => {
  if (o == null)
    return 0;
  if (le.isBlob(o))
    return o.size;
  if (le.isSpecCompliantForm(o))
    return (await new Request(zi.origin, {
      method: "POST",
      body: o
    }).arrayBuffer()).byteLength;
  if (le.isArrayBufferView(o) || le.isArrayBuffer(o))
    return o.byteLength;
  if (le.isURLSearchParams(o) && (o = o + ""), le.isString(o))
    return (await jP(o)).byteLength;
}, UP = async (o, n) => {
  const s = le.toFiniteNumber(o.getContentLength());
  return s ?? PP(n);
}, FP = m0 && (async (o) => {
  let {
    url: n,
    method: s,
    data: l,
    signal: d,
    cancelToken: v,
    timeout: p,
    onDownloadProgress: E,
    onUploadProgress: _,
    responseType: x,
    headers: N,
    withCredentials: O = "same-origin",
    fetchOptions: P
  } = pT(o);
  x = x ? (x + "").toLowerCase() : "text";
  let z = NP([d, v && v.toAbortSignal()], p), B;
  const ie = z && z.unsubscribe && (() => {
    z.unsubscribe();
  });
  let K;
  try {
    if (_ && LP && s !== "get" && s !== "head" && (K = await UP(N, l)) !== 0) {
      let Re = new Request(n, {
        method: "POST",
        body: l,
        duplex: "half"
      }), lt;
      if (le.isFormData(l) && (lt = Re.headers.get("content-type")) && N.setContentType(lt), Re.body) {
        const [Ve, wt] = ZR(
          K,
          Xy(e1(_))
        );
        l = n1(Re.body, r1, Ve, wt);
      }
    }
    le.isString(O) || (O = O ? "include" : "omit");
    const be = "credentials" in Request.prototype;
    B = new Request(n, {
      ...P,
      signal: z,
      method: s.toUpperCase(),
      headers: N.normalize().toJSON(),
      body: l,
      duplex: "half",
      credentials: be ? O : void 0
    });
    let ae = await fetch(B);
    const ve = uw && (x === "stream" || x === "response");
    if (uw && (E || ve && ie)) {
      const Re = {};
      ["status", "statusText", "headers"].forEach((Rt) => {
        Re[Rt] = ae[Rt];
      });
      const lt = le.toFiniteNumber(ae.headers.get("content-length")), [Ve, wt] = E && ZR(
        lt,
        Xy(e1(E), !0)
      ) || [];
      ae = new Response(
        n1(ae.body, r1, Ve, () => {
          wt && wt(), ie && ie();
        }),
        Re
      );
    }
    x = x || "text";
    let De = await Zy[le.findKey(Zy, x) || "text"](ae, o);
    return !ve && ie && ie(), await new Promise((Re, lt) => {
      dT(Re, lt, {
        data: De,
        headers: Na.from(ae.headers),
        status: ae.status,
        statusText: ae.statusText,
        config: o,
        request: B
      });
    });
  } catch (be) {
    throw ie && ie(), be && be.name === "TypeError" && /fetch/i.test(be.message) ? Object.assign(
      new Yt("Network Error", Yt.ERR_NETWORK, o, B),
      {
        cause: be.cause || be
      }
    ) : Yt.from(be, be && be.code, o, B);
  }
}), cw = {
  http: ZL,
  xhr: OP,
  fetch: FP
};
le.forEach(cw, (o, n) => {
  if (o) {
    try {
      Object.defineProperty(o, "name", { value: n });
    } catch {
    }
    Object.defineProperty(o, "adapterName", { value: n });
  }
});
const i1 = (o) => `- ${o}`, IP = (o) => le.isFunction(o) || o === null || o === !1, gT = {
  getAdapter: (o) => {
    o = le.isArray(o) ? o : [o];
    const { length: n } = o;
    let s, l;
    const d = {};
    for (let v = 0; v < n; v++) {
      s = o[v];
      let p;
      if (l = s, !IP(s) && (l = cw[(p = String(s)).toLowerCase()], l === void 0))
        throw new Yt(`Unknown adapter '${p}'`);
      if (l)
        break;
      d[p || "#" + v] = l;
    }
    if (!l) {
      const v = Object.entries(d).map(
        ([E, _]) => `adapter ${E} ` + (_ === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let p = n ? v.length > 1 ? `since :
` + v.map(i1).join(`
`) : " " + i1(v[0]) : "as no adapter specified";
      throw new Yt(
        "There is no suitable adapter to dispatch the request " + p,
        "ERR_NOT_SUPPORT"
      );
    }
    return l;
  },
  adapters: cw
};
function VE(o) {
  if (o.cancelToken && o.cancelToken.throwIfRequested(), o.signal && o.signal.aborted)
    throw new oh(null, o);
}
function a1(o) {
  return VE(o), o.headers = Na.from(o.headers), o.data = HE.call(
    o,
    o.transformRequest
  ), ["post", "put", "patch"].indexOf(o.method) !== -1 && o.headers.setContentType("application/x-www-form-urlencoded", !1), gT.getAdapter(o.adapter || Hm.adapter)(o).then(function(l) {
    return VE(o), l.data = HE.call(
      o,
      o.transformResponse,
      l
    ), l.headers = Na.from(l.headers), l;
  }, function(l) {
    return fT(l) || (VE(o), l && l.response && (l.response.data = HE.call(
      o,
      o.transformResponse,
      l.response
    ), l.response.headers = Na.from(l.response.headers))), Promise.reject(l);
  });
}
const yT = "1.7.9", v0 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((o, n) => {
  v0[o] = function(l) {
    return typeof l === o || "a" + (n < 1 ? "n " : " ") + o;
  };
});
const s1 = {};
v0.transitional = function(n, s, l) {
  function d(v, p) {
    return "[Axios v" + yT + "] Transitional option '" + v + "'" + p + (l ? ". " + l : "");
  }
  return (v, p, E) => {
    if (n === !1)
      throw new Yt(
        d(p, " has been removed" + (s ? " in " + s : "")),
        Yt.ERR_DEPRECATED
      );
    return s && !s1[p] && (s1[p] = !0, console.warn(
      d(
        p,
        " has been deprecated since v" + s + " and will be removed in the near future"
      )
    )), n ? n(v, p, E) : !0;
  };
};
v0.spelling = function(n) {
  return (s, l) => (console.warn(`${l} is likely a misspelling of ${n}`), !0);
};
function zP(o, n, s) {
  if (typeof o != "object")
    throw new Yt("options must be an object", Yt.ERR_BAD_OPTION_VALUE);
  const l = Object.keys(o);
  let d = l.length;
  for (; d-- > 0; ) {
    const v = l[d], p = n[v];
    if (p) {
      const E = o[v], _ = E === void 0 || p(E, v, o);
      if (_ !== !0)
        throw new Yt("option " + v + " must be " + _, Yt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (s !== !0)
      throw new Yt("Unknown option " + v, Yt.ERR_BAD_OPTION);
  }
}
const Gy = {
  assertOptions: zP,
  validators: v0
}, Bo = Gy.validators;
class nf {
  constructor(n) {
    this.defaults = n, this.interceptors = {
      request: new KR(),
      response: new KR()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(n, s) {
    try {
      return await this._request(n, s);
    } catch (l) {
      if (l instanceof Error) {
        let d = {};
        Error.captureStackTrace ? Error.captureStackTrace(d) : d = new Error();
        const v = d.stack ? d.stack.replace(/^.+\n/, "") : "";
        try {
          l.stack ? v && !String(l.stack).endsWith(v.replace(/^.+\n.+\n/, "")) && (l.stack += `
` + v) : l.stack = v;
        } catch {
        }
      }
      throw l;
    }
  }
  _request(n, s) {
    typeof n == "string" ? (s = s || {}, s.url = n) : s = n || {}, s = af(this.defaults, s);
    const { transitional: l, paramsSerializer: d, headers: v } = s;
    l !== void 0 && Gy.assertOptions(l, {
      silentJSONParsing: Bo.transitional(Bo.boolean),
      forcedJSONParsing: Bo.transitional(Bo.boolean),
      clarifyTimeoutError: Bo.transitional(Bo.boolean)
    }, !1), d != null && (le.isFunction(d) ? s.paramsSerializer = {
      serialize: d
    } : Gy.assertOptions(d, {
      encode: Bo.function,
      serialize: Bo.function
    }, !0)), Gy.assertOptions(s, {
      baseUrl: Bo.spelling("baseURL"),
      withXsrfToken: Bo.spelling("withXSRFToken")
    }, !0), s.method = (s.method || this.defaults.method || "get").toLowerCase();
    let p = v && le.merge(
      v.common,
      v[s.method]
    );
    v && le.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (B) => {
        delete v[B];
      }
    ), s.headers = Na.concat(p, v);
    const E = [];
    let _ = !0;
    this.interceptors.request.forEach(function(ie) {
      typeof ie.runWhen == "function" && ie.runWhen(s) === !1 || (_ = _ && ie.synchronous, E.unshift(ie.fulfilled, ie.rejected));
    });
    const x = [];
    this.interceptors.response.forEach(function(ie) {
      x.push(ie.fulfilled, ie.rejected);
    });
    let N, O = 0, P;
    if (!_) {
      const B = [a1.bind(this), void 0];
      for (B.unshift.apply(B, E), B.push.apply(B, x), P = B.length, N = Promise.resolve(s); O < P; )
        N = N.then(B[O++], B[O++]);
      return N;
    }
    P = E.length;
    let z = s;
    for (O = 0; O < P; ) {
      const B = E[O++], ie = E[O++];
      try {
        z = B(z);
      } catch (K) {
        ie.call(this, K);
        break;
      }
    }
    try {
      N = a1.call(this, z);
    } catch (B) {
      return Promise.reject(B);
    }
    for (O = 0, P = x.length; O < P; )
      N = N.then(x[O++], x[O++]);
    return N;
  }
  getUri(n) {
    n = af(this.defaults, n);
    const s = hT(n.baseURL, n.url);
    return lT(s, n.params, n.paramsSerializer);
  }
}
le.forEach(["delete", "get", "head", "options"], function(n) {
  nf.prototype[n] = function(s, l) {
    return this.request(af(l || {}, {
      method: n,
      url: s,
      data: (l || {}).data
    }));
  };
});
le.forEach(["post", "put", "patch"], function(n) {
  function s(l) {
    return function(v, p, E) {
      return this.request(af(E || {}, {
        method: n,
        headers: l ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: v,
        data: p
      }));
    };
  }
  nf.prototype[n] = s(), nf.prototype[n + "Form"] = s(!0);
});
class jw {
  constructor(n) {
    if (typeof n != "function")
      throw new TypeError("executor must be a function.");
    let s;
    this.promise = new Promise(function(v) {
      s = v;
    });
    const l = this;
    this.promise.then((d) => {
      if (!l._listeners) return;
      let v = l._listeners.length;
      for (; v-- > 0; )
        l._listeners[v](d);
      l._listeners = null;
    }), this.promise.then = (d) => {
      let v;
      const p = new Promise((E) => {
        l.subscribe(E), v = E;
      }).then(d);
      return p.cancel = function() {
        l.unsubscribe(v);
      }, p;
    }, n(function(v, p, E) {
      l.reason || (l.reason = new oh(v, p, E), s(l.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(n) {
    if (this.reason) {
      n(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(n) : this._listeners = [n];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(n) {
    if (!this._listeners)
      return;
    const s = this._listeners.indexOf(n);
    s !== -1 && this._listeners.splice(s, 1);
  }
  toAbortSignal() {
    const n = new AbortController(), s = (l) => {
      n.abort(l);
    };
    return this.subscribe(s), n.signal.unsubscribe = () => this.unsubscribe(s), n.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let n;
    return {
      token: new jw(function(d) {
        n = d;
      }),
      cancel: n
    };
  }
}
function $P(o) {
  return function(s) {
    return o.apply(null, s);
  };
}
function BP(o) {
  return le.isObject(o) && o.isAxiosError === !0;
}
const fw = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(fw).forEach(([o, n]) => {
  fw[n] = o;
});
function bT(o) {
  const n = new nf(o), s = Q1(nf.prototype.request, n);
  return le.extend(s, nf.prototype, n, { allOwnKeys: !0 }), le.extend(s, n, null, { allOwnKeys: !0 }), s.create = function(d) {
    return bT(af(o, d));
  }, s;
}
const Ur = bT(Hm);
Ur.Axios = nf;
Ur.CanceledError = oh;
Ur.CancelToken = jw;
Ur.isCancel = fT;
Ur.VERSION = yT;
Ur.toFormData = p0;
Ur.AxiosError = Yt;
Ur.Cancel = Ur.CanceledError;
Ur.all = function(n) {
  return Promise.all(n);
};
Ur.spread = $P;
Ur.isAxiosError = BP;
Ur.mergeConfig = af;
Ur.AxiosHeaders = Na;
Ur.formToJSON = (o) => cT(le.isHTMLForm(o) ? new FormData(o) : o);
Ur.getAdapter = gT.getAdapter;
Ur.HttpStatusCode = fw;
Ur.default = Ur;
const HP = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function e0(o) {
  return typeof o == "string" && HP.test(o);
}
const Ei = [];
for (let o = 0; o < 256; ++o)
  Ei.push((o + 256).toString(16).slice(1));
function VP(o, n = 0) {
  return (Ei[o[n + 0]] + Ei[o[n + 1]] + Ei[o[n + 2]] + Ei[o[n + 3]] + "-" + Ei[o[n + 4]] + Ei[o[n + 5]] + "-" + Ei[o[n + 6]] + Ei[o[n + 7]] + "-" + Ei[o[n + 8]] + Ei[o[n + 9]] + "-" + Ei[o[n + 10]] + Ei[o[n + 11]] + Ei[o[n + 12]] + Ei[o[n + 13]] + Ei[o[n + 14]] + Ei[o[n + 15]]).toLowerCase();
}
let qE;
const qP = new Uint8Array(16);
function YP() {
  if (!qE) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    qE = crypto.getRandomValues.bind(crypto);
  }
  return qE(qP);
}
const WP = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), o1 = { randomUUID: WP };
function GP(o, n, s) {
  if (o1.randomUUID && !o)
    return o1.randomUUID();
  o = o || {};
  const l = o.random ?? o.rng?.() ?? YP();
  if (l.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return l[6] = l[6] & 15 | 64, l[8] = l[8] & 63 | 128, VP(l);
}
class ST {
  messageId;
  // Identificador nico (UUID)
  messageType;
  // Tipo de mensaje
  sendDate;
  // Fecha de envo (ISO string)
  serverDate;
  // Fecha en el servidor (ISO string)
  nickname;
  // Nombre del remitente
  token;
  // JWT del remitente
  messageText;
  // Contenido del mensaje
  roomName;
  // Nombre de la sala
  metadata;
  // Metadatos adicionales
  _roomId = "00000000-0000-0000-0000-000000000000";
  _idMessage = "00000000-0000-0000-0000-000000000000";
  constructor(n, s, l, d, v, p, E, _) {
    this.nickname = n, this.messageText = s, this.sendDate = l, this.serverDate = (/* @__PURE__ */ new Date()).toISOString(), this.token = v, this.roomName = p, this.metadata = E, this.messageType = _, this.messageId = GP(), this.roomId = d;
  }
  // Getter y Setter para idSala
  get idMessage() {
    return this.idMessage;
  }
  set idMessage(n) {
    if (!e0(n))
      throw new Error("El ID de la sala no es un UUID vlido");
    this._idMessage = n;
  }
  // Getter y Setter para idSala
  get roomId() {
    return this._roomId;
  }
  set roomId(n) {
    if (!e0(n))
      throw new Error("El ID de la sala no es un UUID vlido");
    this._roomId = n;
  }
}
const l1 = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIwIiwidXNlcm5hbWUiOiJkZWZhdWx0IiwiZXhwIjoxNjk4Mzg2Mjc5fQ.MGkJd5EYHQffQ9jrUzX7Djgmd4mOuH3aPRvcOP61TnM";
var ET = /* @__PURE__ */ ((o) => (o.TEXT = "text", o.IMAGE = "image", o.VIDEO = "video", o))(ET || {});
const Xa = new Uint8Array(0), sf = new TextEncoder(), Qa = new TextDecoder();
function JP(...o) {
  let n = 0;
  for (let d = 0; d < o.length; d++)
    n += o[d].length;
  const s = new Uint8Array(n);
  let l = 0;
  for (let d = 0; d < o.length; d++)
    s.set(o[d], l), l += o[d].length;
  return s;
}
function _m(...o) {
  const n = [];
  for (let s = 0; s < o.length; s++)
    n.push(sf.encode(o[s]));
  return n.length === 0 ? Xa : n.length === 1 ? n[0] : JP(...n);
}
function u1(o) {
  return !o || o.length === 0 ? "" : Qa.decode(o);
}
const c1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", f1 = 36, QP = 3656158440062976, d1 = 33, KP = 333, h1 = 22;
function XP(o) {
  for (let n = 0; n < o.length; n++)
    o[n] = Math.floor(Math.random() * 255);
}
function ZP(o) {
  globalThis?.crypto?.getRandomValues ? globalThis.crypto.getRandomValues(o) : XP(o);
}
class e2 {
  buf;
  seq;
  inc;
  inited;
  constructor() {
    this.buf = new Uint8Array(h1), this.inited = !1;
  }
  init() {
    this.inited = !0, this.setPre(), this.initSeqAndInc(), this.fillSeq();
  }
  initSeqAndInc() {
    this.seq = Math.floor(Math.random() * QP), this.inc = Math.floor(Math.random() * (KP - d1) + d1);
  }
  setPre() {
    const n = new Uint8Array(12);
    ZP(n);
    for (let s = 0; s < 12; s++) {
      const l = n[s] % 36;
      this.buf[s] = c1.charCodeAt(l);
    }
  }
  fillSeq() {
    let n = this.seq;
    for (let s = h1 - 1; s >= 12; s--)
      this.buf[s] = c1.charCodeAt(n % f1), n = Math.floor(n / f1);
  }
  next() {
    return this.inited || this.init(), this.seq += this.inc, this.seq > 3656158440062976 && (this.setPre(), this.initSeqAndInc()), this.fillSeq(), String.fromCharCode.apply(String, this.buf);
  }
  reset() {
    this.init();
  }
}
const of = new e2();
var Ml;
(function(o) {
  o.Disconnect = "disconnect", o.Reconnect = "reconnect", o.Update = "update", o.LDM = "ldm", o.Error = "error";
})(Ml || (Ml = {}));
var Qd;
(function(o) {
  o.Reconnecting = "reconnecting", o.PingTimer = "pingTimer", o.StaleConnection = "staleConnection", o.ClientInitiatedReconnect = "client initiated reconnect";
})(Qd || (Qd = {}));
var je;
(function(o) {
  o.ApiError = "BAD API", o.BadAuthentication = "BAD_AUTHENTICATION", o.BadCreds = "BAD_CREDS", o.BadHeader = "BAD_HEADER", o.BadJson = "BAD_JSON", o.BadPayload = "BAD_PAYLOAD", o.BadSubject = "BAD_SUBJECT", o.Cancelled = "CANCELLED", o.ConnectionClosed = "CONNECTION_CLOSED", o.ConnectionDraining = "CONNECTION_DRAINING", o.ConnectionRefused = "CONNECTION_REFUSED", o.ConnectionTimeout = "CONNECTION_TIMEOUT", o.Disconnect = "DISCONNECT", o.InvalidOption = "INVALID_OPTION", o.InvalidPayload = "INVALID_PAYLOAD", o.MaxPayloadExceeded = "MAX_PAYLOAD_EXCEEDED", o.NoResponders = "503", o.NotFunction = "NOT_FUNC", o.RequestError = "REQUEST_ERROR", o.ServerOptionNotAvailable = "SERVER_OPT_NA", o.SubClosed = "SUB_CLOSED", o.SubDraining = "SUB_DRAINING", o.Timeout = "TIMEOUT", o.Tls = "TLS", o.Unknown = "UNKNOWN_ERROR", o.WssRequired = "WSS_REQUIRED", o.JetStreamInvalidAck = "JESTREAM_INVALID_ACK", o.JetStream404NoMessages = "404", o.JetStream408RequestTimeout = "408", o.JetStream409MaxAckPendingExceeded = "409", o.JetStream409 = "409", o.JetStreamNotEnabled = "503", o.JetStreamIdleHeartBeat = "IDLE_HEARTBEAT", o.AuthorizationViolation = "AUTHORIZATION_VIOLATION", o.AuthenticationExpired = "AUTHENTICATION_EXPIRED", o.ProtocolError = "NATS_PROTOCOL_ERR", o.PermissionsViolation = "PERMISSIONS_VIOLATION", o.AuthenticationTimeout = "AUTHENTICATION_TIMEOUT", o.AccountExpired = "ACCOUNT_EXPIRED";
})(je || (je = {}));
function t2(o) {
  return typeof o.code == "string";
}
class wT {
  messages;
  constructor() {
    this.messages = /* @__PURE__ */ new Map(), this.messages.set(je.InvalidPayload, "Invalid payload type - payloads can be 'binary', 'string', or 'json'"), this.messages.set(je.BadJson, "Bad JSON"), this.messages.set(je.WssRequired, "TLS is required, therefore a secure websocket connection is also required");
  }
  static getMessage(n) {
    return n2.getMessage(n);
  }
  getMessage(n) {
    return this.messages.get(n) || n;
  }
}
const n2 = new wT();
class nt extends Error {
  name;
  message;
  code;
  permissionContext;
  chainedError;
  api_error;
  constructor(n, s, l) {
    super(n), this.name = "NatsError", this.message = n, this.code = s, this.chainedError = l;
  }
  static errorForCode(n, s) {
    const l = wT.getMessage(n);
    return new nt(l, n, s);
  }
  isAuthError() {
    return this.code === je.AuthenticationExpired || this.code === je.AuthorizationViolation || this.code === je.AccountExpired;
  }
  isAuthTimeout() {
    return this.code === je.AuthenticationTimeout;
  }
  isPermissionError() {
    return this.code === je.PermissionsViolation;
  }
  isProtocolError() {
    return this.code === je.ProtocolError;
  }
  isJetStreamError() {
    return this.api_error !== void 0;
  }
  jsError() {
    return this.api_error ? this.api_error : null;
  }
}
var Wa;
(function(o) {
  o[o.Exact = 0] = "Exact", o[o.CanonicalMIME = 1] = "CanonicalMIME", o[o.IgnoreCase = 2] = "IgnoreCase";
})(Wa || (Wa = {}));
var to;
(function(o) {
  o.Timer = "timer", o.Count = "count", o.JitterTimer = "jitterTimer", o.SentinelMsg = "sentinelMsg";
})(to || (to = {}));
var xm;
(function(o) {
  o.STATS = "io.nats.micro.v1.stats_response", o.INFO = "io.nats.micro.v1.info_response", o.PING = "io.nats.micro.v1.ping_response";
})(xm || (xm = {}));
const t0 = "Nats-Service-Error", n0 = "Nats-Service-Error-Code";
class r0 extends Error {
  code;
  constructor(n, s) {
    super(s), this.code = n;
  }
  static isServiceError(n) {
    return r0.toServiceError(n) !== null;
  }
  static toServiceError(n) {
    const s = n?.headers?.get(n0) || "";
    if (s !== "") {
      const l = parseInt(s) || 400, d = n?.headers?.get(t0) || "";
      return new r0(l, d.length ? d : s);
    }
    return null;
  }
}
function Pl(o = "") {
  if (o = o || "_INBOX", typeof o != "string")
    throw new Error("prefix must be a string");
  return o.split(".").forEach((n) => {
    if (n === "*" || n === ">")
      throw new Error(`inbox prefixes cannot have wildcards '${o}'`);
  }), `${o}.${of.next()}`;
}
const dw = "127.0.0.1";
var Lu;
(function(o) {
  o.PING = "PING", o.STATS = "STATS", o.INFO = "INFO";
})(Lu || (Lu = {}));
function g0(o, ...n) {
  for (let s = 0; s < n.length; s++) {
    const l = n[s];
    Object.keys(l).forEach(function(d) {
      o[d] = l[d];
    });
  }
  return o;
}
function zy(o) {
  return Qa.decode(o).replace(/\n/g, "").replace(/\r/g, "");
}
function th(o, n = !0) {
  const s = n ? nt.errorForCode(je.Timeout) : null;
  let l, d;
  const v = new Promise((p, E) => {
    l = {
      cancel: () => {
        d && clearTimeout(d);
      }
    }, d = setTimeout(() => {
      E(s === null ? nt.errorForCode(je.Timeout) : s);
    }, o);
  });
  return Object.assign(v, l);
}
function lh(o = 0) {
  let n;
  const s = new Promise((l) => {
    const d = setTimeout(() => {
      l();
    }, o);
    n = {
      cancel: () => {
        d && clearTimeout(d);
      }
    };
  });
  return Object.assign(s, n);
}
function nr() {
  let o = {};
  const n = new Promise((s, l) => {
    o = {
      resolve: s,
      reject: l
    };
  });
  return Object.assign(n, o);
}
function _T(o) {
  for (let n = o.length - 1; n > 0; n--) {
    const s = Math.floor(Math.random() * (n + 1));
    [o[n], o[s]] = [
      o[s],
      o[n]
    ];
  }
  return o;
}
function r2(o) {
  return o === 0 ? 0 : Math.floor(o / 2 + Math.random() * o);
}
function Lw(o = [
  0,
  250,
  250,
  500,
  500,
  3e3,
  5e3
]) {
  Array.isArray(o) || (o = [
    0,
    250,
    250,
    500,
    500,
    3e3,
    5e3
  ]);
  const n = o.length - 1;
  return {
    backoff(s) {
      return r2(s > n ? o[n] : o[s]);
    }
  };
}
function fr(o) {
  return o * 1e6;
}
function Pw(o) {
  return Math.floor(o / 1e6);
}
function p1(o) {
  let l = !0;
  const d = new Array(o.length);
  for (let v = 0; v < o.length; v++) {
    let p = o.charCodeAt(v);
    if (p === 58 || p < 33 || p > 126)
      throw new nt(`'${o[v]}' is not a valid character for a header key`, je.BadHeader);
    l && 97 <= p && p <= 122 ? p -= 32 : !l && 65 <= p && p <= 90 && (p += 32), d[v] = p, l = p == 45;
  }
  return String.fromCharCode(...d);
}
function Ul(o = 0, n = "") {
  if (o === 0 && n !== "" || o > 0 && n === "")
    throw new Error("setting status requires both code and description");
  return new Pu(o, n);
}
const YE = "NATS/1.0";
class Pu {
  _code;
  headers;
  _description;
  constructor(n = 0, s = "") {
    this._code = n, this._description = s, this.headers = /* @__PURE__ */ new Map();
  }
  [Symbol.iterator]() {
    return this.headers.entries();
  }
  size() {
    return this.headers.size;
  }
  equals(n) {
    if (n && this.headers.size === n.headers.size && this._code === n._code) {
      for (const [s, l] of this.headers) {
        const d = n.values(s);
        if (l.length !== d.length)
          return !1;
        const v = [
          ...l
        ].sort(), p = [
          ...d
        ].sort();
        for (let E = 0; E < v.length; E++)
          if (v[E] !== p[E])
            return !1;
      }
      return !0;
    }
    return !1;
  }
  static decode(n) {
    const s = new Pu(), d = Qa.decode(n).split(`\r
`), v = d[0];
    if (v !== YE) {
      let p = v.replace(YE, "").trim();
      if (p.length > 0) {
        s._code = parseInt(p, 10), isNaN(s._code) && (s._code = 0);
        const E = s._code.toString();
        p = p.replace(E, ""), s._description = p.trim();
      }
    }
    return d.length >= 1 && d.slice(1).map((p) => {
      if (p) {
        const E = p.indexOf(":");
        if (E > -1) {
          const _ = p.slice(0, E), x = p.slice(E + 1).trim();
          s.append(_, x);
        }
      }
    }), s;
  }
  toString() {
    if (this.headers.size === 0 && this._code === 0)
      return "";
    let n = YE;
    this._code > 0 && this._description !== "" && (n += ` ${this._code} ${this._description}`);
    for (const [s, l] of this.headers)
      for (let d = 0; d < l.length; d++)
        n = `${n}\r
${s}: ${l[d]}`;
    return `${n}\r
\r
`;
  }
  encode() {
    return sf.encode(this.toString());
  }
  static validHeaderValue(n) {
    if (/[\r\n]/.test(n))
      throw new nt("invalid header value - \\r and \\n are not allowed.", je.BadHeader);
    return n.trim();
  }
  keys() {
    const n = [];
    for (const s of this.headers.keys())
      n.push(s);
    return n;
  }
  findKeys(n, s = Wa.Exact) {
    const l = this.keys();
    switch (s) {
      case Wa.Exact:
        return l.filter((d) => d === n);
      case Wa.CanonicalMIME:
        return n = p1(n), l.filter((d) => d === n);
      default: {
        const d = n.toLowerCase();
        return l.filter((v) => d === v.toLowerCase());
      }
    }
  }
  get(n, s = Wa.Exact) {
    const l = this.findKeys(n, s);
    if (l.length) {
      const d = this.headers.get(l[0]);
      if (d)
        return Array.isArray(d) ? d[0] : d;
    }
    return "";
  }
  last(n, s = Wa.Exact) {
    const l = this.findKeys(n, s);
    if (l.length) {
      const d = this.headers.get(l[0]);
      if (d)
        return Array.isArray(d) ? d[d.length - 1] : d;
    }
    return "";
  }
  has(n, s = Wa.Exact) {
    return this.findKeys(n, s).length > 0;
  }
  set(n, s, l = Wa.Exact) {
    this.delete(n, l), this.append(n, s, l);
  }
  append(n, s, l = Wa.Exact) {
    const d = p1(n);
    l === Wa.CanonicalMIME && (n = d);
    const v = this.findKeys(n, l);
    n = v.length > 0 ? v[0] : n;
    const p = Pu.validHeaderValue(s);
    let E = this.headers.get(n);
    E || (E = [], this.headers.set(n, E)), E.push(p);
  }
  values(n, s = Wa.Exact) {
    const l = [];
    return this.findKeys(n, s).forEach((v) => {
      const p = this.headers.get(v);
      p && l.push(...p);
    }), l;
  }
  delete(n, s = Wa.Exact) {
    this.findKeys(n, s).forEach((d) => {
      this.headers.delete(d);
    });
  }
  get hasError() {
    return this._code >= 300;
  }
  get status() {
    return `${this._code} ${this._description}`.trim();
  }
  toRecord() {
    const n = {};
    return this.keys().forEach((s) => {
      n[s] = this.values(s);
    }), n;
  }
  get code() {
    return this._code;
  }
  get description() {
    return this._description;
  }
  static fromRecord(n) {
    const s = new Pu();
    for (const l in n)
      s.headers.set(l, n[l]);
    return s;
  }
}
function hw() {
  return {
    encode(o) {
      return sf.encode(o);
    },
    decode(o) {
      return Qa.decode(o);
    }
  };
}
function no(o) {
  return {
    encode(n) {
      try {
        return n === void 0 && (n = null), sf.encode(JSON.stringify(n));
      } catch (s) {
        throw nt.errorForCode(je.BadJson, s);
      }
    },
    decode(n) {
      try {
        return JSON.parse(Qa.decode(n), o);
      } catch (s) {
        throw nt.errorForCode(je.BadJson, s);
      }
    }
  };
}
function xT(o) {
  return o && o.data.length === 0 && o.headers?.code === 503 ? nt.errorForCode(je.NoResponders) : null;
}
class CT {
  _headers;
  _msg;
  _rdata;
  _reply;
  _subject;
  publisher;
  static jc;
  constructor(n, s, l) {
    this._msg = n, this._rdata = s, this.publisher = l;
  }
  get subject() {
    return this._subject ? this._subject : (this._subject = Qa.decode(this._msg.subject), this._subject);
  }
  get reply() {
    return this._reply ? this._reply : (this._reply = Qa.decode(this._msg.reply), this._reply);
  }
  get sid() {
    return this._msg.sid;
  }
  get headers() {
    if (this._msg.hdr > -1 && !this._headers) {
      const n = this._rdata.subarray(0, this._msg.hdr);
      this._headers = Pu.decode(n);
    }
    return this._headers;
  }
  get data() {
    return this._rdata ? this._msg.hdr > -1 ? this._rdata.subarray(this._msg.hdr) : this._rdata : new Uint8Array(0);
  }
  respond(n = Xa, s) {
    return this.reply ? (this.publisher.publish(this.reply, n, s), !0) : !1;
  }
  size() {
    const n = this._msg.subject.length, s = this._msg.reply?.length || 0, l = this._msg.size === -1 ? 0 : this._msg.size;
    return n + s + l;
  }
  json(n) {
    return no(n).decode(this.data);
  }
  string() {
    return Qa.decode(this.data);
  }
  requestInfo() {
    const n = this.headers?.get("Nats-Request-Info");
    return n ? JSON.parse(n, function(s, l) {
      return (s === "start" || s === "stop") && l !== "" ? new Date(Date.parse(l)) : l;
    }) : null;
  }
}
function Kd(o) {
  return y0("durable", o);
}
function ia(o) {
  return y0("stream", o);
}
function y0(o, n = "") {
  if (n === "")
    throw Error(`${o} name required`);
  return [
    ".",
    "*",
    ">",
    "/",
    "\\",
    " ",
    "	",
    `
`,
    "\r"
  ].forEach((l) => {
    if (n.indexOf(l) !== -1) {
      switch (l) {
        case `
`:
          l = "\\n";
          break;
        case "\r":
          l = "\\r";
          break;
        case "	":
          l = "\\t";
          break;
      }
      throw Error(`invalid ${o} name - ${o} name cannot contain '${l}'`);
    }
  }), "";
}
function Sm(o, n = "") {
  if (n === "")
    throw Error(`${o} name required`);
  const s = i2(n);
  if (s.length)
    throw new Error(`invalid ${o} name - ${o} name ${s}`);
}
function i2(o = "") {
  if (o === "")
    throw Error("name required");
  const n = /^[-\w]+$/g;
  if (o.match(n) === null) {
    for (const l of o.split(""))
      if (l.match(n) === null)
        return `cannot contain '${l}'`;
  }
  return "";
}
function pw(o) {
  if (o.data.length > 0)
    return !1;
  const n = o.headers;
  return n ? n.code >= 100 && n.code < 200 : !1;
}
function mw(o) {
  return pw(o) && o.headers?.description === "Idle Heartbeat";
}
function a2(o, n, s) {
  const l = Ul(o, n), d = {
    hdr: 1,
    sid: 0,
    size: 0
  }, v = new CT(d, Xa, {});
  return v._headers = l, v._subject = s, v;
}
function Xd(o) {
  if (o.data.length !== 0)
    return null;
  const n = o.headers;
  return n ? RT(n.code, n.description) : null;
}
var xs;
(function(o) {
  o.MaxBatchExceeded = "exceeded maxrequestbatch of", o.MaxExpiresExceeded = "exceeded maxrequestexpires of", o.MaxBytesExceeded = "exceeded maxrequestmaxbytes of", o.MaxMessageSizeExceeded = "message size exceeds maxbytes", o.PushConsumer = "consumer is push based", o.MaxWaitingExceeded = "exceeded maxwaiting", o.IdleHeartbeatMissed = "idle heartbeats missed", o.ConsumerDeleted = "consumer deleted";
})(xs || (xs = {}));
function s2(o) {
  return o.code !== je.JetStream409 ? !1 : [
    xs.MaxBatchExceeded,
    xs.MaxExpiresExceeded,
    xs.MaxBytesExceeded,
    xs.MaxMessageSizeExceeded,
    xs.PushConsumer,
    xs.IdleHeartbeatMissed,
    xs.ConsumerDeleted
  ].find((s) => o.message.indexOf(s) !== -1) !== void 0;
}
function RT(o, n = "") {
  if (o < 300)
    return null;
  switch (n = n.toLowerCase(), o) {
    case 404:
      return new nt(n, je.JetStream404NoMessages);
    case 408:
      return new nt(n, je.JetStream408RequestTimeout);
    case 409: {
      const s = n.startsWith(xs.IdleHeartbeatMissed) ? je.JetStreamIdleHeartBeat : je.JetStream409;
      return new nt(n, s);
    }
    case 503:
      return nt.errorForCode(je.JetStreamNotEnabled, new Error(n));
    default:
      return n === "" && (n = je.Unknown), new nt(n, `${o}`);
  }
}
class ii {
  inflight;
  processed;
  received;
  noIterator;
  iterClosed;
  done;
  signal;
  yields;
  filtered;
  pendingFiltered;
  ingestionFilterFn;
  protocolFilterFn;
  dispatchedFn;
  ctx;
  _data;
  err;
  time;
  yielding;
  constructor() {
    this.inflight = 0, this.filtered = 0, this.pendingFiltered = 0, this.processed = 0, this.received = 0, this.noIterator = !1, this.done = !1, this.signal = nr(), this.yields = [], this.iterClosed = nr(), this.time = 0, this.yielding = !1;
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  push(n) {
    if (this.done)
      return;
    if (typeof n == "function") {
      this.yields.push(n), this.signal.resolve();
      return;
    }
    const { ingest: s, protocol: l } = this.ingestionFilterFn ? this.ingestionFilterFn(n, this.ctx || this) : {
      ingest: !0,
      protocol: !1
    };
    s && (l && (this.filtered++, this.pendingFiltered++), this.yields.push(n), this.signal.resolve());
  }
  async *iterate() {
    if (this.noIterator)
      throw new nt("unsupported iterator", je.ApiError);
    if (this.yielding)
      throw new nt("already yielding", je.ApiError);
    this.yielding = !0;
    try {
      for (; ; ) {
        if (this.yields.length === 0 && await this.signal, this.err)
          throw this.err;
        const n = this.yields;
        this.inflight = n.length, this.yields = [];
        for (let s = 0; s < n.length; s++) {
          if (typeof n[s] == "function") {
            const d = n[s];
            try {
              d();
            } catch (v) {
              throw v;
            }
            if (this.err)
              throw this.err;
            continue;
          }
          if (this.protocolFilterFn ? this.protocolFilterFn(n[s]) : !0) {
            this.processed++;
            const d = Date.now();
            yield n[s], this.time = Date.now() - d, this.dispatchedFn && n[s] && this.dispatchedFn(n[s]);
          } else
            this.pendingFiltered--;
          this.inflight--;
        }
        if (this.done)
          break;
        this.yields.length === 0 && (n.length = 0, this.yields = n, this.signal = nr());
      }
    } finally {
      this.stop();
    }
  }
  stop(n) {
    this.done || (this.err = n, this.done = !0, this.signal.resolve(), this.iterClosed.resolve(n));
  }
  getProcessed() {
    return this.noIterator ? this.received : this.processed;
  }
  getPending() {
    return this.yields.length + this.inflight - this.pendingFiltered;
  }
  getReceived() {
    return this.received - this.filtered;
  }
}
class Uw {
  interval;
  maxOut;
  cancelAfter;
  timer;
  autoCancelTimer;
  last;
  missed;
  count;
  callback;
  constructor(n, s, l = {
    maxOut: 2
  }) {
    this.interval = n, this.maxOut = l?.maxOut || 2, this.cancelAfter = l?.cancelAfter || 0, this.last = Date.now(), this.missed = 0, this.count = 0, this.callback = s, this._schedule();
  }
  cancel() {
    this.autoCancelTimer && clearTimeout(this.autoCancelTimer), this.timer && clearInterval(this.timer), this.timer = 0, this.autoCancelTimer = 0, this.missed = 0;
  }
  work() {
    this.last = Date.now(), this.missed = 0;
  }
  _change(n, s = 0, l = 2) {
    this.interval = n, this.maxOut = l, this.cancelAfter = s, this.restart();
  }
  restart() {
    this.cancel(), this._schedule();
  }
  _schedule() {
    this.cancelAfter > 0 && (this.autoCancelTimer = setTimeout(() => {
      this.cancel();
    }, this.cancelAfter)), this.timer = setInterval(() => {
      if (this.count++, Date.now() - this.last > this.interval && this.missed++, this.missed >= this.maxOut)
        try {
          this.callback(this.missed) === !0 && this.cancel();
        } catch (n) {
          console.log(n);
        }
    }, this.interval);
  }
}
var i0;
(function(o) {
  o.Limits = "limits", o.Interest = "interest", o.Workqueue = "workqueue";
})(i0 || (i0 = {}));
var Mm;
(function(o) {
  o.Old = "old", o.New = "new";
})(Mm || (Mm = {}));
var vw;
(function(o) {
  o.File = "file", o.Memory = "memory";
})(vw || (vw = {}));
var Ar;
(function(o) {
  o.All = "all", o.Last = "last", o.New = "new", o.StartSequence = "by_start_sequence", o.StartTime = "by_start_time", o.LastPerSubject = "last_per_subject";
})(Ar || (Ar = {}));
var Pr;
(function(o) {
  o.None = "none", o.All = "all", o.Explicit = "explicit", o.NotSet = "";
})(Pr || (Pr = {}));
var nh;
(function(o) {
  o.Instant = "instant", o.Original = "original";
})(nh || (nh = {}));
var Iu;
(function(o) {
  o.None = "none", o.S2 = "s2";
})(Iu || (Iu = {}));
var a0;
(function(o) {
  o.CreateOrUpdate = "", o.Update = "update", o.Create = "create";
})(a0 || (a0 = {}));
function o2(o, n = {}) {
  return Object.assign({
    name: o,
    deliver_policy: Ar.All,
    ack_policy: Pr.Explicit,
    ack_wait: fr(30 * 1e3),
    replay_policy: nh.Instant
  }, n);
}
var m1;
(function(o) {
  o.API = "api_audit", o.StreamAction = "stream_action", o.ConsumerAction = "consumer_action", o.SnapshotCreate = "snapshot_create", o.SnapshotComplete = "snapshot_complete", o.RestoreCreate = "restore_create", o.RestoreComplete = "restore_complete", o.MaxDeliver = "max_deliver", o.Terminated = "terminated", o.Ack = "consumer_ack", o.StreamLeaderElected = "stream_leader_elected", o.StreamQuorumLost = "stream_quorum_lost", o.ConsumerLeaderElected = "consumer_leader_elected", o.ConsumerQuorumLost = "consumer_quorum_lost";
})(m1 || (m1 = {}));
var sa;
(function(o) {
  o.StreamSourceHdr = "Nats-Stream-Source", o.LastConsumerSeqHdr = "Nats-Last-Consumer", o.LastStreamSeqHdr = "Nats-Last-Stream", o.ConsumerStalledHdr = "Nats-Consumer-Stalled", o.MessageSizeHdr = "Nats-Msg-Size", o.RollupHdr = "Nats-Rollup", o.RollupValueSubject = "sub", o.RollupValueAll = "all", o.PendingMessagesHdr = "Nats-Pending-Messages", o.PendingBytesHdr = "Nats-Pending-Bytes";
})(sa || (sa = {}));
var eo;
(function(o) {
  o.LastValue = "", o.AllHistory = "history", o.UpdatesOnly = "updates";
})(eo || (eo = {}));
var Jd;
(function(o) {
  o.Stream = "Nats-Stream", o.Sequence = "Nats-Sequence", o.TimeStamp = "Nats-Time-Stamp", o.Subject = "Nats-Subject";
})(Jd || (Jd = {}));
var v1;
(function(o) {
  o.Stream = "Nats-Stream", o.Subject = "Nats-Subject", o.Sequence = "Nats-Sequence", o.LastSequence = "Nats-Last-Sequence", o.Size = "Nats-Msg-Size";
})(v1 || (v1 = {}));
const Ga = "KV_";
class l2 {
  config;
  ordered;
  mack;
  stream;
  callbackFn;
  max;
  qname;
  isBind;
  filters;
  constructor(n) {
    this.stream = "", this.mack = !1, this.ordered = !1, this.config = o2("", n || {});
  }
  getOpts() {
    const n = {};
    if (n.config = Object.assign({}, this.config), n.config.filter_subject && (this.filterSubject(n.config.filter_subject), n.config.filter_subject = void 0), n.config.filter_subjects && (n.config.filter_subjects?.forEach((s) => {
      this.filterSubject(s);
    }), n.config.filter_subjects = void 0), n.mack = this.mack, n.stream = this.stream, n.callbackFn = this.callbackFn, n.max = this.max, n.queue = this.qname, n.ordered = this.ordered, n.config.ack_policy = n.ordered ? Pr.None : n.config.ack_policy, n.isBind = n.isBind || !1, this.filters)
      switch (this.filters.length) {
        case 0:
          break;
        case 1:
          n.config.filter_subject = this.filters[0];
          break;
        default:
          n.config.filter_subjects = this.filters;
      }
    return n;
  }
  description(n) {
    return this.config.description = n, this;
  }
  deliverTo(n) {
    return this.config.deliver_subject = n, this;
  }
  durable(n) {
    return Kd(n), this.config.durable_name = n, this;
  }
  startSequence(n) {
    if (n <= 0)
      throw new Error("sequence must be greater than 0");
    return this.config.deliver_policy = Ar.StartSequence, this.config.opt_start_seq = n, this;
  }
  startTime(n) {
    return this.config.deliver_policy = Ar.StartTime, this.config.opt_start_time = n.toISOString(), this;
  }
  deliverAll() {
    return this.config.deliver_policy = Ar.All, this;
  }
  deliverLastPerSubject() {
    return this.config.deliver_policy = Ar.LastPerSubject, this;
  }
  deliverLast() {
    return this.config.deliver_policy = Ar.Last, this;
  }
  deliverNew() {
    return this.config.deliver_policy = Ar.New, this;
  }
  startAtTimeDelta(n) {
    return this.startTime(new Date(Date.now() - n)), this;
  }
  headersOnly() {
    return this.config.headers_only = !0, this;
  }
  ackNone() {
    return this.config.ack_policy = Pr.None, this;
  }
  ackAll() {
    return this.config.ack_policy = Pr.All, this;
  }
  ackExplicit() {
    return this.config.ack_policy = Pr.Explicit, this;
  }
  ackWait(n) {
    return this.config.ack_wait = fr(n), this;
  }
  maxDeliver(n) {
    return this.config.max_deliver = n, this;
  }
  filterSubject(n) {
    return this.filters = this.filters || [], this.filters.push(n), this;
  }
  replayInstantly() {
    return this.config.replay_policy = nh.Instant, this;
  }
  replayOriginal() {
    return this.config.replay_policy = nh.Original, this;
  }
  sample(n) {
    if (n = Math.trunc(n), n < 0 || n > 100)
      throw new Error("value must be between 0-100");
    return this.config.sample_freq = `${n}%`, this;
  }
  limit(n) {
    return this.config.rate_limit_bps = n, this;
  }
  maxWaiting(n) {
    return this.config.max_waiting = n, this;
  }
  maxAckPending(n) {
    return this.config.max_ack_pending = n, this;
  }
  idleHeartbeat(n) {
    return this.config.idle_heartbeat = fr(n), this;
  }
  flowControl() {
    return this.config.flow_control = !0, this;
  }
  deliverGroup(n) {
    return this.queue(n), this;
  }
  manualAck() {
    return this.mack = !0, this;
  }
  maxMessages(n) {
    return this.max = n, this;
  }
  callback(n) {
    return this.callbackFn = n, this;
  }
  queue(n) {
    return this.qname = n, this.config.deliver_group = n, this;
  }
  orderedConsumer() {
    return this.ordered = !0, this;
  }
  bind(n, s) {
    return this.stream = n, this.config.durable_name = s, this.isBind = !0, this;
  }
  bindStream(n) {
    return this.stream = n, this;
  }
  inactiveEphemeralThreshold(n) {
    return this.config.inactive_threshold = fr(n), this;
  }
  maxPullBatch(n) {
    return this.config.max_batch = n, this;
  }
  maxPullRequestExpires(n) {
    return this.config.max_expires = fr(n), this;
  }
  memory() {
    return this.config.mem_storage = !0, this;
  }
  numReplicas(n) {
    return this.config.num_replicas = n, this;
  }
  consumerName(n) {
    return this.config.name = n, this;
  }
}
function Uu(o) {
  return new l2(o);
}
function g1(o) {
  return typeof o.getOpts == "function";
}
class u2 {
  static encode(n) {
    if (typeof n == "string")
      return btoa(n);
    const s = Array.from(n);
    return btoa(String.fromCharCode(...s));
  }
  static decode(n, s = !1) {
    const l = atob(n);
    return s ? Uint8Array.from(l, (d) => d.charCodeAt(0)) : l;
  }
}
class Cm {
  static encode(n) {
    return Cm.toB64URLEncoding(u2.encode(n));
  }
  static decode(n, s = !1) {
    return Cm.decode(Cm.fromB64URLEncoding(n), s);
  }
  static toB64URLEncoding(n) {
    return n.replace(/\+/g, "-").replace(/\//g, "_");
  }
  static fromB64URLEncoding(n) {
    return n.replace(/_/g, "/").replace(/-/g, "+");
  }
}
class rh {
  buffers;
  byteLength;
  constructor() {
    this.buffers = [], this.byteLength = 0;
  }
  static concat(...n) {
    let s = 0;
    for (let v = 0; v < n.length; v++)
      s += n[v].length;
    const l = new Uint8Array(s);
    let d = 0;
    for (let v = 0; v < n.length; v++)
      l.set(n[v], d), d += n[v].length;
    return l;
  }
  static fromAscii(n) {
    return n || (n = ""), sf.encode(n);
  }
  static toAscii(n) {
    return Qa.decode(n);
  }
  reset() {
    this.buffers.length = 0, this.byteLength = 0;
  }
  pack() {
    if (this.buffers.length > 1) {
      const n = new Uint8Array(this.byteLength);
      let s = 0;
      for (let l = 0; l < this.buffers.length; l++)
        n.set(this.buffers[l], s), s += this.buffers[l].length;
      this.buffers.length = 0, this.buffers.push(n);
    }
  }
  shift() {
    if (this.buffers.length) {
      const n = this.buffers.shift();
      if (n)
        return this.byteLength -= n.length, n;
    }
    return new Uint8Array(0);
  }
  drain(n) {
    if (this.buffers.length) {
      this.pack();
      const s = this.buffers.pop();
      if (s) {
        const l = this.byteLength;
        (n === void 0 || n > l) && (n = l);
        const d = s.subarray(0, n);
        return l > n && this.buffers.push(s.subarray(n)), this.byteLength = l - n, d;
      }
    }
    return new Uint8Array(0);
  }
  fill(n, ...s) {
    n && (this.buffers.push(n), this.byteLength += n.length);
    for (let l = 0; l < s.length; l++)
      s[l] && s[l].length && (this.buffers.push(s[l]), this.byteLength += s[l].length);
  }
  peek() {
    return this.buffers.length ? (this.pack(), this.buffers[0]) : new Uint8Array(0);
  }
  size() {
    return this.byteLength;
  }
  length() {
    return this.buffers.length;
  }
}
function y1(o) {
  const n = o.length;
  let s = o.indexOf("=");
  s === -1 && (s = n);
  const l = s === n ? 0 : 4 - s % 4;
  return [
    s,
    l
  ];
}
function c2(o, n, s = !1) {
  function l(p, E) {
    return Math.floor((p + E) * 3 / 4 - E);
  }
  function d(p) {
    return o[p >> 18 & 63] + o[p >> 12 & 63] + o[p >> 6 & 63] + o[p & 63];
  }
  function v(p, E, _) {
    const x = new Array((_ - E) / 3);
    for (let N = E, O = 0; N < _; N += 3)
      x[O++] = d((p[N] << 16) + (p[N + 1] << 8) + p[N + 2]);
    return x.join("");
  }
  return {
    byteLength(p) {
      return l.apply(null, y1(p));
    },
    toUint8Array(p) {
      const [E, _] = y1(p), x = new Uint8Array(l(E, _)), N = _ ? E - 4 : E;
      let O, P = 0, z;
      for (z = 0; z < N; z += 4)
        O = n[p.charCodeAt(z)] << 18 | n[p.charCodeAt(z + 1)] << 12 | n[p.charCodeAt(z + 2)] << 6 | n[p.charCodeAt(z + 3)], x[P++] = O >> 16 & 255, x[P++] = O >> 8 & 255, x[P++] = O & 255;
      return _ === 2 ? (O = n[p.charCodeAt(z)] << 2 | n[p.charCodeAt(z + 1)] >> 4, x[P++] = O & 255) : _ === 1 && (O = n[p.charCodeAt(z)] << 10 | n[p.charCodeAt(z + 1)] << 4 | n[p.charCodeAt(z + 2)] >> 2, x[P++] = O >> 8 & 255, x[P++] = O & 255), x;
    },
    fromUint8Array(p) {
      const _ = p.length, x = _ % 3, N = _ - x, O = new Array(Math.ceil(N / 16383) + (x ? 1 : 0));
      let P = 0, z;
      for (let ie = 0; ie < N; ie += 16383)
        z = ie + 16383, O[P++] = v(p, ie, z > N ? N : z);
      let B;
      return x === 1 ? (B = p[N], O[P] = o[B >> 2] + o[B << 4 & 63], s || (O[P] += "==")) : x === 2 && (B = p[N] << 8 | p[N + 1] & 255, O[P] = o[B >> 10] + o[B >> 4 & 63] + o[B << 2 & 63], s || (O[P] += "=")), O.join("");
    }
  };
}
const TT = [], kT = [], WE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
for (let o = 0, n = WE.length; o < n; ++o)
  TT[o] = WE[o], kT[WE.charCodeAt(o)] = o;
const { byteLength: bF, toUint8Array: f2, fromUint8Array: d2 } = c2(TT, kT, !0), h2 = new TextDecoder(), p2 = new TextEncoder();
function m2(o) {
  return o.reduce((n, s) => `${n}${s < 16 ? "0" : ""}${s.toString(16)}`, "");
}
function v2(o) {
  const n = o.length;
  if (n % 2 || !/^[0-9a-fA-F]+$/.test(o))
    throw new TypeError("Invalid hex string.");
  o = o.toLowerCase();
  const s = new Uint8Array(Math.floor(n / 2)), l = n / 2;
  for (let d = 0; d < l; ++d)
    s[d] = parseInt(o.substr(d * 2, 2), 16);
  return s;
}
function g2(o, n = "utf8") {
  if (/^utf-?8$/i.test(n))
    return h2.decode(o);
  if (/^base64$/i.test(n))
    return d2(o);
  if (/^hex(?:adecimal)?$/i.test(n))
    return m2(o);
  throw new TypeError("Unsupported string encoding.");
}
function y2(o, n = "utf8") {
  if (/^utf-?8$/i.test(n))
    return p2.encode(o);
  if (/^base64$/i.test(n))
    return f2(o);
  if (/^hex(?:adecimal)?$/i.test(n))
    return v2(o);
  throw new TypeError("Unsupported string encoding.");
}
class b1 {
  hashSize = 32;
  _buf;
  _bufIdx;
  _count;
  _K;
  _H;
  _finalized;
  constructor() {
    this._buf = new Uint8Array(64), this._K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]), this.init();
  }
  init() {
    return this._H = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]), this._bufIdx = 0, this._count = new Uint32Array(2), this._buf.fill(0), this._finalized = !1, this;
  }
  update(n, s) {
    if (n === null)
      throw new TypeError("msg must be a string or Uint8Array.");
    typeof n == "string" && (n = y2(n, s));
    for (let d = 0, v = n.length; d < v; d++)
      this._buf[this._bufIdx++] = n[d], this._bufIdx === 64 && (this._transform(), this._bufIdx = 0);
    const l = this._count;
    return (l[0] += n.length << 3) < n.length << 3 && l[1]++, l[1] += n.length >>> 29, this;
  }
  digest(n) {
    if (this._finalized)
      throw new Error("digest has already been called.");
    this._finalized = !0;
    const s = this._buf;
    let l = this._bufIdx;
    for (s[l++] = 128; l !== 56; )
      l === 64 && (this._transform(), l = 0), s[l++] = 0;
    const d = this._count;
    s[56] = d[1] >>> 24 & 255, s[57] = d[1] >>> 16 & 255, s[58] = d[1] >>> 8 & 255, s[59] = d[1] >>> 0 & 255, s[60] = d[0] >>> 24 & 255, s[61] = d[0] >>> 16 & 255, s[62] = d[0] >>> 8 & 255, s[63] = d[0] >>> 0 & 255, this._transform();
    const v = new Uint8Array(32);
    for (let p = 0; p < 8; p++)
      v[(p << 2) + 0] = this._H[p] >>> 24 & 255, v[(p << 2) + 1] = this._H[p] >>> 16 & 255, v[(p << 2) + 2] = this._H[p] >>> 8 & 255, v[(p << 2) + 3] = this._H[p] >>> 0 & 255;
    return this.init(), n ? g2(v, n) : v;
  }
  _transform() {
    const n = this._H;
    let s = n[0], l = n[1], d = n[2], v = n[3], p = n[4], E = n[5], _ = n[6], x = n[7];
    const N = new Uint32Array(16);
    let O;
    for (O = 0; O < 16; O++)
      N[O] = this._buf[(O << 2) + 3] | this._buf[(O << 2) + 2] << 8 | this._buf[(O << 2) + 1] << 16 | this._buf[O << 2] << 24;
    for (O = 0; O < 64; O++) {
      let P;
      if (O < 16)
        P = N[O];
      else {
        let z = N[O + 1 & 15], B = N[O + 14 & 15];
        P = N[O & 15] = (z >>> 7 ^ z >>> 18 ^ z >>> 3 ^ z << 25 ^ z << 14) + (B >>> 17 ^ B >>> 19 ^ B >>> 10 ^ B << 15 ^ B << 13) + N[O & 15] + N[O + 9 & 15] | 0;
      }
      P = P + x + (p >>> 6 ^ p >>> 11 ^ p >>> 25 ^ p << 26 ^ p << 21 ^ p << 7) + (_ ^ p & (E ^ _)) + this._K[O] | 0, x = _, _ = E, E = p, p = v + P, v = d, d = l, l = s, s = P + (l & d ^ v & (l ^ d)) + (l >>> 2 ^ l >>> 13 ^ l >>> 22 ^ l << 30 ^ l << 19 ^ l << 10) | 0;
    }
    n[0] = n[0] + s | 0, n[1] = n[1] + l | 0, n[2] = n[2] + d | 0, n[3] = n[3] + v | 0, n[4] = n[4] + p | 0, n[5] = n[5] + E | 0, n[6] = n[6] + _ | 0, n[7] = n[7] + x | 0;
  }
}
class OT {
  token;
  received;
  ctx;
  requestSubject;
  mux;
  constructor(n, s, l = !0) {
    this.mux = n, this.requestSubject = s, this.received = 0, this.token = of.next(), l && (this.ctx = new Error());
  }
}
class b2 extends OT {
  callback;
  done;
  timer;
  max;
  opts;
  constructor(n, s, l = {
    maxWait: 1e3
  }) {
    if (super(n, s), this.opts = l, typeof this.opts.callback != "function")
      throw new Error("callback is required");
    this.callback = this.opts.callback, this.max = typeof l.maxMessages == "number" && l.maxMessages > 0 ? l.maxMessages : -1, this.done = nr(), this.done.then(() => {
      this.callback(null, null);
    }), this.timer = setTimeout(() => {
      this.cancel();
    }, l.maxWait);
  }
  cancel(n) {
    n && this.callback(n, null), clearTimeout(this.timer), this.mux.cancel(this), this.done.resolve();
  }
  resolver(n, s) {
    n ? (this.ctx && (n.stack += `

${this.ctx.stack}`), this.cancel(n)) : (this.callback(null, s), this.opts.strategy === to.Count && (this.max--, this.max === 0 && this.cancel()), this.opts.strategy === to.JitterTimer && (clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.cancel();
    }, this.opts.jitter || 300)), this.opts.strategy === to.SentinelMsg && s && s.data.length === 0 && this.cancel());
  }
}
class NT extends OT {
  deferred;
  timer;
  constructor(n, s, l = {
    timeout: 1e3
  }, d = !0) {
    super(n, s, d), this.deferred = nr(), this.timer = th(l.timeout, d);
  }
  resolver(n, s) {
    this.timer && this.timer.cancel(), n ? (this.ctx && (n.stack += `

${this.ctx.stack}`), this.deferred.reject(n)) : this.deferred.resolve(s), this.cancel();
  }
  cancel(n) {
    this.timer && this.timer.cancel(), this.mux.cancel(this), this.deferred.reject(n || nt.errorForCode(je.Cancelled));
  }
}
const S2 = "$JS.API";
function E2(o) {
  return o = o || {}, o.domain && (o.apiPrefix = `$JS.${o.domain}.API`, delete o.domain), g0({
    apiPrefix: S2,
    timeout: 5e3
  }, o);
}
class Vm {
  nc;
  opts;
  prefix;
  timeout;
  jc;
  constructor(n, s) {
    this.nc = n, this.opts = E2(s), this._parseOpts(), this.prefix = this.opts.apiPrefix, this.timeout = this.opts.timeout, this.jc = no();
  }
  getOptions() {
    return Object.assign({}, this.opts);
  }
  _parseOpts() {
    let n = this.opts.apiPrefix;
    if (!n || n.length === 0)
      throw new Error("invalid empty prefix");
    n[n.length - 1] === "." && (n = n.substr(0, n.length - 1)), this.opts.apiPrefix = n;
  }
  async _request(n, s = null, l) {
    l = l || {}, l.timeout = this.timeout;
    let d = Xa;
    s && (d = this.jc.encode(s));
    let { retries: v } = l;
    v = v || 1, v = v === -1 ? Number.MAX_SAFE_INTEGER : v;
    const p = Lw();
    for (let E = 0; E < v; E++)
      try {
        const _ = await this.nc.request(n, d, l);
        return this.parseJsResponse(_);
      } catch (_) {
        const x = _;
        if ((x.code === "503" || x.code === je.Timeout) && E + 1 < v)
          await lh(p.backoff(E));
        else
          throw _;
      }
  }
  async findStream(n) {
    const s = {
      subject: n
    }, d = await this._request(`${this.prefix}.STREAM.NAMES`, s);
    if (!d.streams || d.streams.length !== 1)
      throw new Error("no stream matches subject");
    return d.streams[0];
  }
  getConnection() {
    return this.nc;
  }
  parseJsResponse(n) {
    const s = this.jc.decode(n.data), l = s;
    if (l.error) {
      const d = RT(l.error.code, l.error.description);
      if (d !== null)
        throw d.api_error = l.error, d;
    }
    return s;
  }
}
class Em {
  err;
  offset;
  pageInfo;
  subject;
  jsm;
  filter;
  payload;
  constructor(n, s, l, d) {
    if (!n)
      throw new Error("subject is required");
    this.subject = n, this.jsm = l, this.offset = 0, this.pageInfo = {}, this.filter = s, this.payload = d || {};
  }
  async next() {
    if (this.err)
      return [];
    if (this.pageInfo && this.offset >= this.pageInfo.total)
      return [];
    const n = {
      offset: this.offset
    };
    this.payload && Object.assign(n, this.payload);
    try {
      const s = await this.jsm._request(this.subject, n, {
        timeout: this.jsm.timeout
      });
      this.pageInfo = s;
      const l = this.countResponse(s);
      return l === 0 ? [] : (this.offset += l, this.filter(s));
    } catch (s) {
      throw this.err = s, s;
    }
  }
  countResponse(n) {
    switch (n?.type) {
      case "io.nats.jetstream.api.v1.stream_names_response":
      case "io.nats.jetstream.api.v1.stream_list_response":
        return n.streams?.length || 0;
      case "io.nats.jetstream.api.v1.consumer_list_response":
        return n.consumers?.length || 0;
      default:
        return console.error(`jslister.ts: unknown API response for paged output: ${n?.type}`), n.streams?.length || 0;
    }
    return 0;
  }
  async *[Symbol.asyncIterator]() {
    let n = await this.next();
    for (; n.length > 0; ) {
      for (const s of n)
        yield s;
      n = await this.next();
    }
  }
}
function rf(o = "") {
  const n = o.match(/(\d+).(\d+).(\d+)/);
  if (n)
    return {
      major: parseInt(n[1]),
      minor: parseInt(n[2]),
      micro: parseInt(n[3])
    };
  throw new Error(`'${o}' is not a semver value`);
}
function gw(o, n) {
  return o.major < n.major ? -1 : o.major > n.major ? 1 : o.minor < n.minor ? -1 : o.minor > n.minor ? 1 : o.micro < n.micro ? -1 : o.micro > n.micro ? 1 : 0;
}
var vn;
(function(o) {
  o.JS_KV = "js_kv", o.JS_OBJECTSTORE = "js_objectstore", o.JS_PULL_MAX_BYTES = "js_pull_max_bytes", o.JS_NEW_CONSUMER_CREATE_API = "js_new_consumer_create", o.JS_ALLOW_DIRECT = "js_allow_direct", o.JS_MULTIPLE_CONSUMER_FILTER = "js_multiple_consumer_filter", o.JS_SIMPLIFICATION = "js_simplification", o.JS_STREAM_CONSUMER_METADATA = "js_stream_consumer_metadata", o.JS_CONSUMER_FILTER_SUBJECTS = "js_consumer_filter_subjects", o.JS_STREAM_FIRST_SEQ = "js_stream_first_seq", o.JS_STREAM_SUBJECT_TRANSFORM = "js_stream_subject_transform", o.JS_STREAM_SOURCE_SUBJECT_TRANSFORM = "js_stream_source_subject_transform", o.JS_STREAM_COMPRESSION = "js_stream_compression", o.JS_DEFAULT_CONSUMER_LIMITS = "js_default_consumer_limits", o.JS_BATCH_DIRECT_GET = "js_batch_direct_get";
})(vn || (vn = {}));
class w2 {
  server;
  features;
  disabled;
  constructor(n) {
    this.features = /* @__PURE__ */ new Map(), this.disabled = [], this.update(n);
  }
  resetDisabled() {
    this.disabled.length = 0, this.update(this.server);
  }
  disable(n) {
    this.disabled.push(n), this.update(this.server);
  }
  isDisabled(n) {
    return this.disabled.indexOf(n) !== -1;
  }
  update(n) {
    typeof n == "string" && (n = rf(n)), this.server = n, this.set(vn.JS_KV, "2.6.2"), this.set(vn.JS_OBJECTSTORE, "2.6.3"), this.set(vn.JS_PULL_MAX_BYTES, "2.8.3"), this.set(vn.JS_NEW_CONSUMER_CREATE_API, "2.9.0"), this.set(vn.JS_ALLOW_DIRECT, "2.9.0"), this.set(vn.JS_MULTIPLE_CONSUMER_FILTER, "2.10.0"), this.set(vn.JS_SIMPLIFICATION, "2.9.4"), this.set(vn.JS_STREAM_CONSUMER_METADATA, "2.10.0"), this.set(vn.JS_CONSUMER_FILTER_SUBJECTS, "2.10.0"), this.set(vn.JS_STREAM_FIRST_SEQ, "2.10.0"), this.set(vn.JS_STREAM_SUBJECT_TRANSFORM, "2.10.0"), this.set(vn.JS_STREAM_SOURCE_SUBJECT_TRANSFORM, "2.10.0"), this.set(vn.JS_STREAM_COMPRESSION, "2.10.0"), this.set(vn.JS_DEFAULT_CONSUMER_LIMITS, "2.10.0"), this.set(vn.JS_BATCH_DIRECT_GET, "2.11.0"), this.disabled.forEach((s) => {
      this.features.delete(s);
    });
  }
  set(n, s) {
    this.features.set(n, {
      min: s,
      ok: gw(this.server, rf(s)) >= 0
    });
  }
  get(n) {
    return this.features.get(n) || {
      min: "unknown",
      ok: !1
    };
  }
  supports(n) {
    return this.get(n)?.ok || !1;
  }
  require(n) {
    return typeof n == "string" && (n = rf(n)), gw(this.server, n) >= 0;
  }
}
class Fw extends Vm {
  constructor(n, s) {
    super(n, s);
  }
  async add(n, s, l = a0.Create) {
    if (ia(n), s.deliver_group && s.flow_control)
      throw new Error("jetstream flow control is not supported with queue groups");
    if (s.deliver_group && s.idle_heartbeat)
      throw new Error("jetstream idle heartbeat is not supported with queue groups");
    const d = {};
    d.config = s, d.stream_name = n, d.action = l, d.config.durable_name && Kd(d.config.durable_name);
    const v = this.nc;
    let { min: p, ok: E } = v.features.get(vn.JS_NEW_CONSUMER_CREATE_API);
    const _ = s.name === "" ? void 0 : s.name;
    if (_ && !E)
      throw new Error(`consumer 'name' requires server ${p}`);
    if (_)
      try {
        y0("name", _);
      } catch (P) {
        const z = P.message, B = z.indexOf("cannot contain");
        throw B !== -1 ? new Error(`consumer 'name' ${z.substring(B)}`) : P;
      }
    let x, N = "";
    if (Array.isArray(s.filter_subjects)) {
      const { min: P, ok: z } = v.features.get(vn.JS_MULTIPLE_CONSUMER_FILTER);
      if (!z)
        throw new Error(`consumer 'filter_subjects' requires server ${P}`);
      E = !1;
    }
    if (s.metadata) {
      const { min: P, ok: z } = v.features.get(vn.JS_STREAM_CONSUMER_METADATA);
      if (!z)
        throw new Error(`consumer 'metadata' requires server ${P}`);
    }
    if (E && (N = s.name ?? s.durable_name ?? ""), N !== "") {
      let P = s.filter_subject ?? void 0;
      P === ">" && (P = void 0), x = P !== void 0 ? `${this.prefix}.CONSUMER.CREATE.${n}.${N}.${P}` : `${this.prefix}.CONSUMER.CREATE.${n}.${N}`;
    } else
      x = s.durable_name ? `${this.prefix}.CONSUMER.DURABLE.CREATE.${n}.${s.durable_name}` : `${this.prefix}.CONSUMER.CREATE.${n}`;
    return await this._request(x, d);
  }
  async update(n, s, l) {
    const d = await this.info(n, s), v = l;
    return this.add(n, Object.assign(d.config, v), a0.Update);
  }
  async info(n, s) {
    return ia(n), Kd(s), await this._request(`${this.prefix}.CONSUMER.INFO.${n}.${s}`);
  }
  async delete(n, s) {
    return ia(n), Kd(s), (await this._request(`${this.prefix}.CONSUMER.DELETE.${n}.${s}`)).success;
  }
  list(n) {
    ia(n);
    const s = (d) => d.consumers, l = `${this.prefix}.CONSUMER.LIST.${n}`;
    return new Em(l, s, this);
  }
  pause(n, s, l) {
    const d = `${this.prefix}.CONSUMER.PAUSE.${n}.${s}`, v = {
      pause_until: l.toISOString()
    };
    return this._request(d, v);
  }
  resume(n, s) {
    return this.pause(n, s, /* @__PURE__ */ new Date(0));
  }
}
function Gd(o, n, s = !1) {
  if (s === !0 && !o)
    throw nt.errorForCode(je.ApiError, new Error(`${n} is not a function`));
  if (o && typeof o != "function")
    throw nt.errorForCode(je.ApiError, new Error(`${n} is not a function`));
}
class _2 extends ii {
  sub;
  adapter;
  subIterDone;
  constructor(n, s, l) {
    super(), Gd(l.adapter, "adapter", !0), this.adapter = l.adapter, l.callback && Gd(l.callback, "callback"), this.noIterator = typeof l.callback == "function", l.ingestionFilterFn && (Gd(l.ingestionFilterFn, "ingestionFilterFn"), this.ingestionFilterFn = l.ingestionFilterFn), l.protocolFilterFn && (Gd(l.protocolFilterFn, "protocolFilterFn"), this.protocolFilterFn = l.protocolFilterFn), l.dispatchedFn && (Gd(l.dispatchedFn, "dispatchedFn"), this.dispatchedFn = l.dispatchedFn), l.cleanupFn && Gd(l.cleanupFn, "cleanupFn");
    let d = (x, N) => {
      this.callback(x, N);
    };
    if (l.callback) {
      const x = l.callback;
      d = (N, O) => {
        const [P, z] = this.adapter(N, O);
        if (P) {
          x(P, null);
          return;
        }
        const { ingest: B } = this.ingestionFilterFn ? this.ingestionFilterFn(z, this) : {
          ingest: !0
        };
        B && (!this.protocolFilterFn || this.protocolFilterFn(z)) && (x(P, z), this.dispatchedFn && z && this.dispatchedFn(z));
      };
    }
    const { max: v, queue: p, timeout: E } = l, _ = {
      queue: p,
      timeout: E,
      callback: d
    };
    v && v > 0 && (_.max = v), this.sub = n.subscribe(s, _), l.cleanupFn && (this.sub.cleanupFn = l.cleanupFn), this.noIterator || this.iterClosed.then(() => {
      this.unsubscribe();
    }), this.subIterDone = nr(), Promise.all([
      this.sub.closed,
      this.iterClosed
    ]).then(() => {
      this.subIterDone.resolve();
    }).catch(() => {
      this.subIterDone.resolve();
    }), (async (x) => {
      await x.closed, this.stop();
    })(this.sub).then().catch();
  }
  unsubscribe(n) {
    this.sub.unsubscribe(n);
  }
  drain() {
    return this.sub.drain();
  }
  isDraining() {
    return this.sub.isDraining();
  }
  isClosed() {
    return this.sub.isClosed();
  }
  callback(n, s) {
    this.sub.cancelTimeout();
    const [l, d] = this.adapter(n, s);
    l && this.stop(l), d && this.push(d);
  }
  getSubject() {
    return this.sub.getSubject();
  }
  getReceived() {
    return this.sub.getReceived();
  }
  getProcessed() {
    return this.sub.getProcessed();
  }
  getPending() {
    return this.sub.getPending();
  }
  getID() {
    return this.sub.getID();
  }
  getMax() {
    return this.sub.getMax();
  }
  get closed() {
    return this.sub.closed;
  }
}
let Ka;
function x2(o) {
  Ka = o;
}
function AT() {
  return Ka !== void 0 && Ka.defaultPort !== void 0 ? Ka.defaultPort : 4222;
}
function GE() {
  return Ka !== void 0 && Ka.urlParseFn ? Ka.urlParseFn : void 0;
}
function C2() {
  if (!Ka || typeof Ka.factory != "function")
    throw new Error("transport fn is not set");
  return Ka.factory();
}
function yw() {
  return Ka !== void 0 && Ka.dnsResolveFn ? Ka.dnsResolveFn : void 0;
}
const Jy = `\r
`, s0 = rh.fromAscii(Jy), R2 = new Uint8Array(s0)[0], T2 = new Uint8Array(s0)[1];
function k2(o) {
  for (let n = 0; n < o.length; n++) {
    const s = n + 1;
    if (o.byteLength > s && o[n] === R2 && o[s] === T2)
      return s + 1;
  }
  return 0;
}
function O2(o) {
  const n = k2(o);
  if (n > 0) {
    const l = new Uint8Array(o).slice(0, n);
    return Qa.decode(l);
  }
  return "";
}
const N2 = 4, DT = 48, A2 = 65, D2 = 97;
function M2(o, n, s, l) {
  const d = new Uint8Array(16);
  return [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    255,
    255
  ].forEach((p, E) => {
    d[E] = p;
  }), d[12] = o, d[13] = n, d[14] = s, d[15] = l, d;
}
function bw(o) {
  return j2(o) !== void 0;
}
function j2(o) {
  for (let n = 0; n < o.length; n++)
    switch (o[n]) {
      case ".":
        return MT(o);
      case ":":
        return L2(o);
    }
}
function MT(o) {
  const n = new Uint8Array(4);
  for (let s = 0; s < 4; s++) {
    if (o.length === 0)
      return;
    if (s > 0) {
      if (o[0] !== ".")
        return;
      o = o.substring(1);
    }
    const { n: l, c: d, ok: v } = P2(o);
    if (!v || l > 255)
      return;
    o = o.substring(d), n[s] = l;
  }
  return M2(n[0], n[1], n[2], n[3]);
}
function L2(o) {
  const n = new Uint8Array(16);
  let s = -1;
  if (o.length >= 2 && o[0] === ":" && o[1] === ":" && (s = 0, o = o.substring(2), o.length === 0))
    return n;
  let l = 0;
  for (; l < 16; ) {
    const { n: d, c: v, ok: p } = U2(o);
    if (!p || d > 65535)
      return;
    if (v < o.length && o[v] === ".") {
      if (s < 0 && l != 12 || l + 4 > 16)
        return;
      const E = MT(o);
      if (E === void 0)
        return;
      n[l] = E[12], n[l + 1] = E[13], n[l + 2] = E[14], n[l + 3] = E[15], o = "", l += N2;
      break;
    }
    if (n[l] = d >> 8, n[l + 1] = d, l += 2, o = o.substring(v), o.length === 0)
      break;
    if (o[0] !== ":" || o.length == 1)
      return;
    if (o = o.substring(1), o[0] === ":") {
      if (s >= 0)
        return;
      if (s = l, o = o.substring(1), o.length === 0)
        break;
    }
  }
  if (o.length === 0) {
    if (l < 16) {
      if (s < 0)
        return;
      const d = 16 - l;
      for (let v = l - 1; v >= s; v--)
        n[v + d] = n[v];
      for (let v = s + d - 1; v >= s; v--)
        n[v] = 0;
    } else if (s >= 0)
      return;
    return n;
  }
}
function P2(o) {
  let n = 0, s = 0;
  for (n = 0; n < o.length && 48 <= o.charCodeAt(n) && o.charCodeAt(n) <= 57; n++)
    if (s = s * 10 + (o.charCodeAt(n) - DT), s >= 16777215)
      return {
        n: 16777215,
        c: n,
        ok: !1
      };
  return n === 0 ? {
    n: 0,
    c: 0,
    ok: !1
  } : {
    n: s,
    c: n,
    ok: !0
  };
}
function U2(o) {
  let n = 0, s = 0;
  for (s = 0; s < o.length; s++) {
    if (48 <= o.charCodeAt(s) && o.charCodeAt(s) <= 57)
      n *= 16, n += o.charCodeAt(s) - DT;
    else if (97 <= o.charCodeAt(s) && o.charCodeAt(s) <= 102)
      n *= 16, n += o.charCodeAt(s) - D2 + 10;
    else if (65 <= o.charCodeAt(s) && o.charCodeAt(s) <= 70)
      n *= 16, n += o.charCodeAt(s) - A2 + 10;
    else
      break;
    if (n >= 16777215)
      return {
        n: 0,
        c: s,
        ok: !1
      };
  }
  return s === 0 ? {
    n: 0,
    c: s,
    ok: !1
  } : {
    n,
    c: s,
    ok: !0
  };
}
function F2(o) {
  return o.indexOf("[") !== -1 || o.indexOf("::") !== -1 ? !1 : o.indexOf(".") !== -1 || o.split(":").length <= 2;
}
function Sw(o) {
  return !F2(o);
}
function I2(o) {
  const n = "::FFFF:", s = o.toUpperCase().indexOf(n);
  if (s !== -1 && o.indexOf(".") !== -1) {
    let l = o.substring(s + n.length);
    return l = l.replace("[", ""), l.replace("]", "");
  }
  return o;
}
function z2(o) {
  o = o.trim(), o.match(/^(.*:\/\/)(.*)/m) && (o = o.replace(/^(.*:\/\/)(.*)/gm, "$2")), o = I2(o), Sw(o) && o.indexOf("[") === -1 && (o = `[${o}]`);
  const n = Sw(o) ? o.match(/(]:)(\d+)/) : o.match(/(:)(\d+)/), s = n && n.length === 3 && n[1] && n[2] ? parseInt(n[2]) : 4222, l = s === 80 ? "https" : "http", d = new URL(`${l}://${o}`);
  d.port = `${s}`;
  let v = d.hostname;
  return v.charAt(0) === "[" && (v = v.substring(1, v.length - 1)), {
    listen: d.host,
    hostname: v,
    port: s
  };
}
class Rm {
  src;
  listen;
  hostname;
  port;
  didConnect;
  reconnects;
  lastConnect;
  gossiped;
  tlsName;
  resolves;
  constructor(n, s = !1) {
    this.src = n, this.tlsName = "";
    const l = z2(n);
    this.listen = l.listen, this.hostname = l.hostname, this.port = l.port, this.didConnect = !1, this.reconnects = 0, this.lastConnect = 0, this.gossiped = s;
  }
  toString() {
    return this.listen;
  }
  async resolve(n) {
    if (!n.fn || n.resolve === !1)
      return [
        this
      ];
    const s = [];
    if (bw(this.hostname))
      return [
        this
      ];
    {
      const l = await n.fn(this.hostname);
      n.debug && console.log(`resolve ${this.hostname} = ${l.join(",")}`);
      for (const d of l) {
        const v = this.port === 80 ? "https" : "http", p = new URL(`${v}://${Sw(d) ? "[" + d + "]" : d}`);
        p.port = `${this.port}`;
        const E = new Rm(p.host, !1);
        E.tlsName = this.hostname, s.push(E);
      }
    }
    return n.randomize && _T(s), this.resolves = s, s;
  }
}
class $2 {
  firstSelect;
  servers;
  currentServer;
  tlsName;
  randomize;
  constructor(n = [], s = {}) {
    this.firstSelect = !0, this.servers = [], this.tlsName = "", this.randomize = s.randomize || !1;
    const l = GE();
    n && (n.forEach((d) => {
      d = l ? l(d) : d, this.servers.push(new Rm(d));
    }), this.randomize && (this.servers = _T(this.servers))), this.servers.length === 0 && this.addServer(`${dw}:${AT()}`, !1), this.currentServer = this.servers[0];
  }
  clear() {
    this.servers.length = 0;
  }
  updateTLSName() {
    const n = this.getCurrentServer();
    bw(n.hostname) || (this.tlsName = n.hostname, this.servers.forEach((s) => {
      s.gossiped && (s.tlsName = this.tlsName);
    }));
  }
  getCurrentServer() {
    return this.currentServer;
  }
  addServer(n, s = !1) {
    const l = GE();
    n = l ? l(n) : n;
    const d = new Rm(n, s);
    bw(d.hostname) && (d.tlsName = this.tlsName), this.servers.push(d);
  }
  selectServer() {
    if (this.firstSelect)
      return this.firstSelect = !1, this.currentServer;
    const n = this.servers.shift();
    return n && (this.servers.push(n), this.currentServer = n), n;
  }
  removeCurrentServer() {
    this.removeServer(this.currentServer);
  }
  removeServer(n) {
    if (n) {
      const s = this.servers.indexOf(n);
      this.servers.splice(s, 1);
    }
  }
  length() {
    return this.servers.length;
  }
  next() {
    return this.servers.length ? this.servers[0] : void 0;
  }
  getServers() {
    return this.servers;
  }
  update(n, s) {
    const l = [];
    let d = [];
    const v = GE(), p = /* @__PURE__ */ new Map();
    n.connect_urls && n.connect_urls.length > 0 && n.connect_urls.forEach((_) => {
      _ = v ? v(_, s) : _;
      const x = new Rm(_, !0);
      p.set(_, x);
    });
    const E = [];
    return this.servers.forEach((_, x) => {
      const N = _.listen;
      _.gossiped && this.currentServer.listen !== N && p.get(N) === void 0 && E.push(x), p.delete(N);
    }), E.reverse(), E.forEach((_) => {
      const x = this.servers.splice(_, 1);
      d = d.concat(x[0].listen);
    }), p.forEach((_, x) => {
      this.servers.push(_), l.push(x);
    }), {
      added: l,
      deleted: d
    };
  }
}
class B2 {
  baseInbox;
  reqs;
  constructor() {
    this.reqs = /* @__PURE__ */ new Map();
  }
  size() {
    return this.reqs.size;
  }
  init(n) {
    return this.baseInbox = `${Pl(n)}.`, this.baseInbox;
  }
  add(n) {
    isNaN(n.received) || (n.received = 0), this.reqs.set(n.token, n);
  }
  get(n) {
    return this.reqs.get(n);
  }
  cancel(n) {
    this.reqs.delete(n.token);
  }
  getToken(n) {
    const s = n.subject || "";
    return s.indexOf(this.baseInbox) === 0 ? s.substring(this.baseInbox.length) : null;
  }
  all() {
    return Array.from(this.reqs.values());
  }
  handleError(n, s) {
    if (s && s.permissionContext) {
      if (n)
        return this.all().forEach((d) => {
          d.resolver(s, {});
        }), !0;
      const l = s.permissionContext;
      if (l.operation === "publish") {
        const d = this.all().find((v) => v.requestSubject === l.subject);
        if (d)
          return d.resolver(s, {}), !0;
      }
    }
    return !1;
  }
  dispatcher() {
    return (n, s) => {
      const l = this.getToken(s);
      if (l) {
        const d = this.get(l);
        d && (n === null && s.headers && (n = xT(s)), d.resolver(n, s));
      }
    };
  }
  close() {
    const n = nt.errorForCode(je.Timeout);
    this.reqs.forEach((s) => {
      s.resolver(n, {});
    });
  }
}
class H2 {
  ph;
  interval;
  maxOut;
  timer;
  pendings;
  constructor(n, s, l) {
    this.ph = n, this.interval = s, this.maxOut = l, this.pendings = [];
  }
  start() {
    this.cancel(), this._schedule();
  }
  cancel(n) {
    this.timer && (clearTimeout(this.timer), this.timer = void 0), this._reset(), n && this.ph.disconnect();
  }
  _schedule() {
    this.timer = setTimeout(() => {
      if (this.ph.dispatchStatus({
        type: Qd.PingTimer,
        data: `${this.pendings.length + 1}`
      }), this.pendings.length === this.maxOut) {
        this.cancel(!0);
        return;
      }
      const n = nr();
      this.ph.flush(n).then(() => {
        this._reset();
      }).catch(() => {
        this.cancel();
      }), this.pendings.push(n), this._schedule();
    }, this.interval);
  }
  _reset() {
    this.pendings = this.pendings.filter((n) => (n.resolve(), !1));
  }
}
class V2 extends Error {
  constructor(n) {
    super(n), this.name = "AssertionError";
  }
}
function q2(o, n = "Assertion failed.") {
  if (!o)
    throw new V2(n);
}
const S1 = 32 * 1024, JE = 2 ** 32 - 2;
function $y(o, n, s = 0) {
  const l = n.byteLength - s;
  return o.byteLength > l && (o = o.subarray(0, l)), n.set(o, s), o.byteLength;
}
class QE {
  _buf;
  _off;
  constructor(n) {
    if (this._off = 0, n == null) {
      this._buf = new Uint8Array(0);
      return;
    }
    this._buf = new Uint8Array(n);
  }
  bytes(n = {
    copy: !0
  }) {
    return n.copy === !1 ? this._buf.subarray(this._off) : this._buf.slice(this._off);
  }
  empty() {
    return this._buf.byteLength <= this._off;
  }
  get length() {
    return this._buf.byteLength - this._off;
  }
  get capacity() {
    return this._buf.buffer.byteLength;
  }
  truncate(n) {
    if (n === 0) {
      this.reset();
      return;
    }
    if (n < 0 || n > this.length)
      throw Error("bytes.Buffer: truncation out of range");
    this._reslice(this._off + n);
  }
  reset() {
    this._reslice(0), this._off = 0;
  }
  _tryGrowByReslice(n) {
    const s = this._buf.byteLength;
    return n <= this.capacity - s ? (this._reslice(s + n), s) : -1;
  }
  _reslice(n) {
    q2(n <= this._buf.buffer.byteLength), this._buf = new Uint8Array(this._buf.buffer, 0, n);
  }
  readByte() {
    const n = new Uint8Array(1);
    return this.read(n) ? n[0] : null;
  }
  read(n) {
    if (this.empty())
      return this.reset(), n.byteLength === 0 ? 0 : null;
    const s = $y(this._buf.subarray(this._off), n);
    return this._off += s, s;
  }
  writeByte(n) {
    return this.write(Uint8Array.of(n));
  }
  writeString(n) {
    return this.write(sf.encode(n));
  }
  write(n) {
    const s = this._grow(n.byteLength);
    return $y(n, this._buf, s);
  }
  _grow(n) {
    const s = this.length;
    s === 0 && this._off !== 0 && this.reset();
    const l = this._tryGrowByReslice(n);
    if (l >= 0)
      return l;
    const d = this.capacity;
    if (n <= Math.floor(d / 2) - s)
      $y(this._buf.subarray(this._off), this._buf);
    else {
      if (d + n > JE)
        throw new Error("The buffer cannot be grown beyond the maximum size.");
      {
        const v = new Uint8Array(Math.min(2 * d + n, JE));
        $y(this._buf.subarray(this._off), v), this._buf = v;
      }
    }
    return this._off = 0, this._reslice(Math.min(s + n, JE)), s;
  }
  grow(n) {
    if (n < 0)
      throw Error("Buffer._grow: negative count");
    const s = this._grow(n);
    this._reslice(s);
  }
  readFrom(n) {
    let s = 0;
    const l = new Uint8Array(S1);
    for (; ; ) {
      const d = this.capacity - this.length < S1, v = d ? l : new Uint8Array(this._buf.buffer, this.length), p = n.read(v);
      if (p === null)
        return s;
      d ? this.write(v.subarray(0, p)) : this._reslice(this.length + p), s += p;
    }
  }
}
var aa;
(function(o) {
  o[o.OK = 0] = "OK", o[o.ERR = 1] = "ERR", o[o.MSG = 2] = "MSG", o[o.INFO = 3] = "INFO", o[o.PING = 4] = "PING", o[o.PONG = 5] = "PONG";
})(aa || (aa = {}));
function E1() {
  const o = {};
  return o.sid = -1, o.hdr = -1, o.size = -1, o;
}
const Y2 = 48;
class w1 {
  dispatcher;
  state;
  as;
  drop;
  hdr;
  ma;
  argBuf;
  msgBuf;
  constructor(n) {
    this.dispatcher = n, this.state = ze.OP_START, this.as = 0, this.drop = 0, this.hdr = 0;
  }
  parse(n) {
    let s;
    for (s = 0; s < n.length; s++) {
      const l = n[s];
      switch (this.state) {
        case ze.OP_START:
          switch (l) {
            case $e.M:
            case $e.m:
              this.state = ze.OP_M, this.hdr = -1, this.ma = E1();
              break;
            case $e.H:
            case $e.h:
              this.state = ze.OP_H, this.hdr = 0, this.ma = E1();
              break;
            case $e.P:
            case $e.p:
              this.state = ze.OP_P;
              break;
            case $e.PLUS:
              this.state = ze.OP_PLUS;
              break;
            case $e.MINUS:
              this.state = ze.OP_MINUS;
              break;
            case $e.I:
            case $e.i:
              this.state = ze.OP_I;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_H:
          switch (l) {
            case $e.M:
            case $e.m:
              this.state = ze.OP_M;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_M:
          switch (l) {
            case $e.S:
            case $e.s:
              this.state = ze.OP_MS;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_MS:
          switch (l) {
            case $e.G:
            case $e.g:
              this.state = ze.OP_MSG;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_MSG:
          switch (l) {
            case $e.SPACE:
            case $e.TAB:
              this.state = ze.OP_MSG_SPC;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_MSG_SPC:
          switch (l) {
            case $e.SPACE:
            case $e.TAB:
              continue;
            default:
              this.state = ze.MSG_ARG, this.as = s;
          }
          break;
        case ze.MSG_ARG:
          switch (l) {
            case $e.CR:
              this.drop = 1;
              break;
            case $e.NL: {
              const d = this.argBuf ? this.argBuf.bytes() : n.subarray(this.as, s - this.drop);
              this.processMsgArgs(d), this.drop = 0, this.as = s + 1, this.state = ze.MSG_PAYLOAD, s = this.as + this.ma.size - 1;
              break;
            }
            default:
              this.argBuf && this.argBuf.writeByte(l);
          }
          break;
        case ze.MSG_PAYLOAD:
          if (this.msgBuf)
            if (this.msgBuf.length >= this.ma.size) {
              const d = this.msgBuf.bytes({
                copy: !1
              });
              this.dispatcher.push({
                kind: aa.MSG,
                msg: this.ma,
                data: d
              }), this.argBuf = void 0, this.msgBuf = void 0, this.state = ze.MSG_END;
            } else {
              let d = this.ma.size - this.msgBuf.length;
              const v = n.length - s;
              v < d && (d = v), d > 0 ? (this.msgBuf.write(n.subarray(s, s + d)), s = s + d - 1) : this.msgBuf.writeByte(l);
            }
          else s - this.as >= this.ma.size && (this.dispatcher.push({
            kind: aa.MSG,
            msg: this.ma,
            data: n.subarray(this.as, s)
          }), this.argBuf = void 0, this.msgBuf = void 0, this.state = ze.MSG_END);
          break;
        case ze.MSG_END:
          switch (l) {
            case $e.NL:
              this.drop = 0, this.as = s + 1, this.state = ze.OP_START;
              break;
            default:
              continue;
          }
          break;
        case ze.OP_PLUS:
          switch (l) {
            case $e.O:
            case $e.o:
              this.state = ze.OP_PLUS_O;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_PLUS_O:
          switch (l) {
            case $e.K:
            case $e.k:
              this.state = ze.OP_PLUS_OK;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_PLUS_OK:
          switch (l) {
            case $e.NL:
              this.dispatcher.push({
                kind: aa.OK
              }), this.drop = 0, this.state = ze.OP_START;
              break;
          }
          break;
        case ze.OP_MINUS:
          switch (l) {
            case $e.E:
            case $e.e:
              this.state = ze.OP_MINUS_E;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_MINUS_E:
          switch (l) {
            case $e.R:
            case $e.r:
              this.state = ze.OP_MINUS_ER;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_MINUS_ER:
          switch (l) {
            case $e.R:
            case $e.r:
              this.state = ze.OP_MINUS_ERR;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_MINUS_ERR:
          switch (l) {
            case $e.SPACE:
            case $e.TAB:
              this.state = ze.OP_MINUS_ERR_SPC;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_MINUS_ERR_SPC:
          switch (l) {
            case $e.SPACE:
            case $e.TAB:
              continue;
            default:
              this.state = ze.MINUS_ERR_ARG, this.as = s;
          }
          break;
        case ze.MINUS_ERR_ARG:
          switch (l) {
            case $e.CR:
              this.drop = 1;
              break;
            case $e.NL: {
              let d;
              this.argBuf ? (d = this.argBuf.bytes(), this.argBuf = void 0) : d = n.subarray(this.as, s - this.drop), this.dispatcher.push({
                kind: aa.ERR,
                data: d
              }), this.drop = 0, this.as = s + 1, this.state = ze.OP_START;
              break;
            }
            default:
              this.argBuf && this.argBuf.write(Uint8Array.of(l));
          }
          break;
        case ze.OP_P:
          switch (l) {
            case $e.I:
            case $e.i:
              this.state = ze.OP_PI;
              break;
            case $e.O:
            case $e.o:
              this.state = ze.OP_PO;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_PO:
          switch (l) {
            case $e.N:
            case $e.n:
              this.state = ze.OP_PON;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_PON:
          switch (l) {
            case $e.G:
            case $e.g:
              this.state = ze.OP_PONG;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_PONG:
          switch (l) {
            case $e.NL:
              this.dispatcher.push({
                kind: aa.PONG
              }), this.drop = 0, this.state = ze.OP_START;
              break;
          }
          break;
        case ze.OP_PI:
          switch (l) {
            case $e.N:
            case $e.n:
              this.state = ze.OP_PIN;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_PIN:
          switch (l) {
            case $e.G:
            case $e.g:
              this.state = ze.OP_PING;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_PING:
          switch (l) {
            case $e.NL:
              this.dispatcher.push({
                kind: aa.PING
              }), this.drop = 0, this.state = ze.OP_START;
              break;
          }
          break;
        case ze.OP_I:
          switch (l) {
            case $e.N:
            case $e.n:
              this.state = ze.OP_IN;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_IN:
          switch (l) {
            case $e.F:
            case $e.f:
              this.state = ze.OP_INF;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_INF:
          switch (l) {
            case $e.O:
            case $e.o:
              this.state = ze.OP_INFO;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_INFO:
          switch (l) {
            case $e.SPACE:
            case $e.TAB:
              this.state = ze.OP_INFO_SPC;
              break;
            default:
              throw this.fail(n.subarray(s));
          }
          break;
        case ze.OP_INFO_SPC:
          switch (l) {
            case $e.SPACE:
            case $e.TAB:
              continue;
            default:
              this.state = ze.INFO_ARG, this.as = s;
          }
          break;
        case ze.INFO_ARG:
          switch (l) {
            case $e.CR:
              this.drop = 1;
              break;
            case $e.NL: {
              let d;
              this.argBuf ? (d = this.argBuf.bytes(), this.argBuf = void 0) : d = n.subarray(this.as, s - this.drop), this.dispatcher.push({
                kind: aa.INFO,
                data: d
              }), this.drop = 0, this.as = s + 1, this.state = ze.OP_START;
              break;
            }
            default:
              this.argBuf && this.argBuf.writeByte(l);
          }
          break;
        default:
          throw this.fail(n.subarray(s));
      }
    }
    (this.state === ze.MSG_ARG || this.state === ze.MINUS_ERR_ARG || this.state === ze.INFO_ARG) && !this.argBuf && (this.argBuf = new QE(n.subarray(this.as, s - this.drop))), this.state === ze.MSG_PAYLOAD && !this.msgBuf && (this.argBuf || this.cloneMsgArg(), this.msgBuf = new QE(n.subarray(this.as)));
  }
  cloneMsgArg() {
    const n = this.ma.subject.length, s = this.ma.reply ? this.ma.reply.length : 0, l = new Uint8Array(n + s);
    l.set(this.ma.subject), this.ma.reply && l.set(this.ma.reply, n), this.argBuf = new QE(l), this.ma.subject = l.subarray(0, n), this.ma.reply && (this.ma.reply = l.subarray(n));
  }
  processMsgArgs(n) {
    if (this.hdr >= 0)
      return this.processHeaderMsgArgs(n);
    const s = [];
    let l = -1;
    for (let d = 0; d < n.length; d++)
      switch (n[d]) {
        case $e.SPACE:
        case $e.TAB:
        case $e.CR:
        case $e.NL:
          l >= 0 && (s.push(n.subarray(l, d)), l = -1);
          break;
        default:
          l < 0 && (l = d);
      }
    switch (l >= 0 && s.push(n.subarray(l)), s.length) {
      case 3:
        this.ma.subject = s[0], this.ma.sid = this.protoParseInt(s[1]), this.ma.reply = void 0, this.ma.size = this.protoParseInt(s[2]);
        break;
      case 4:
        this.ma.subject = s[0], this.ma.sid = this.protoParseInt(s[1]), this.ma.reply = s[2], this.ma.size = this.protoParseInt(s[3]);
        break;
      default:
        throw this.fail(n, "processMsgArgs Parse Error");
    }
    if (this.ma.sid < 0)
      throw this.fail(n, "processMsgArgs Bad or Missing Sid Error");
    if (this.ma.size < 0)
      throw this.fail(n, "processMsgArgs Bad or Missing Size Error");
  }
  fail(n, s = "") {
    return s ? s = `${s} [${this.state}]` : s = `parse error [${this.state}]`, new Error(`${s}: ${Qa.decode(n)}`);
  }
  processHeaderMsgArgs(n) {
    const s = [];
    let l = -1;
    for (let d = 0; d < n.length; d++)
      switch (n[d]) {
        case $e.SPACE:
        case $e.TAB:
        case $e.CR:
        case $e.NL:
          l >= 0 && (s.push(n.subarray(l, d)), l = -1);
          break;
        default:
          l < 0 && (l = d);
      }
    switch (l >= 0 && s.push(n.subarray(l)), s.length) {
      case 4:
        this.ma.subject = s[0], this.ma.sid = this.protoParseInt(s[1]), this.ma.reply = void 0, this.ma.hdr = this.protoParseInt(s[2]), this.ma.size = this.protoParseInt(s[3]);
        break;
      case 5:
        this.ma.subject = s[0], this.ma.sid = this.protoParseInt(s[1]), this.ma.reply = s[2], this.ma.hdr = this.protoParseInt(s[3]), this.ma.size = this.protoParseInt(s[4]);
        break;
      default:
        throw this.fail(n, "processHeaderMsgArgs Parse Error");
    }
    if (this.ma.sid < 0)
      throw this.fail(n, "processHeaderMsgArgs Bad or Missing Sid Error");
    if (this.ma.hdr < 0 || this.ma.hdr > this.ma.size)
      throw this.fail(n, "processHeaderMsgArgs Bad or Missing Header Size Error");
    if (this.ma.size < 0)
      throw this.fail(n, "processHeaderMsgArgs Bad or Missing Size Error");
  }
  protoParseInt(n) {
    if (n.length === 0)
      return -1;
    let s = 0;
    for (let l = 0; l < n.length; l++) {
      if (n[l] < 48 || n[l] > 57)
        return -1;
      s = s * 10 + (n[l] - Y2);
    }
    return s;
  }
}
var ze;
(function(o) {
  o[o.OP_START = 0] = "OP_START", o[o.OP_PLUS = 1] = "OP_PLUS", o[o.OP_PLUS_O = 2] = "OP_PLUS_O", o[o.OP_PLUS_OK = 3] = "OP_PLUS_OK", o[o.OP_MINUS = 4] = "OP_MINUS", o[o.OP_MINUS_E = 5] = "OP_MINUS_E", o[o.OP_MINUS_ER = 6] = "OP_MINUS_ER", o[o.OP_MINUS_ERR = 7] = "OP_MINUS_ERR", o[o.OP_MINUS_ERR_SPC = 8] = "OP_MINUS_ERR_SPC", o[o.MINUS_ERR_ARG = 9] = "MINUS_ERR_ARG", o[o.OP_M = 10] = "OP_M", o[o.OP_MS = 11] = "OP_MS", o[o.OP_MSG = 12] = "OP_MSG", o[o.OP_MSG_SPC = 13] = "OP_MSG_SPC", o[o.MSG_ARG = 14] = "MSG_ARG", o[o.MSG_PAYLOAD = 15] = "MSG_PAYLOAD", o[o.MSG_END = 16] = "MSG_END", o[o.OP_H = 17] = "OP_H", o[o.OP_P = 18] = "OP_P", o[o.OP_PI = 19] = "OP_PI", o[o.OP_PIN = 20] = "OP_PIN", o[o.OP_PING = 21] = "OP_PING", o[o.OP_PO = 22] = "OP_PO", o[o.OP_PON = 23] = "OP_PON", o[o.OP_PONG = 24] = "OP_PONG", o[o.OP_I = 25] = "OP_I", o[o.OP_IN = 26] = "OP_IN", o[o.OP_INF = 27] = "OP_INF", o[o.OP_INFO = 28] = "OP_INFO", o[o.OP_INFO_SPC = 29] = "OP_INFO_SPC", o[o.INFO_ARG = 30] = "INFO_ARG";
})(ze || (ze = {}));
var $e;
(function(o) {
  o[o.CR = 13] = "CR", o[o.E = 69] = "E", o[o.e = 101] = "e", o[o.F = 70] = "F", o[o.f = 102] = "f", o[o.G = 71] = "G", o[o.g = 103] = "g", o[o.H = 72] = "H", o[o.h = 104] = "h", o[o.I = 73] = "I", o[o.i = 105] = "i", o[o.K = 75] = "K", o[o.k = 107] = "k", o[o.M = 77] = "M", o[o.m = 109] = "m", o[o.MINUS = 45] = "MINUS", o[o.N = 78] = "N", o[o.n = 110] = "n", o[o.NL = 10] = "NL", o[o.O = 79] = "O", o[o.o = 111] = "o", o[o.P = 80] = "P", o[o.p = 112] = "p", o[o.PLUS = 43] = "PLUS", o[o.R = 82] = "R", o[o.r = 114] = "r", o[o.S = 83] = "S", o[o.s = 115] = "s", o[o.SPACE = 32] = "SPACE", o[o.TAB = 9] = "TAB";
})($e || ($e = {}));
(function(o) {
  var n = function(T, j) {
    this.hi = T | 0, this.lo = j | 0;
  }, s = function(T) {
    var j, A = new Float64Array(16);
    if (T) for (j = 0; j < T.length; j++) A[j] = T[j];
    return A;
  }, l = function() {
    throw new Error("no PRNG");
  }, d = new Uint8Array(16), v = new Uint8Array(32);
  v[0] = 9;
  var p = s(), E = s([
    1
  ]), _ = s([
    56129,
    1
  ]), x = s([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), N = s([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), O = s([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), P = s([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), z = s([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function B(T, j) {
    return T << j | T >>> 32 - j;
  }
  function ie(T, j) {
    var A = T[j + 3] & 255;
    return A = A << 8 | T[j + 2] & 255, A = A << 8 | T[j + 1] & 255, A << 8 | T[j + 0] & 255;
  }
  function K(T, j) {
    var A = T[j] << 24 | T[j + 1] << 16 | T[j + 2] << 8 | T[j + 3], D = T[j + 4] << 24 | T[j + 5] << 16 | T[j + 6] << 8 | T[j + 7];
    return new n(A, D);
  }
  function be(T, j, A) {
    var D;
    for (D = 0; D < 4; D++)
      T[j + D] = A & 255, A >>>= 8;
  }
  function ae(T, j, A) {
    T[j] = A.hi >> 24 & 255, T[j + 1] = A.hi >> 16 & 255, T[j + 2] = A.hi >> 8 & 255, T[j + 3] = A.hi & 255, T[j + 4] = A.lo >> 24 & 255, T[j + 5] = A.lo >> 16 & 255, T[j + 6] = A.lo >> 8 & 255, T[j + 7] = A.lo & 255;
  }
  function ve(T, j, A, D, U) {
    var W, he = 0;
    for (W = 0; W < U; W++) he |= T[j + W] ^ A[D + W];
    return (1 & he - 1 >>> 8) - 1;
  }
  function De(T, j, A, D) {
    return ve(T, j, A, D, 16);
  }
  function Re(T, j, A, D) {
    return ve(T, j, A, D, 32);
  }
  function lt(T, j, A, D, U) {
    var W = new Uint32Array(16), he = new Uint32Array(16), ge = new Uint32Array(16), Z = new Uint32Array(4), de, qe, xt;
    for (de = 0; de < 4; de++)
      he[5 * de] = ie(D, 4 * de), he[1 + de] = ie(A, 4 * de), he[6 + de] = ie(j, 4 * de), he[11 + de] = ie(A, 16 + 4 * de);
    for (de = 0; de < 16; de++) ge[de] = he[de];
    for (de = 0; de < 20; de++) {
      for (qe = 0; qe < 4; qe++) {
        for (xt = 0; xt < 4; xt++) Z[xt] = he[(5 * qe + 4 * xt) % 16];
        for (Z[1] ^= B(Z[0] + Z[3] | 0, 7), Z[2] ^= B(Z[1] + Z[0] | 0, 9), Z[3] ^= B(Z[2] + Z[1] | 0, 13), Z[0] ^= B(Z[3] + Z[2] | 0, 18), xt = 0; xt < 4; xt++) W[4 * qe + (qe + xt) % 4] = Z[xt];
      }
      for (xt = 0; xt < 16; xt++) he[xt] = W[xt];
    }
    if (U) {
      for (de = 0; de < 16; de++) he[de] = he[de] + ge[de] | 0;
      for (de = 0; de < 4; de++)
        he[5 * de] = he[5 * de] - ie(D, 4 * de) | 0, he[6 + de] = he[6 + de] - ie(j, 4 * de) | 0;
      for (de = 0; de < 4; de++)
        be(T, 4 * de, he[5 * de]), be(T, 16 + 4 * de, he[6 + de]);
    } else
      for (de = 0; de < 16; de++) be(T, 4 * de, he[de] + ge[de] | 0);
  }
  function Ve(T, j, A, D) {
    return lt(T, j, A, D, !1), 0;
  }
  function wt(T, j, A, D) {
    return lt(T, j, A, D, !0), 0;
  }
  var Rt = new Uint8Array([
    101,
    120,
    112,
    97,
    110,
    100,
    32,
    51,
    50,
    45,
    98,
    121,
    116,
    101,
    32,
    107
  ]);
  function zt(T, j, A, D, U, W, he) {
    var ge = new Uint8Array(16), Z = new Uint8Array(64), de, qe;
    if (!U) return 0;
    for (qe = 0; qe < 16; qe++) ge[qe] = 0;
    for (qe = 0; qe < 8; qe++) ge[qe] = W[qe];
    for (; U >= 64; ) {
      for (Ve(Z, ge, he, Rt), qe = 0; qe < 64; qe++) T[j + qe] = (A ? A[D + qe] : 0) ^ Z[qe];
      for (de = 1, qe = 8; qe < 16; qe++)
        de = de + (ge[qe] & 255) | 0, ge[qe] = de & 255, de >>>= 8;
      U -= 64, j += 64, A && (D += 64);
    }
    if (U > 0)
      for (Ve(Z, ge, he, Rt), qe = 0; qe < U; qe++) T[j + qe] = (A ? A[D + qe] : 0) ^ Z[qe];
    return 0;
  }
  function it(T, j, A, D, U) {
    return zt(T, j, null, 0, A, D, U);
  }
  function Bt(T, j, A, D, U) {
    var W = new Uint8Array(32);
    return wt(W, D, U, Rt), it(T, j, A, D.subarray(16), W);
  }
  function Ke(T, j, A, D, U, W, he) {
    var ge = new Uint8Array(32);
    return wt(ge, W, he, Rt), zt(T, j, A, D, U, W.subarray(16), ge);
  }
  function Jt(T, j) {
    var A, D = 0;
    for (A = 0; A < 17; A++)
      D = D + (T[A] + j[A] | 0) | 0, T[A] = D & 255, D >>>= 8;
  }
  var jt = new Uint32Array([
    5,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    252
  ]);
  function Ht(T, j, A, D, U, W) {
    var he, ge, Z, de, qe = new Uint32Array(17), xt = new Uint32Array(17), En = new Uint32Array(17), Dn = new Uint32Array(17), Da = new Uint32Array(17);
    for (Z = 0; Z < 17; Z++) xt[Z] = En[Z] = 0;
    for (Z = 0; Z < 16; Z++) xt[Z] = W[Z];
    for (xt[3] &= 15, xt[4] &= 252, xt[7] &= 15, xt[8] &= 252, xt[11] &= 15, xt[12] &= 252, xt[15] &= 15; U > 0; ) {
      for (Z = 0; Z < 17; Z++) Dn[Z] = 0;
      for (Z = 0; Z < 16 && Z < U; ++Z) Dn[Z] = A[D + Z];
      for (Dn[Z] = 1, D += Z, U -= Z, Jt(En, Dn), ge = 0; ge < 17; ge++)
        for (qe[ge] = 0, Z = 0; Z < 17; Z++) qe[ge] = qe[ge] + En[Z] * (Z <= ge ? xt[ge - Z] : 320 * xt[ge + 17 - Z] | 0) | 0 | 0;
      for (ge = 0; ge < 17; ge++) En[ge] = qe[ge];
      for (de = 0, Z = 0; Z < 16; Z++)
        de = de + En[Z] | 0, En[Z] = de & 255, de >>>= 8;
      for (de = de + En[16] | 0, En[16] = de & 3, de = 5 * (de >>> 2) | 0, Z = 0; Z < 16; Z++)
        de = de + En[Z] | 0, En[Z] = de & 255, de >>>= 8;
      de = de + En[16] | 0, En[16] = de;
    }
    for (Z = 0; Z < 17; Z++) Da[Z] = En[Z];
    for (Jt(En, jt), he = -(En[16] >>> 7) | 0, Z = 0; Z < 17; Z++) En[Z] ^= he & (Da[Z] ^ En[Z]);
    for (Z = 0; Z < 16; Z++) Dn[Z] = W[Z + 16];
    for (Dn[16] = 0, Jt(En, Dn), Z = 0; Z < 16; Z++) T[j + Z] = En[Z];
    return 0;
  }
  function Ye(T, j, A, D, U, W) {
    var he = new Uint8Array(16);
    return Ht(he, 0, A, D, U, W), De(T, j, he, 0);
  }
  function Ce(T, j, A, D, U) {
    var W;
    if (A < 32) return -1;
    for (Ke(T, 0, j, 0, A, D, U), Ht(T, 16, T, 32, A - 32, T), W = 0; W < 16; W++) T[W] = 0;
    return 0;
  }
  function Ze(T, j, A, D, U) {
    var W, he = new Uint8Array(32);
    if (A < 32 || (Bt(he, 0, 32, D, U), Ye(j, 16, j, 32, A - 32, he) !== 0)) return -1;
    for (Ke(T, 0, j, 0, A, D, U), W = 0; W < 32; W++) T[W] = 0;
    return 0;
  }
  function ke(T, j) {
    var A;
    for (A = 0; A < 16; A++) T[A] = j[A] | 0;
  }
  function Y(T) {
    var j, A;
    for (A = 0; A < 16; A++)
      T[A] += 65536, j = Math.floor(T[A] / 65536), T[(A + 1) * (A < 15 ? 1 : 0)] += j - 1 + 37 * (j - 1) * (A === 15 ? 1 : 0), T[A] -= j * 65536;
  }
  function ue(T, j, A) {
    for (var D, U = ~(A - 1), W = 0; W < 16; W++)
      D = U & (T[W] ^ j[W]), T[W] ^= D, j[W] ^= D;
  }
  function st(T, j) {
    var A, D, U, W = s(), he = s();
    for (A = 0; A < 16; A++) he[A] = j[A];
    for (Y(he), Y(he), Y(he), D = 0; D < 2; D++) {
      for (W[0] = he[0] - 65517, A = 1; A < 15; A++)
        W[A] = he[A] - 65535 - (W[A - 1] >> 16 & 1), W[A - 1] &= 65535;
      W[15] = he[15] - 32767 - (W[14] >> 16 & 1), U = W[15] >> 16 & 1, W[14] &= 65535, ue(he, W, 1 - U);
    }
    for (A = 0; A < 16; A++)
      T[2 * A] = he[A] & 255, T[2 * A + 1] = he[A] >> 8;
  }
  function dt(T, j) {
    var A = new Uint8Array(32), D = new Uint8Array(32);
    return st(A, T), st(D, j), Re(A, 0, D, 0);
  }
  function ot(T) {
    var j = new Uint8Array(32);
    return st(j, T), j[0] & 1;
  }
  function Ot(T, j) {
    var A;
    for (A = 0; A < 16; A++) T[A] = j[2 * A] + (j[2 * A + 1] << 8);
    T[15] &= 32767;
  }
  function ct(T, j, A) {
    var D;
    for (D = 0; D < 16; D++) T[D] = j[D] + A[D] | 0;
  }
  function ht(T, j, A) {
    var D;
    for (D = 0; D < 16; D++) T[D] = j[D] - A[D] | 0;
  }
  function Ae(T, j, A) {
    var D, U, W = new Float64Array(31);
    for (D = 0; D < 31; D++) W[D] = 0;
    for (D = 0; D < 16; D++)
      for (U = 0; U < 16; U++)
        W[D + U] += j[D] * A[U];
    for (D = 0; D < 15; D++)
      W[D] += 38 * W[D + 16];
    for (D = 0; D < 16; D++) T[D] = W[D];
    Y(T), Y(T);
  }
  function Lt(T, j) {
    Ae(T, j, j);
  }
  function Un(T, j) {
    var A = s(), D;
    for (D = 0; D < 16; D++) A[D] = j[D];
    for (D = 253; D >= 0; D--)
      Lt(A, A), D !== 2 && D !== 4 && Ae(A, A, j);
    for (D = 0; D < 16; D++) T[D] = A[D];
  }
  function dr(T, j) {
    var A = s(), D;
    for (D = 0; D < 16; D++) A[D] = j[D];
    for (D = 250; D >= 0; D--)
      Lt(A, A), D !== 1 && Ae(A, A, j);
    for (D = 0; D < 16; D++) T[D] = A[D];
  }
  function wn(T, j, A) {
    var D = new Uint8Array(32), U = new Float64Array(80), W, he, ge = s(), Z = s(), de = s(), qe = s(), xt = s(), En = s();
    for (he = 0; he < 31; he++) D[he] = j[he];
    for (D[31] = j[31] & 127 | 64, D[0] &= 248, Ot(U, A), he = 0; he < 16; he++)
      Z[he] = U[he], qe[he] = ge[he] = de[he] = 0;
    for (ge[0] = qe[0] = 1, he = 254; he >= 0; --he)
      W = D[he >>> 3] >>> (he & 7) & 1, ue(ge, Z, W), ue(de, qe, W), ct(xt, ge, de), ht(ge, ge, de), ct(de, Z, qe), ht(Z, Z, qe), Lt(qe, xt), Lt(En, ge), Ae(ge, de, ge), Ae(de, Z, xt), ct(xt, ge, de), ht(ge, ge, de), Lt(Z, ge), ht(de, qe, En), Ae(ge, de, _), ct(ge, ge, qe), Ae(de, de, ge), Ae(ge, qe, En), Ae(qe, Z, U), Lt(Z, xt), ue(ge, Z, W), ue(de, qe, W);
    for (he = 0; he < 16; he++)
      U[he + 16] = ge[he], U[he + 32] = de[he], U[he + 48] = Z[he], U[he + 64] = qe[he];
    var Dn = U.subarray(32), Da = U.subarray(16);
    return Un(Dn, Dn), Ae(Da, Da, Dn), st(T, Da), 0;
  }
  function $n(T, j) {
    return wn(T, j, v);
  }
  function Fn(T, j) {
    return l(j, 32), $n(T, j);
  }
  function jn(T, j, A) {
    var D = new Uint8Array(32);
    return wn(D, A, j), wt(T, d, D, Rt);
  }
  var xr = Ce, wi = Ze;
  function Fr(T, j, A, D, U, W) {
    var he = new Uint8Array(32);
    return jn(he, U, W), xr(T, j, A, D, he);
  }
  function Kn(T, j, A, D, U, W) {
    var he = new Uint8Array(32);
    return jn(he, U, W), wi(T, j, A, D, he);
  }
  function Sn() {
    var T = 0, j = 0, A = 0, D = 0, U = 65535, W, he, ge;
    for (ge = 0; ge < arguments.length; ge++)
      W = arguments[ge].lo, he = arguments[ge].hi, T += W & U, j += W >>> 16, A += he & U, D += he >>> 16;
    return j += T >>> 16, A += j >>> 16, D += A >>> 16, new n(A & U | D << 16, T & U | j << 16);
  }
  function Bn(T, j) {
    return new n(T.hi >>> j, T.lo >>> j | T.hi << 32 - j);
  }
  function qn() {
    var T = 0, j = 0, A;
    for (A = 0; A < arguments.length; A++)
      T ^= arguments[A].lo, j ^= arguments[A].hi;
    return new n(j, T);
  }
  function We(T, j) {
    var A, D, U = 32 - j;
    return j < 32 ? (A = T.hi >>> j | T.lo << U, D = T.lo >>> j | T.hi << U) : j < 64 && (A = T.lo >>> j | T.hi << U, D = T.hi >>> j | T.lo << U), new n(A, D);
  }
  function Tt(T, j, A) {
    var D = T.hi & j.hi ^ ~T.hi & A.hi, U = T.lo & j.lo ^ ~T.lo & A.lo;
    return new n(D, U);
  }
  function hr(T, j, A) {
    var D = T.hi & j.hi ^ T.hi & A.hi ^ j.hi & A.hi, U = T.lo & j.lo ^ T.lo & A.lo ^ j.lo & A.lo;
    return new n(D, U);
  }
  function ai(T) {
    return qn(We(T, 28), We(T, 34), We(T, 39));
  }
  function $i(T) {
    return qn(We(T, 14), We(T, 18), We(T, 41));
  }
  function oa(T) {
    return qn(We(T, 1), We(T, 8), Bn(T, 7));
  }
  function Me(T) {
    return qn(We(T, 19), We(T, 61), Bn(T, 6));
  }
  var at = [
    new n(1116352408, 3609767458),
    new n(1899447441, 602891725),
    new n(3049323471, 3964484399),
    new n(3921009573, 2173295548),
    new n(961987163, 4081628472),
    new n(1508970993, 3053834265),
    new n(2453635748, 2937671579),
    new n(2870763221, 3664609560),
    new n(3624381080, 2734883394),
    new n(310598401, 1164996542),
    new n(607225278, 1323610764),
    new n(1426881987, 3590304994),
    new n(1925078388, 4068182383),
    new n(2162078206, 991336113),
    new n(2614888103, 633803317),
    new n(3248222580, 3479774868),
    new n(3835390401, 2666613458),
    new n(4022224774, 944711139),
    new n(264347078, 2341262773),
    new n(604807628, 2007800933),
    new n(770255983, 1495990901),
    new n(1249150122, 1856431235),
    new n(1555081692, 3175218132),
    new n(1996064986, 2198950837),
    new n(2554220882, 3999719339),
    new n(2821834349, 766784016),
    new n(2952996808, 2566594879),
    new n(3210313671, 3203337956),
    new n(3336571891, 1034457026),
    new n(3584528711, 2466948901),
    new n(113926993, 3758326383),
    new n(338241895, 168717936),
    new n(666307205, 1188179964),
    new n(773529912, 1546045734),
    new n(1294757372, 1522805485),
    new n(1396182291, 2643833823),
    new n(1695183700, 2343527390),
    new n(1986661051, 1014477480),
    new n(2177026350, 1206759142),
    new n(2456956037, 344077627),
    new n(2730485921, 1290863460),
    new n(2820302411, 3158454273),
    new n(3259730800, 3505952657),
    new n(3345764771, 106217008),
    new n(3516065817, 3606008344),
    new n(3600352804, 1432725776),
    new n(4094571909, 1467031594),
    new n(275423344, 851169720),
    new n(430227734, 3100823752),
    new n(506948616, 1363258195),
    new n(659060556, 3750685593),
    new n(883997877, 3785050280),
    new n(958139571, 3318307427),
    new n(1322822218, 3812723403),
    new n(1537002063, 2003034995),
    new n(1747873779, 3602036899),
    new n(1955562222, 1575990012),
    new n(2024104815, 1125592928),
    new n(2227730452, 2716904306),
    new n(2361852424, 442776044),
    new n(2428436474, 593698344),
    new n(2756734187, 3733110249),
    new n(3204031479, 2999351573),
    new n(3329325298, 3815920427),
    new n(3391569614, 3928383900),
    new n(3515267271, 566280711),
    new n(3940187606, 3454069534),
    new n(4118630271, 4000239992),
    new n(116418474, 1914138554),
    new n(174292421, 2731055270),
    new n(289380356, 3203993006),
    new n(460393269, 320620315),
    new n(685471733, 587496836),
    new n(852142971, 1086792851),
    new n(1017036298, 365543100),
    new n(1126000580, 2618297676),
    new n(1288033470, 3409855158),
    new n(1501505948, 4234509866),
    new n(1607167915, 987167468),
    new n(1816402316, 1246189591)
  ];
  function Pt(T, j, A) {
    var D = [], U = [], W = [], he = [], ge, Z, de;
    for (Z = 0; Z < 8; Z++) D[Z] = W[Z] = K(T, 8 * Z);
    for (var qe = 0; A >= 128; ) {
      for (Z = 0; Z < 16; Z++) he[Z] = K(j, 8 * Z + qe);
      for (Z = 0; Z < 80; Z++) {
        for (de = 0; de < 8; de++) U[de] = W[de];
        for (ge = Sn(W[7], $i(W[4]), Tt(W[4], W[5], W[6]), at[Z], he[Z % 16]), U[7] = Sn(ge, ai(W[0]), hr(W[0], W[1], W[2])), U[3] = Sn(U[3], ge), de = 0; de < 8; de++) W[(de + 1) % 8] = U[de];
        if (Z % 16 === 15)
          for (de = 0; de < 16; de++)
            he[de] = Sn(he[de], he[(de + 9) % 16], oa(he[(de + 1) % 16]), Me(he[(de + 14) % 16]));
      }
      for (Z = 0; Z < 8; Z++)
        W[Z] = Sn(W[Z], D[Z]), D[Z] = W[Z];
      qe += 128, A -= 128;
    }
    for (Z = 0; Z < 8; Z++) ae(T, 8 * Z, D[Z]);
    return A;
  }
  var sn = new Uint8Array([
    106,
    9,
    230,
    103,
    243,
    188,
    201,
    8,
    187,
    103,
    174,
    133,
    132,
    202,
    167,
    59,
    60,
    110,
    243,
    114,
    254,
    148,
    248,
    43,
    165,
    79,
    245,
    58,
    95,
    29,
    54,
    241,
    81,
    14,
    82,
    127,
    173,
    230,
    130,
    209,
    155,
    5,
    104,
    140,
    43,
    62,
    108,
    31,
    31,
    131,
    217,
    171,
    251,
    65,
    189,
    107,
    91,
    224,
    205,
    25,
    19,
    126,
    33,
    121
  ]);
  function nn(T, j, A) {
    var D = new Uint8Array(64), U = new Uint8Array(256), W, he = A;
    for (W = 0; W < 64; W++) D[W] = sn[W];
    for (Pt(D, j, A), A %= 128, W = 0; W < 256; W++) U[W] = 0;
    for (W = 0; W < A; W++) U[W] = j[he - A + W];
    for (U[A] = 128, A = 256 - 128 * (A < 112 ? 1 : 0), U[A - 9] = 0, ae(U, A - 8, new n(he / 536870912 | 0, he << 3)), Pt(D, U, A), W = 0; W < 64; W++) T[W] = D[W];
    return 0;
  }
  function _n(T, j) {
    var A = s(), D = s(), U = s(), W = s(), he = s(), ge = s(), Z = s(), de = s(), qe = s();
    ht(A, T[1], T[0]), ht(qe, j[1], j[0]), Ae(A, A, qe), ct(D, T[0], T[1]), ct(qe, j[0], j[1]), Ae(D, D, qe), Ae(U, T[3], j[3]), Ae(U, U, N), Ae(W, T[2], j[2]), ct(W, W, W), ht(he, D, A), ht(ge, W, U), ct(Z, W, U), ct(de, D, A), Ae(T[0], he, ge), Ae(T[1], de, Z), Ae(T[2], Z, ge), Ae(T[3], he, de);
  }
  function xn(T, j, A) {
    var D;
    for (D = 0; D < 4; D++)
      ue(T[D], j[D], A);
  }
  function Xn(T, j) {
    var A = s(), D = s(), U = s();
    Un(U, j[2]), Ae(A, j[0], U), Ae(D, j[1], U), st(T, D), T[31] ^= ot(A) << 7;
  }
  function gn(T, j, A) {
    var D, U;
    for (ke(T[0], p), ke(T[1], E), ke(T[2], E), ke(T[3], p), U = 255; U >= 0; --U)
      D = A[U / 8 | 0] >> (U & 7) & 1, xn(T, j, D), _n(j, T), _n(T, T), xn(T, j, D);
  }
  function on(T, j) {
    var A = [
      s(),
      s(),
      s(),
      s()
    ];
    ke(A[0], O), ke(A[1], P), ke(A[2], E), Ae(A[3], O, P), gn(T, A, j);
  }
  function un(T, j, A) {
    var D = new Uint8Array(64), U = [
      s(),
      s(),
      s(),
      s()
    ], W;
    for (A || l(j, 32), nn(D, j, 32), D[0] &= 248, D[31] &= 127, D[31] |= 64, on(U, D), Xn(T, U), W = 0; W < 32; W++) j[W + 32] = T[W];
    return 0;
  }
  var Dr = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function pr(T, j) {
    var A, D, U, W;
    for (D = 63; D >= 32; --D) {
      for (A = 0, U = D - 32, W = D - 12; U < W; ++U)
        j[U] += A - 16 * j[D] * Dr[U - (D - 32)], A = Math.floor((j[U] + 128) / 256), j[U] -= A * 256;
      j[U] += A, j[D] = 0;
    }
    for (A = 0, U = 0; U < 32; U++)
      j[U] += A - (j[31] >> 4) * Dr[U], A = j[U] >> 8, j[U] &= 255;
    for (U = 0; U < 32; U++) j[U] -= A * Dr[U];
    for (D = 0; D < 32; D++)
      j[D + 1] += j[D] >> 8, T[D] = j[D] & 255;
  }
  function Zr(T) {
    var j = new Float64Array(64), A;
    for (A = 0; A < 64; A++) j[A] = T[A];
    for (A = 0; A < 64; A++) T[A] = 0;
    pr(T, j);
  }
  function la(T, j, A, D) {
    var U = new Uint8Array(64), W = new Uint8Array(64), he = new Uint8Array(64), ge, Z, de = new Float64Array(64), qe = [
      s(),
      s(),
      s(),
      s()
    ];
    nn(U, D, 32), U[0] &= 248, U[31] &= 127, U[31] |= 64;
    var xt = A + 64;
    for (ge = 0; ge < A; ge++) T[64 + ge] = j[ge];
    for (ge = 0; ge < 32; ge++) T[32 + ge] = U[32 + ge];
    for (nn(he, T.subarray(32), A + 32), Zr(he), on(qe, he), Xn(T, qe), ge = 32; ge < 64; ge++) T[ge] = D[ge];
    for (nn(W, T, A + 64), Zr(W), ge = 0; ge < 64; ge++) de[ge] = 0;
    for (ge = 0; ge < 32; ge++) de[ge] = he[ge];
    for (ge = 0; ge < 32; ge++)
      for (Z = 0; Z < 32; Z++)
        de[ge + Z] += W[ge] * U[Z];
    return pr(T.subarray(32), de), xt;
  }
  function Rs(T, j) {
    var A = s(), D = s(), U = s(), W = s(), he = s(), ge = s(), Z = s();
    return ke(T[2], E), Ot(T[1], j), Lt(U, T[1]), Ae(W, U, x), ht(U, U, T[2]), ct(W, T[2], W), Lt(he, W), Lt(ge, he), Ae(Z, ge, he), Ae(A, Z, U), Ae(A, A, W), dr(A, A), Ae(A, A, U), Ae(A, A, W), Ae(A, A, W), Ae(T[0], A, W), Lt(D, T[0]), Ae(D, D, W), dt(D, U) && Ae(T[0], T[0], z), Lt(D, T[0]), Ae(D, D, W), dt(D, U) ? -1 : (ot(T[0]) === j[31] >> 7 && ht(T[0], p, T[0]), Ae(T[3], T[0], T[1]), 0);
  }
  function Aa(T, j, A, D) {
    var U, W = new Uint8Array(32), he = new Uint8Array(64), ge = [
      s(),
      s(),
      s(),
      s()
    ], Z = [
      s(),
      s(),
      s(),
      s()
    ];
    if (A < 64 || Rs(Z, D)) return -1;
    for (U = 0; U < A; U++) T[U] = j[U];
    for (U = 0; U < 32; U++) T[U + 32] = D[U];
    if (nn(he, T, A), Zr(he), gn(ge, Z, he), on(Z, j.subarray(32)), _n(ge, Z), Xn(W, ge), A -= 64, Re(j, 0, W, 0)) {
      for (U = 0; U < A; U++) T[U] = 0;
      return -1;
    }
    for (U = 0; U < A; U++) T[U] = j[U + 64];
    return A;
  }
  var ua = 32, Bi = 24, Hi = 32, Zn = 16, rr = 32, er = 32, ei = 32, Ir = 32, _i = 32, Vi = Bi, I = Hi, ye = Zn, Ne = 64, Ue = 32, Et = 64, _t = 32, Ut = 64;
  o.lowlevel = {
    crypto_core_hsalsa20: wt,
    crypto_stream_xor: Ke,
    crypto_stream: Bt,
    crypto_stream_salsa20_xor: zt,
    crypto_stream_salsa20: it,
    crypto_onetimeauth: Ht,
    crypto_onetimeauth_verify: Ye,
    crypto_verify_16: De,
    crypto_verify_32: Re,
    crypto_secretbox: Ce,
    crypto_secretbox_open: Ze,
    crypto_scalarmult: wn,
    crypto_scalarmult_base: $n,
    crypto_box_beforenm: jn,
    crypto_box_afternm: xr,
    crypto_box: Fr,
    crypto_box_open: Kn,
    crypto_box_keypair: Fn,
    crypto_hash: nn,
    crypto_sign: la,
    crypto_sign_keypair: un,
    crypto_sign_open: Aa,
    crypto_secretbox_KEYBYTES: ua,
    crypto_secretbox_NONCEBYTES: Bi,
    crypto_secretbox_ZEROBYTES: Hi,
    crypto_secretbox_BOXZEROBYTES: Zn,
    crypto_scalarmult_BYTES: rr,
    crypto_scalarmult_SCALARBYTES: er,
    crypto_box_PUBLICKEYBYTES: ei,
    crypto_box_SECRETKEYBYTES: Ir,
    crypto_box_BEFORENMBYTES: _i,
    crypto_box_NONCEBYTES: Vi,
    crypto_box_ZEROBYTES: I,
    crypto_box_BOXZEROBYTES: ye,
    crypto_sign_BYTES: Ne,
    crypto_sign_PUBLICKEYBYTES: Ue,
    crypto_sign_SECRETKEYBYTES: Et,
    crypto_sign_SEEDBYTES: _t,
    crypto_hash_BYTES: Ut,
    gf: s,
    D: x,
    L: Dr,
    pack25519: st,
    unpack25519: Ot,
    M: Ae,
    A: ct,
    S: Lt,
    Z: ht,
    pow2523: dr,
    add: _n,
    set25519: ke,
    modL: pr,
    scalarmult: gn,
    scalarbase: on
  };
  function Ft(T, j) {
    if (T.length !== ua) throw new Error("bad key size");
    if (j.length !== Bi) throw new Error("bad nonce size");
  }
  function Yn(T, j) {
    if (T.length !== ei) throw new Error("bad public key size");
    if (j.length !== Ir) throw new Error("bad secret key size");
  }
  function Vt() {
    for (var T = 0; T < arguments.length; T++)
      if (!(arguments[T] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
  }
  function Cn(T) {
    for (var j = 0; j < T.length; j++) T[j] = 0;
  }
  o.randomBytes = function(T) {
    var j = new Uint8Array(T);
    return l(j, T), j;
  }, o.secretbox = function(T, j, A) {
    Vt(T, j, A), Ft(A, j);
    for (var D = new Uint8Array(Hi + T.length), U = new Uint8Array(D.length), W = 0; W < T.length; W++) D[W + Hi] = T[W];
    return Ce(U, D, D.length, j, A), U.subarray(Zn);
  }, o.secretbox.open = function(T, j, A) {
    Vt(T, j, A), Ft(A, j);
    for (var D = new Uint8Array(Zn + T.length), U = new Uint8Array(D.length), W = 0; W < T.length; W++) D[W + Zn] = T[W];
    return D.length < 32 || Ze(U, D, D.length, j, A) !== 0 ? null : U.subarray(Hi);
  }, o.secretbox.keyLength = ua, o.secretbox.nonceLength = Bi, o.secretbox.overheadLength = Zn, o.scalarMult = function(T, j) {
    if (Vt(T, j), T.length !== er) throw new Error("bad n size");
    if (j.length !== rr) throw new Error("bad p size");
    var A = new Uint8Array(rr);
    return wn(A, T, j), A;
  }, o.scalarMult.base = function(T) {
    if (Vt(T), T.length !== er) throw new Error("bad n size");
    var j = new Uint8Array(rr);
    return $n(j, T), j;
  }, o.scalarMult.scalarLength = er, o.scalarMult.groupElementLength = rr, o.box = function(T, j, A, D) {
    var U = o.box.before(A, D);
    return o.secretbox(T, j, U);
  }, o.box.before = function(T, j) {
    Vt(T, j), Yn(T, j);
    var A = new Uint8Array(_i);
    return jn(A, T, j), A;
  }, o.box.after = o.secretbox, o.box.open = function(T, j, A, D) {
    var U = o.box.before(A, D);
    return o.secretbox.open(T, j, U);
  }, o.box.open.after = o.secretbox.open, o.box.keyPair = function() {
    var T = new Uint8Array(ei), j = new Uint8Array(Ir);
    return Fn(T, j), {
      publicKey: T,
      secretKey: j
    };
  }, o.box.keyPair.fromSecretKey = function(T) {
    if (Vt(T), T.length !== Ir) throw new Error("bad secret key size");
    var j = new Uint8Array(ei);
    return $n(j, T), {
      publicKey: j,
      secretKey: new Uint8Array(T)
    };
  }, o.box.publicKeyLength = ei, o.box.secretKeyLength = Ir, o.box.sharedKeyLength = _i, o.box.nonceLength = Vi, o.box.overheadLength = o.secretbox.overheadLength, o.sign = function(T, j) {
    if (Vt(T, j), j.length !== Et) throw new Error("bad secret key size");
    var A = new Uint8Array(Ne + T.length);
    return la(A, T, T.length, j), A;
  }, o.sign.open = function(T, j) {
    if (Vt(T, j), j.length !== Ue) throw new Error("bad public key size");
    var A = new Uint8Array(T.length), D = Aa(A, T, T.length, j);
    if (D < 0) return null;
    for (var U = new Uint8Array(D), W = 0; W < U.length; W++) U[W] = A[W];
    return U;
  }, o.sign.detached = function(T, j) {
    for (var A = o.sign(T, j), D = new Uint8Array(Ne), U = 0; U < D.length; U++) D[U] = A[U];
    return D;
  }, o.sign.detached.verify = function(T, j, A) {
    if (Vt(T, j, A), j.length !== Ne) throw new Error("bad signature size");
    if (A.length !== Ue) throw new Error("bad public key size");
    var D = new Uint8Array(Ne + T.length), U = new Uint8Array(Ne + T.length), W;
    for (W = 0; W < Ne; W++) D[W] = j[W];
    for (W = 0; W < T.length; W++) D[W + Ne] = T[W];
    return Aa(U, D, D.length, A) >= 0;
  }, o.sign.keyPair = function() {
    var T = new Uint8Array(Ue), j = new Uint8Array(Et);
    return un(T, j), {
      publicKey: T,
      secretKey: j
    };
  }, o.sign.keyPair.fromSecretKey = function(T) {
    if (Vt(T), T.length !== Et) throw new Error("bad secret key size");
    for (var j = new Uint8Array(Ue), A = 0; A < j.length; A++) j[A] = T[32 + A];
    return {
      publicKey: j,
      secretKey: new Uint8Array(T)
    };
  }, o.sign.keyPair.fromSeed = function(T) {
    if (Vt(T), T.length !== _t) throw new Error("bad seed size");
    for (var j = new Uint8Array(Ue), A = new Uint8Array(Et), D = 0; D < 32; D++) A[D] = T[D];
    return un(j, A, !0), {
      publicKey: j,
      secretKey: A
    };
  }, o.sign.publicKeyLength = Ue, o.sign.secretKeyLength = Et, o.sign.seedLength = _t, o.sign.signatureLength = Ne, o.hash = function(T) {
    Vt(T);
    var j = new Uint8Array(Ut);
    return nn(j, T, T.length), j;
  }, o.hash.hashLength = Ut, o.verify = function(T, j) {
    return Vt(T, j), T.length === 0 || j.length === 0 || T.length !== j.length ? !1 : ve(T, 0, j, 0, T.length) === 0;
  }, o.setPRNG = function(T) {
    l = T;
  }, function() {
    var T = typeof globalThis < "u" ? globalThis.crypto || globalThis.msCrypto : null;
    if (T && T.getRandomValues) {
      var j = 65536;
      o.setPRNG(function(A, D) {
        var U, W = new Uint8Array(D);
        for (U = 0; U < D; U += j)
          T.getRandomValues(W.subarray(U, U + Math.min(D - U, j)));
        for (U = 0; U < D; U++) A[U] = W[U];
        Cn(W);
      });
    } else typeof require < "u" && (T = require("crypto"), T && T.randomBytes && o.setPRNG(function(A, D) {
      var U, W = T.randomBytes(D);
      for (U = 0; U < D; U++) A[U] = W[U];
      Cn(W);
    }));
  }();
})(typeof module < "u" && module.exports ? module.exports : globalThis.nacl = globalThis.nacl || {});
const By = typeof module < "u" && module.exports ? module.exports : globalThis.nacl;
By.sign.keyPair.fromSeed, By.sign.detached, By.sign.detached.verify, By.randomBytes;
var _1;
(function(o) {
  o.InvalidPrefixByte = "nkeys: invalid prefix byte", o.InvalidKey = "nkeys: invalid key", o.InvalidPublicKey = "nkeys: invalid public key", o.InvalidSeedLen = "nkeys: invalid seed length", o.InvalidSeed = "nkeys: invalid seed", o.InvalidEncoding = "nkeys: invalid encoded key", o.InvalidSignature = "nkeys: signature verification failed", o.CannotSign = "nkeys: cannot sign, no private key available", o.PublicKeyOnly = "nkeys: no seed or private key available", o.InvalidChecksum = "nkeys: invalid checksum", o.SerializationError = "nkeys: serialization error", o.ApiError = "nkeys: api error", o.ClearedPair = "nkeys: pair is cleared";
})(_1 || (_1 = {}));
var x1;
(function(o) {
  o[o.Seed = 144] = "Seed", o[o.Private = 120] = "Private", o[o.Operator = 112] = "Operator", o[o.Server = 104] = "Server", o[o.Cluster = 16] = "Cluster", o[o.Account = 0] = "Account", o[o.User = 160] = "User";
})(x1 || (x1 = {}));
function W2(o) {
  return (n) => {
    let s = {};
    return o.forEach((l) => {
      const d = l(n) || {};
      s = Object.assign(s, d);
    }), s;
  };
}
function G2() {
  return () => {
  };
}
function J2(o, n) {
  return () => {
    const s = typeof o == "function" ? o() : o, l = typeof n == "function" ? n() : n;
    return {
      user: s,
      pass: l
    };
  };
}
function Q2(o) {
  return () => ({
    auth_token: typeof o == "function" ? o() : o
  });
}
const jT = 2 * 60 * 1e3, K2 = 2, LT = 2 * 1e3;
function X2() {
  return {
    maxPingOut: 2,
    maxReconnectAttempts: 10,
    noRandomize: !1,
    pedantic: !1,
    pingInterval: jT,
    reconnect: !0,
    reconnectJitter: 100,
    reconnectJitterTLS: 1e3,
    reconnectTimeWait: LT,
    tls: void 0,
    verbose: !1,
    waitOnFirstConnect: !1,
    ignoreAuthErrorAbort: !1
  };
}
function Z2(o) {
  const n = [];
  return typeof o.authenticator == "function" && n.push(o.authenticator), Array.isArray(o.authenticator) && n.push(...o.authenticator), o.token && n.push(Q2(o.token)), o.user && n.push(J2(o.user, o.pass)), n.length === 0 ? G2() : W2(n);
}
function eU(o) {
  const n = `${dw}:${AT()}`;
  if (o = o || {
    servers: [
      n
    ]
  }, o.servers = o.servers || [], typeof o.servers == "string" && (o.servers = [
    o.servers
  ]), o.servers.length > 0 && o.port)
    throw new nt("port and servers options are mutually exclusive", je.InvalidOption);
  o.servers.length === 0 && o.port && (o.servers = [
    `${dw}:${o.port}`
  ]), o.servers && o.servers.length === 0 && (o.servers = [
    n
  ]);
  const s = g0(X2(), o);
  if (s.authenticator = Z2(s), [
    "reconnectDelayHandler",
    "authenticator"
  ].forEach((l) => {
    if (s[l] && typeof s[l] != "function")
      throw new nt(`${l} option should be a function`, je.NotFunction);
  }), s.reconnectDelayHandler || (s.reconnectDelayHandler = () => {
    let l = s.tls ? s.reconnectJitterTLS : s.reconnectJitter;
    return l && (l++, l = Math.floor(Math.random() * l)), s.reconnectTimeWait + l;
  }), s.inboxPrefix)
    try {
      Pl(s.inboxPrefix);
    } catch (l) {
      throw new nt(l.message, je.ApiError);
    }
  if (s.resolve === void 0 && (s.resolve = typeof yw() == "function"), s.resolve && typeof yw() != "function")
    throw new nt("'resolve' is not supported on this client", je.InvalidOption);
  return s;
}
function tU(o, n) {
  const { proto: s, tls_required: l, tls_available: d } = o;
  if ((s === void 0 || s < 1) && n.noEcho)
    throw new nt("noEcho", je.ServerOptionNotAvailable);
  const v = l || d || !1;
  if (n.tls && !v)
    throw new nt("tls", je.ServerOptionNotAvailable);
}
const nU = 1024 * 32, rU = /^INFO\s+([^\r\n]+)\r\n/i, iU = _m(`PONG\r
`), C1 = _m(`PING\r
`);
class aU {
  echo;
  no_responders;
  protocol;
  verbose;
  pedantic;
  jwt;
  nkey;
  sig;
  user;
  pass;
  auth_token;
  tls_required;
  name;
  lang;
  version;
  headers;
  constructor(n, s, l) {
    this.protocol = 1, this.version = n.version, this.lang = n.lang, this.echo = s.noEcho ? !1 : void 0, this.verbose = s.verbose, this.pedantic = s.pedantic, this.tls_required = s.tls ? !0 : void 0, this.name = s.name;
    const d = (s && typeof s.authenticator == "function" ? s.authenticator(l) : {}) || {};
    g0(this, d);
  }
}
class PT extends ii {
  sid;
  queue;
  draining;
  max;
  subject;
  drained;
  protocol;
  timer;
  info;
  cleanupFn;
  closed;
  requestSubject;
  constructor(n, s, l = {}) {
    super(), g0(this, l), this.protocol = n, this.subject = s, this.draining = !1, this.noIterator = typeof l.callback == "function", this.closed = nr();
    const d = !n.options?.noAsyncTraces;
    l.timeout && (this.timer = th(l.timeout, d), this.timer.then(() => {
      this.timer = void 0;
    }).catch((v) => {
      this.stop(v), this.noIterator && this.callback(v, {});
    })), this.noIterator || this.iterClosed.then(() => {
      this.closed.resolve(), this.unsubscribe();
    });
  }
  setPrePostHandlers(n) {
    if (this.noIterator) {
      const s = this.callback, l = n.ingestionFilterFn ? n.ingestionFilterFn : () => ({
        ingest: !0,
        protocol: !1
      }), d = n.protocolFilterFn ? n.protocolFilterFn : () => !0, v = n.dispatchedFn ? n.dispatchedFn : () => {
      };
      this.callback = (p, E) => {
        const { ingest: _ } = l(E);
        _ && d(E) && (s(p, E), v(E));
      };
    } else
      this.protocolFilterFn = n.protocolFilterFn, this.dispatchedFn = n.dispatchedFn;
  }
  callback(n, s) {
    this.cancelTimeout(), n ? this.stop(n) : this.push(s);
  }
  close() {
    if (!this.isClosed()) {
      this.cancelTimeout();
      const n = () => {
        if (this.stop(), this.cleanupFn)
          try {
            this.cleanupFn(this, this.info);
          } catch {
          }
        this.closed.resolve();
      };
      this.noIterator ? n() : this.push(n);
    }
  }
  unsubscribe(n) {
    this.protocol.unsubscribe(this, n);
  }
  cancelTimeout() {
    this.timer && (this.timer.cancel(), this.timer = void 0);
  }
  drain() {
    return this.protocol.isClosed() ? Promise.reject(nt.errorForCode(je.ConnectionClosed)) : this.isClosed() ? Promise.reject(nt.errorForCode(je.SubClosed)) : (this.drained || (this.draining = !0, this.protocol.unsub(this), this.drained = this.protocol.flush(nr()).then(() => {
      this.protocol.subscriptions.cancel(this);
    }).catch(() => {
      this.protocol.subscriptions.cancel(this);
    })), this.drained);
  }
  isDraining() {
    return this.draining;
  }
  isClosed() {
    return this.done;
  }
  getSubject() {
    return this.subject;
  }
  getMax() {
    return this.max;
  }
  getID() {
    return this.sid;
  }
}
class sU {
  mux;
  subs;
  sidCounter;
  constructor() {
    this.sidCounter = 0, this.mux = null, this.subs = /* @__PURE__ */ new Map();
  }
  size() {
    return this.subs.size;
  }
  add(n) {
    return this.sidCounter++, n.sid = this.sidCounter, this.subs.set(n.sid, n), n;
  }
  setMux(n) {
    return this.mux = n, n;
  }
  getMux() {
    return this.mux;
  }
  get(n) {
    return this.subs.get(n);
  }
  resub(n) {
    return this.sidCounter++, this.subs.delete(n.sid), n.sid = this.sidCounter, this.subs.set(n.sid, n), n;
  }
  all() {
    return Array.from(this.subs.values());
  }
  cancel(n) {
    n && (n.close(), this.subs.delete(n.sid));
  }
  handleError(n) {
    if (n && n.permissionContext) {
      const s = n.permissionContext, l = this.all();
      let d;
      if (s.operation === "subscription" && (d = l.find((v) => v.subject === s.subject && v.queue === s.queue)), s.operation === "publish" && (d = l.find((v) => v.requestSubject === s.subject)), d)
        return d.callback(n, {}), d.close(), this.subs.delete(d.sid), d !== this.mux;
    }
    return !1;
  }
  close() {
    this.subs.forEach((n) => {
      n.close();
    });
  }
}
class o0 {
  connected;
  connectedOnce;
  infoReceived;
  info;
  muxSubscriptions;
  options;
  outbound;
  pongs;
  subscriptions;
  transport;
  noMorePublishing;
  connectError;
  publisher;
  _closed;
  closed;
  listeners;
  heartbeats;
  parser;
  outMsgs;
  inMsgs;
  outBytes;
  inBytes;
  pendingLimit;
  lastError;
  abortReconnect;
  whyClosed;
  servers;
  server;
  features;
  connectPromise;
  constructor(n, s) {
    this._closed = !1, this.connected = !1, this.connectedOnce = !1, this.infoReceived = !1, this.noMorePublishing = !1, this.abortReconnect = !1, this.listeners = [], this.pendingLimit = nU, this.outMsgs = 0, this.inMsgs = 0, this.outBytes = 0, this.inBytes = 0, this.options = n, this.publisher = s, this.subscriptions = new sU(), this.muxSubscriptions = new B2(), this.outbound = new rh(), this.pongs = [], this.whyClosed = "", this.pendingLimit = n.pendingLimit || this.pendingLimit, this.features = new w2({
      major: 0,
      minor: 0,
      micro: 0
    }), this.connectPromise = null;
    const l = typeof n.servers == "string" ? [
      n.servers
    ] : n.servers;
    this.servers = new $2(l, {
      randomize: !n.noRandomize
    }), this.closed = nr(), this.parser = new w1(this), this.heartbeats = new H2(this, this.options.pingInterval || jT, this.options.maxPingOut || K2);
  }
  resetOutbound() {
    this.outbound.reset();
    const n = this.pongs;
    this.pongs = [];
    const s = nt.errorForCode(je.Disconnect);
    s.stack = "", n.forEach((l) => {
      l.reject(s);
    }), this.parser = new w1(this), this.infoReceived = !1;
  }
  dispatchStatus(n) {
    this.listeners.forEach((s) => {
      s.push(n);
    });
  }
  status() {
    const n = new ii();
    return this.listeners.push(n), n;
  }
  prepare() {
    this.transport && this.transport.discard(), this.info = void 0, this.resetOutbound();
    const n = nr();
    return n.catch(() => {
    }), this.pongs.unshift(n), this.connectError = (s) => {
      n.reject(s);
    }, this.transport = C2(), this.transport.closed().then(async (s) => {
      if (this.connected = !1, !this.isClosed()) {
        await this.disconnected(this.transport.closeError || this.lastError);
        return;
      }
    }), n;
  }
  disconnect() {
    this.dispatchStatus({
      type: Qd.StaleConnection,
      data: ""
    }), this.transport.disconnect();
  }
  reconnect() {
    return this.connected && (this.dispatchStatus({
      type: Qd.ClientInitiatedReconnect,
      data: ""
    }), this.transport.disconnect()), Promise.resolve();
  }
  async disconnected(n) {
    this.dispatchStatus({
      type: Ml.Disconnect,
      data: this.servers.getCurrentServer().toString()
    }), this.options.reconnect ? await this.dialLoop().then(() => {
      this.dispatchStatus({
        type: Ml.Reconnect,
        data: this.servers.getCurrentServer().toString()
      }), this.lastError?.code === je.AuthenticationExpired && (this.lastError = void 0);
    }).catch((s) => {
      this._close(s);
    }) : await this._close(n);
  }
  async dial(n) {
    const s = this.prepare();
    let l;
    try {
      l = th(this.options.timeout || 2e4);
      const d = this.transport.connect(n, this.options);
      await Promise.race([
        d,
        l
      ]), (async () => {
        try {
          for await (const v of this.transport)
            this.parser.parse(v);
        } catch (v) {
          console.log("reader closed", v);
        }
      })().then();
    } catch (d) {
      s.reject(d);
    }
    try {
      await Promise.race([
        l,
        s
      ]), l && l.cancel(), this.connected = !0, this.connectError = void 0, this.sendSubscriptions(), this.connectedOnce = !0, this.server.didConnect = !0, this.server.reconnects = 0, this.flushPending(), this.heartbeats.start();
    } catch (d) {
      throw l && l.cancel(), await this.transport.close(d), d;
    }
  }
  async _doDial(n) {
    const { resolve: s } = this.options, l = await n.resolve({
      fn: yw(),
      debug: this.options.debug,
      randomize: !this.options.noRandomize,
      resolve: s
    });
    let d = null;
    for (const v of l)
      try {
        d = null, this.dispatchStatus({
          type: Qd.Reconnecting,
          data: v.toString()
        }), await this.dial(v);
        return;
      } catch (p) {
        d = p;
      }
    throw d;
  }
  dialLoop() {
    return this.connectPromise === null && (this.connectPromise = this.dodialLoop(), this.connectPromise.then(() => {
    }).catch(() => {
    }).finally(() => {
      this.connectPromise = null;
    })), this.connectPromise;
  }
  async dodialLoop() {
    let n;
    for (; ; ) {
      this._closed && this.servers.clear();
      const s = this.options.reconnectDelayHandler ? this.options.reconnectDelayHandler() : LT;
      let l = s;
      const d = this.selectServer();
      if (!d || this.abortReconnect)
        throw n || (this.lastError ? this.lastError : nt.errorForCode(je.ConnectionRefused));
      const v = Date.now();
      if (d.lastConnect === 0 || d.lastConnect + s <= v) {
        d.lastConnect = Date.now();
        try {
          await this._doDial(d);
          break;
        } catch (p) {
          if (n = p, !this.connectedOnce) {
            if (this.options.waitOnFirstConnect)
              continue;
            this.servers.removeCurrentServer();
          }
          d.reconnects++;
          const E = this.options.maxReconnectAttempts || 0;
          E !== -1 && d.reconnects >= E && this.servers.removeCurrentServer();
        }
      } else
        l = Math.min(l, d.lastConnect + s - v), await lh(l);
    }
  }
  static async connect(n, s) {
    const l = new o0(n, s);
    return await l.dialLoop(), l;
  }
  static toError(n) {
    const s = n ? n.toLowerCase() : "";
    if (s.indexOf("permissions violation") !== -1) {
      const l = new nt(n, je.PermissionsViolation), d = n.match(/(Publish|Subscription) to "(\S+)"/);
      if (d) {
        l.permissionContext = {
          operation: d[1].toLowerCase(),
          subject: d[2],
          queue: void 0
        };
        const v = n.match(/using queue "(\S+)"/);
        v && (l.permissionContext.queue = v[1]);
      }
      return l;
    } else return s.indexOf("authorization violation") !== -1 ? new nt(n, je.AuthorizationViolation) : s.indexOf("user authentication expired") !== -1 ? new nt(n, je.AuthenticationExpired) : s.indexOf("account authentication expired") != -1 ? new nt(n, je.AccountExpired) : s.indexOf("authentication timeout") !== -1 ? new nt(n, je.AuthenticationTimeout) : new nt(n, je.ProtocolError);
  }
  processMsg(n, s) {
    if (this.inMsgs++, this.inBytes += s.length, !this.subscriptions.sidCounter)
      return;
    const l = this.subscriptions.get(n.sid);
    l && (l.received += 1, l.callback && l.callback(null, new CT(n, s, this)), l.max !== void 0 && l.received >= l.max && l.unsubscribe());
  }
  processError(n) {
    const s = u1(n), l = o0.toError(s), d = {
      type: Ml.Error,
      data: l.code
    };
    if (l.isPermissionError()) {
      let v = !1;
      l.permissionContext && (d.permissionContext = l.permissionContext, v = this.subscriptions.getMux()?.subject === l.permissionContext.subject), this.subscriptions.handleError(l), this.muxSubscriptions.handleError(v, l), v && this.subscriptions.setMux(null);
    }
    this.dispatchStatus(d), this.handleError(l);
  }
  handleError(n) {
    n.isAuthError() ? this.handleAuthError(n) : n.isProtocolError() ? this.lastError = n : n.isAuthTimeout() && (this.lastError = n), n.isPermissionError() || (this.lastError = n);
  }
  handleAuthError(n) {
    this.lastError && n.code === this.lastError.code && this.options.ignoreAuthErrorAbort === !1 && (this.abortReconnect = !0), this.connectError ? this.connectError(n) : this.disconnect();
  }
  processPing() {
    this.transport.send(iU);
  }
  processPong() {
    const n = this.pongs.shift();
    n && n.resolve();
  }
  processInfo(n) {
    const s = JSON.parse(u1(n));
    this.info = s;
    const l = this.options && this.options.ignoreClusterUpdates ? void 0 : this.servers.update(s, this.transport.isEncrypted());
    if (!this.infoReceived) {
      this.features.update(rf(s.version)), this.infoReceived = !0, this.transport.isEncrypted() && this.servers.updateTLSName();
      const { version: v, lang: p } = this.transport;
      try {
        const E = new aU({
          version: v,
          lang: p
        }, this.options, s.nonce);
        s.headers && (E.headers = !0, E.no_responders = !0);
        const _ = JSON.stringify(E);
        this.transport.send(_m(`CONNECT ${_}${Jy}`)), this.transport.send(C1);
      } catch (E) {
        this._close(E);
      }
    }
    l && this.dispatchStatus({
      type: Ml.Update,
      data: l
    }), (s.ldm !== void 0 ? s.ldm : !1) && this.dispatchStatus({
      type: Ml.LDM,
      data: this.servers.getCurrentServer().toString()
    });
  }
  push(n) {
    switch (n.kind) {
      case aa.MSG: {
        const { msg: s, data: l } = n;
        this.processMsg(s, l);
        break;
      }
      case aa.OK:
        break;
      case aa.ERR:
        this.processError(n.data);
        break;
      case aa.PING:
        this.processPing();
        break;
      case aa.PONG:
        this.processPong();
        break;
      case aa.INFO:
        this.processInfo(n.data);
        break;
    }
  }
  sendCommand(n, ...s) {
    const l = this.outbound.length();
    let d;
    typeof n == "string" ? d = _m(n) : d = n, this.outbound.fill(d, ...s), l === 0 ? queueMicrotask(() => {
      this.flushPending();
    }) : this.outbound.size() >= this.pendingLimit && this.flushPending();
  }
  publish(n, s = Xa, l) {
    let d;
    if (s instanceof Uint8Array)
      d = s;
    else if (typeof s == "string")
      d = sf.encode(s);
    else
      throw nt.errorForCode(je.BadPayload);
    let v = d.length;
    l = l || {}, l.reply = l.reply || "";
    let p = Xa, E = 0;
    if (l.headers) {
      if (this.info && !this.info.headers)
        throw new nt("headers", je.ServerOptionNotAvailable);
      p = l.headers.encode(), E = p.length, v = d.length + E;
    }
    if (this.info && v > this.info.max_payload)
      throw nt.errorForCode(je.MaxPayloadExceeded);
    this.outBytes += v, this.outMsgs++;
    let _;
    l.headers ? (l.reply ? _ = `HPUB ${n} ${l.reply} ${E} ${v}\r
` : _ = `HPUB ${n} ${E} ${v}\r
`, this.sendCommand(_, p, d, s0)) : (l.reply ? _ = `PUB ${n} ${l.reply} ${v}\r
` : _ = `PUB ${n} ${v}\r
`, this.sendCommand(_, d, s0));
  }
  request(n) {
    return this.initMux(), this.muxSubscriptions.add(n), n;
  }
  subscribe(n) {
    return this.subscriptions.add(n), this._subunsub(n), n;
  }
  _sub(n) {
    n.queue ? this.sendCommand(`SUB ${n.subject} ${n.queue} ${n.sid}\r
`) : this.sendCommand(`SUB ${n.subject} ${n.sid}\r
`);
  }
  _subunsub(n) {
    return this._sub(n), n.max && this.unsubscribe(n, n.max), n;
  }
  unsubscribe(n, s) {
    this.unsub(n, s), (n.max === void 0 || n.received >= n.max) && this.subscriptions.cancel(n);
  }
  unsub(n, s) {
    !n || this.isClosed() || (s ? this.sendCommand(`UNSUB ${n.sid} ${s}\r
`) : this.sendCommand(`UNSUB ${n.sid}\r
`), n.max = s);
  }
  resub(n, s) {
    !n || this.isClosed() || (this.unsub(n), n.subject = s, this.subscriptions.resub(n), this._sub(n));
  }
  flush(n) {
    return n || (n = nr()), this.pongs.push(n), this.outbound.fill(C1), this.flushPending(), n;
  }
  sendSubscriptions() {
    const n = [];
    this.subscriptions.all().forEach((s) => {
      const l = s;
      l.queue ? n.push(`SUB ${l.subject} ${l.queue} ${l.sid}${Jy}`) : n.push(`SUB ${l.subject} ${l.sid}${Jy}`);
    }), n.length && this.transport.send(_m(n.join("")));
  }
  async _close(n) {
    this._closed || (this.whyClosed = new Error("close trace").stack || "", this.heartbeats.cancel(), this.connectError && (this.connectError(n), this.connectError = void 0), this.muxSubscriptions.close(), this.subscriptions.close(), this.listeners.forEach((s) => {
      s.stop();
    }), this._closed = !0, await this.transport.close(n), await this.closed.resolve(n));
  }
  close() {
    return this._close();
  }
  isClosed() {
    return this._closed;
  }
  drain() {
    const n = this.subscriptions.all(), s = [];
    return n.forEach((l) => {
      s.push(l.drain());
    }), Promise.all(s).then(async () => (this.noMorePublishing = !0, await this.flush(), this.close())).catch(() => {
    });
  }
  flushPending() {
    if (!(!this.infoReceived || !this.connected) && this.outbound.size()) {
      const n = this.outbound.drain();
      this.transport.send(n);
    }
  }
  initMux() {
    if (!this.subscriptions.getMux()) {
      const s = this.muxSubscriptions.init(this.options.inboxPrefix), l = new PT(this, `${s}*`);
      l.callback = this.muxSubscriptions.dispatcher(), this.subscriptions.setMux(l), this.subscribe(l);
    }
  }
  selectServer() {
    const n = this.servers.selectServer();
    if (n !== void 0)
      return this.server = n, this.server;
  }
  getServer() {
    return this.server;
  }
}
const oU = "$SRV";
class R1 {
  msg;
  constructor(n) {
    this.msg = n;
  }
  get data() {
    return this.msg.data;
  }
  get sid() {
    return this.msg.sid;
  }
  get subject() {
    return this.msg.subject;
  }
  get reply() {
    return this.msg.reply || "";
  }
  get headers() {
    return this.msg.headers;
  }
  respond(n, s) {
    return this.msg.respond(n, s);
  }
  respondError(n, s, l, d) {
    return d = d || {}, d.headers = d.headers || Ul(), d.headers?.set(n0, `${n}`), d.headers?.set(t0, s), this.msg.respond(l, d);
  }
  json(n) {
    return this.msg.json(n);
  }
  string() {
    return this.msg.string();
  }
}
class jm {
  subject;
  queue;
  srv;
  constructor(n, s = "", l = "") {
    s !== "" && uU("service group", s);
    let d = "";
    if (n instanceof qm)
      this.srv = n, d = "";
    else if (n instanceof jm) {
      const v = n;
      this.srv = v.srv, l === "" && v.queue !== "" && (l = v.queue), d = v.subject;
    } else
      throw new Error("unknown ServiceGroup type");
    this.subject = this.calcSubject(d, s), this.queue = l;
  }
  calcSubject(n, s = "") {
    return s === "" ? n : n !== "" ? `${n}.${s}` : s;
  }
  addEndpoint(n = "", s) {
    s = s || {
      subject: n
    };
    const l = typeof s == "function" ? {
      handler: s,
      subject: n
    } : s;
    Sm("endpoint", n);
    let { subject: d, handler: v, metadata: p, queue: E } = l;
    d = d || n, E = E || this.queue, lU("endpoint subject", d), d = this.calcSubject(this.subject, d);
    const _ = {
      name: n,
      subject: d,
      queue: E,
      handler: v,
      metadata: p
    };
    return this.srv._addEndpoint(_);
  }
  addGroup(n = "", s = "") {
    return new jm(this, n, s);
  }
}
function lU(o, n) {
  if (n === "")
    throw new Error(`${o} cannot be empty`);
  if (n.indexOf(" ") !== -1)
    throw new Error(`${o} cannot contain spaces: '${n}'`);
  const s = n.split(".");
  s.forEach((l, d) => {
    if (l === ">" && d !== s.length - 1)
      throw new Error(`${o} cannot have internal '>': '${n}'`);
  });
}
function uU(o, n) {
  if (n.indexOf(" ") !== -1)
    throw new Error(`${o} cannot contain spaces: '${n}'`);
  n.split(".").forEach((l) => {
    if (l === ">")
      throw new Error(`${o} name cannot contain internal '>': '${n}'`);
  });
}
class qm {
  nc;
  _id;
  config;
  handlers;
  internal;
  _stopped;
  _done;
  started;
  static controlSubject(n, s = "", l = "", d) {
    const v = d ?? oU;
    return s === "" && l === "" ? `${v}.${n}` : (Sm("control subject name", s), l !== "" ? (Sm("control subject id", l), `${v}.${n}.${s}.${l}`) : `${v}.${n}.${s}`);
  }
  constructor(n, s = {
    name: "",
    version: ""
  }) {
    this.nc = n, this.config = Object.assign({}, s), this.config.queue || (this.config.queue = "q"), Sm("name", this.config.name), Sm("queue", this.config.queue), rf(this.config.version), this._id = of.next(), this.internal = [], this._done = nr(), this._stopped = !1, this.handlers = [], this.started = (/* @__PURE__ */ new Date()).toISOString(), this.reset(), this.nc.closed().then(() => {
      this.close().catch();
    }).catch((l) => {
      this.close(l).catch();
    });
  }
  get subjects() {
    return this.handlers.filter((n) => n.internal === !1).map((n) => n.subject);
  }
  get id() {
    return this._id;
  }
  get name() {
    return this.config.name;
  }
  get description() {
    return this.config.description ?? "";
  }
  get version() {
    return this.config.version;
  }
  get metadata() {
    return this.config.metadata;
  }
  errorToHeader(n) {
    const s = Ul();
    if (n instanceof r0) {
      const l = n;
      s.set(t0, l.message), s.set(n0, `${l.code}`);
    } else
      s.set(t0, n.message), s.set(n0, "500");
    return s;
  }
  setupHandler(n, s = !1) {
    const l = s ? "" : n.queue ? n.queue : this.config.queue, { name: d, subject: v, handler: p } = n, E = n;
    E.internal = s, s && this.internal.push(E), E.stats = new cU(d, v, l), E.queue = l;
    const _ = p ? (x, N) => {
      if (x) {
        this.close(x);
        return;
      }
      const O = Date.now();
      try {
        p(x, new R1(N));
      } catch (P) {
        E.stats.countError(P), N?.respond(Xa, {
          headers: this.errorToHeader(P)
        });
      } finally {
        E.stats.countLatency(O);
      }
    } : void 0;
    return E.sub = this.nc.subscribe(v, {
      callback: _,
      queue: l
    }), E.sub.closed.then(() => {
      this._stopped || this.close(new Error(`required subscription ${n.subject} stopped`)).catch();
    }).catch((x) => {
      if (!this._stopped) {
        const N = new Error(`required subscription ${n.subject} errored: ${x.message}`);
        N.stack = x.stack, this.close(N).catch();
      }
    }), E;
  }
  info() {
    return {
      type: xm.INFO,
      name: this.name,
      id: this.id,
      version: this.version,
      description: this.description,
      metadata: this.metadata,
      endpoints: this.endpoints()
    };
  }
  endpoints() {
    return this.handlers.map((n) => {
      const { subject: s, metadata: l, name: d, queue: v } = n;
      return {
        subject: s,
        metadata: l,
        name: d,
        queue_group: v
      };
    });
  }
  async stats() {
    const n = [];
    for (const s of this.handlers) {
      if (typeof this.config.statsHandler == "function")
        try {
          s.stats.data = await this.config.statsHandler(s);
        } catch (l) {
          s.stats.countError(l);
        }
      n.push(s.stats.stats(s.qi));
    }
    return {
      type: xm.STATS,
      name: this.name,
      id: this.id,
      version: this.version,
      started: this.started,
      metadata: this.metadata,
      endpoints: n
    };
  }
  addInternalHandler(n, s) {
    const l = `${n}`.toUpperCase();
    this._doAddInternalHandler(`${l}-all`, n, s), this._doAddInternalHandler(`${l}-kind`, n, s, this.name), this._doAddInternalHandler(`${l}`, n, s, this.name, this.id);
  }
  _doAddInternalHandler(n, s, l, d = "", v = "") {
    const p = {};
    p.name = n, p.subject = qm.controlSubject(s, d, v), p.handler = l, this.setupHandler(p, !0);
  }
  start() {
    const n = no(), s = (p, E) => p ? (this.close(p), Promise.reject(p)) : this.stats().then((_) => (E?.respond(n.encode(_)), Promise.resolve())), l = (p, E) => p ? (this.close(p), Promise.reject(p)) : (E?.respond(n.encode(this.info())), Promise.resolve()), d = n.encode(this.ping()), v = (p, E) => p ? (this.close(p).then().catch(), Promise.reject(p)) : (E.respond(d), Promise.resolve());
    return this.addInternalHandler(Lu.PING, v), this.addInternalHandler(Lu.STATS, s), this.addInternalHandler(Lu.INFO, l), this.handlers.forEach((p) => {
      const { subject: E } = p;
      typeof E == "string" && p.handler !== null && this.setupHandler(p);
    }), Promise.resolve(this);
  }
  close(n) {
    if (this._stopped)
      return this._done;
    this._stopped = !0;
    let s = [];
    return this.nc.isClosed() || (s = this.handlers.concat(this.internal).map((l) => l.sub.drain())), Promise.allSettled(s).then(() => {
      this._done.resolve(n || null);
    }), this._done;
  }
  get stopped() {
    return this._done;
  }
  get isStopped() {
    return this._stopped;
  }
  stop(n) {
    return this.close(n);
  }
  ping() {
    return {
      type: xm.PING,
      name: this.name,
      id: this.id,
      version: this.version,
      metadata: this.metadata
    };
  }
  reset() {
    if (this.started = (/* @__PURE__ */ new Date()).toISOString(), this.handlers)
      for (const n of this.handlers)
        n.stats.reset(n.qi);
  }
  addGroup(n, s) {
    return new jm(this, n, s);
  }
  addEndpoint(n, s) {
    return new jm(this).addEndpoint(n, s);
  }
  _addEndpoint(n) {
    const s = new ii();
    s.noIterator = typeof n.handler == "function", s.noIterator || (n.handler = (d, v) => {
      d ? this.stop(d).catch() : s.push(new R1(v));
    }, s.iterClosed.then(() => {
      this.close().catch();
    }));
    const l = this.setupHandler(n, !1);
    return l.qi = s, this.handlers.push(l), s;
  }
}
class cU {
  name;
  subject;
  average_processing_time;
  num_requests;
  processing_time;
  num_errors;
  last_error;
  data;
  metadata;
  queue;
  constructor(n, s, l = "") {
    this.name = n, this.subject = s, this.average_processing_time = 0, this.num_errors = 0, this.num_requests = 0, this.processing_time = 0, this.queue = l;
  }
  reset(n) {
    this.num_requests = 0, this.processing_time = 0, this.average_processing_time = 0, this.num_errors = 0, this.last_error = void 0, this.data = void 0;
    const s = n;
    s && (s.time = 0, s.processed = 0);
  }
  countLatency(n) {
    this.num_requests++, this.processing_time += fr(Date.now() - n), this.average_processing_time = Math.round(this.processing_time / this.num_requests);
  }
  countError(n) {
    this.num_errors++, this.last_error = n.message;
  }
  _stats() {
    const { name: n, subject: s, average_processing_time: l, num_errors: d, num_requests: v, processing_time: p, last_error: E, data: _, queue: x } = this;
    return {
      name: n,
      subject: s,
      average_processing_time: l,
      num_errors: d,
      num_requests: v,
      processing_time: p,
      last_error: E,
      data: _,
      queue_group: x
    };
  }
  stats(n) {
    const s = n;
    return s?.noIterator === !1 && (this.processing_time = s.time, this.num_requests = s.processed, this.average_processing_time = this.processing_time > 0 && this.num_requests > 0 ? this.processing_time / this.num_requests : 0), this._stats();
  }
}
class fU {
  nc;
  prefix;
  opts;
  constructor(n, s = {
    strategy: to.JitterTimer,
    maxWait: 2e3
  }, l) {
    this.nc = n, this.prefix = l, this.opts = s;
  }
  ping(n = "", s = "") {
    return this.q(Lu.PING, n, s);
  }
  stats(n = "", s = "") {
    return this.q(Lu.STATS, n, s);
  }
  info(n = "", s = "") {
    return this.q(Lu.INFO, n, s);
  }
  async q(n, s = "", l = "") {
    const d = new ii(), v = no(), p = qm.controlSubject(n, s, l, this.prefix), E = await this.nc.requestMany(p, Xa, this.opts);
    return (async () => {
      for await (const _ of E)
        try {
          const x = v.decode(_.data);
          d.push(x);
        } catch (x) {
          d.push(() => {
            d.stop(x);
          });
        }
      d.push(() => {
        d.stop();
      });
    })().catch((_) => {
      d.stop(_);
    }), d;
  }
}
function UT() {
  return {
    key: {
      encode(o) {
        return o;
      },
      decode(o) {
        return o;
      }
    },
    value: {
      encode(o) {
        return o;
      },
      decode(o) {
        return o;
      }
    }
  };
}
function dU() {
  return {
    replicas: 1,
    history: 1,
    timeout: 2e3,
    max_bytes: -1,
    maxValueSize: -1,
    codec: UT(),
    storage: vw.File
  };
}
const l0 = "KV-Operation", T1 = "$KV", hU = /^[-/=.\w]+$/, pU = /^[-/=.>*\w]+$/, mU = /^[-\w]+$/;
function vU(o) {
  if (o.startsWith(".") || o.endsWith(".") || !hU.test(o))
    throw new Error(`invalid key: ${o}`);
}
function gU(o) {
  if (o.startsWith(".") || o.endsWith(".") || !pU.test(o))
    throw new Error(`invalid key: ${o}`);
}
function yU(o) {
  if (o.startsWith(".") || o.endsWith("."))
    throw new Error(`invalid key: ${o}`);
  const n = o.split(".");
  let s = !1;
  for (let l = 0; l < n.length; l++)
    switch (n[l]) {
      case "*":
        s = !0;
        break;
      case ">":
        if (l !== n.length - 1)
          throw new Error(`invalid key: ${o}`);
        s = !0;
        break;
    }
  return s;
}
function Qy(o) {
  if (!mU.test(o))
    throw new Error(`invalid bucket name: ${o}`);
}
var Ho;
(function(o) {
  o.MsgIdHdr = "Nats-Msg-Id", o.ExpectedStreamHdr = "Nats-Expected-Stream", o.ExpectedLastSeqHdr = "Nats-Expected-Last-Sequence", o.ExpectedLastMsgIdHdr = "Nats-Expected-Last-Msg-Id", o.ExpectedLastSubjectSequenceHdr = "Nats-Expected-Last-Subject-Sequence";
})(Ho || (Ho = {}));
class Lm {
  js;
  jsm;
  stream;
  bucket;
  direct;
  codec;
  prefix;
  editPrefix;
  useJsPrefix;
  _prefixLen;
  constructor(n, s, l) {
    Qy(n), this.js = s, this.jsm = l, this.bucket = n, this.prefix = T1, this.editPrefix = "", this.useJsPrefix = !1, this._prefixLen = 0;
  }
  static async create(n, s, l = {}) {
    Qy(s);
    const d = await n.jetstreamManager(), v = new Lm(s, n, d);
    return await v.init(l), v;
  }
  static async bind(n, s, l = {}) {
    const d = await n.jetstreamManager(), v = {
      config: {
        allow_direct: l.allow_direct
      }
    };
    Qy(s);
    const p = new Lm(s, n, d);
    return v.config.name = l.streamName ?? p.bucketName(), Object.assign(p, v), p.stream = v.config.name, p.codec = l.codec || UT(), p.direct = v.config.allow_direct ?? !1, p.initializePrefixes(v), p;
  }
  async init(n = {}) {
    const s = Object.assign(dU(), n);
    this.codec = s.codec;
    const l = {};
    this.stream = l.name = n.streamName ?? this.bucketName(), l.retention = i0.Limits, l.max_msgs_per_subject = s.history, s.maxBucketSize && (s.max_bytes = s.maxBucketSize), s.max_bytes && (l.max_bytes = s.max_bytes), l.max_msg_size = s.maxValueSize, l.storage = s.storage;
    const d = n.placementCluster ?? "";
    if (d && (n.placement = {}, n.placement.cluster = d, n.placement.tags = []), n.placement && (l.placement = n.placement), n.republish && (l.republish = n.republish), n.description && (l.description = n.description), n.mirror) {
      const O = Object.assign({}, n.mirror);
      O.name.startsWith(Ga) || (O.name = `${Ga}${O.name}`), l.mirror = O, l.mirror_direct = !0;
    } else if (n.sources) {
      const O = n.sources.map((P) => {
        const z = Object.assign({}, P), B = z.name.startsWith(Ga) ? z.name.substring(Ga.length) : z.name;
        return z.name.startsWith(Ga) || (z.name = `${Ga}${z.name}`), !P.external && B !== this.bucket && (z.subject_transforms = [
          {
            src: `$KV.${B}.>`,
            dest: `$KV.${this.bucket}.>`
          }
        ]), z;
      });
      l.sources = O, l.subjects = [
        this.subjectForBucket()
      ];
    } else
      l.subjects = [
        this.subjectForBucket()
      ];
    n.metadata && (l.metadata = n.metadata), typeof n.compression == "boolean" && (l.compression = n.compression ? Iu.S2 : Iu.None);
    const v = this.js.nc, p = v.getServerVersion(), E = p ? gw(p, rf("2.7.2")) >= 0 : !1;
    l.discard = E ? Mm.New : Mm.Old;
    const { ok: _, min: x } = v.features.get(vn.JS_ALLOW_DIRECT);
    if (!_ && n.allow_direct === !0) {
      const O = p ? `${p.major}.${p.minor}.${p.micro}` : "unknown";
      return Promise.reject(new Error(`allow_direct is not available on server version ${O} - requires ${x}`));
    }
    n.allow_direct = typeof n.allow_direct == "boolean" ? n.allow_direct : _, l.allow_direct = n.allow_direct, this.direct = l.allow_direct, l.num_replicas = s.replicas, s.ttl && (l.max_age = fr(s.ttl)), l.allow_rollup_hdrs = !0;
    let N;
    try {
      N = await this.jsm.streams.info(l.name), !N.config.allow_direct && this.direct === !0 && (this.direct = !1);
    } catch (O) {
      if (O.message === "stream not found")
        N = await this.jsm.streams.add(l);
      else
        throw O;
    }
    this.initializePrefixes(N);
  }
  initializePrefixes(n) {
    this._prefixLen = 0, this.prefix = `$KV.${this.bucket}`, this.useJsPrefix = this.js.apiPrefix !== "$JS.API";
    const { mirror: s } = n.config;
    if (s) {
      let l = s.name;
      if (l.startsWith(Ga) && (l = l.substring(Ga.length)), s.external && s.external.api !== "") {
        const d = s.name.substring(Ga.length);
        this.useJsPrefix = !1, this.prefix = `$KV.${d}`, this.editPrefix = `${s.external.api}.$KV.${l}`;
      } else
        this.editPrefix = this.prefix;
    }
  }
  bucketName() {
    return this.stream ?? `${Ga}${this.bucket}`;
  }
  subjectForBucket() {
    return `${this.prefix}.${this.bucket}.>`;
  }
  subjectForKey(n, s = !1) {
    const l = [];
    return s ? (this.useJsPrefix && l.push(this.js.apiPrefix), this.editPrefix !== "" ? l.push(this.editPrefix) : l.push(this.prefix)) : this.prefix && l.push(this.prefix), l.push(n), l.join(".");
  }
  fullKeyName(n) {
    return this.prefix !== "" ? `${this.prefix}.${n}` : `${T1}.${this.bucket}.${n}`;
  }
  get prefixLen() {
    return this._prefixLen === 0 && (this._prefixLen = this.prefix.length + 1), this._prefixLen;
  }
  encodeKey(n) {
    const s = [];
    for (const l of n.split("."))
      switch (l) {
        case ">":
        case "*":
          s.push(l);
          break;
        default:
          s.push(this.codec.key.encode(l));
          break;
      }
    return s.join(".");
  }
  decodeKey(n) {
    const s = [];
    for (const l of n.split("."))
      switch (l) {
        case ">":
        case "*":
          s.push(l);
          break;
        default:
          s.push(this.codec.key.decode(l));
          break;
      }
    return s.join(".");
  }
  validateKey = vU;
  validateSearchKey = gU;
  hasWildcards = yU;
  close() {
    return Promise.resolve();
  }
  dataLen(n, s) {
    const l = s && s.get(sa.MessageSizeHdr) || "";
    return l !== "" ? parseInt(l, 10) : n.length;
  }
  smToEntry(n) {
    return new jU(this.bucket, this.prefixLen, n);
  }
  jmToEntry(n) {
    const s = this.decodeKey(n.subject.substring(this.prefixLen));
    return new LU(this.bucket, s, n);
  }
  async create(n, s) {
    let l;
    try {
      const v = await this.put(n, s, {
        previousSeq: 0
      });
      return Promise.resolve(v);
    } catch (v) {
      if (l = v, v?.api_error?.err_code !== 10071)
        return Promise.reject(v);
    }
    let d = 0;
    try {
      const v = await this.get(n);
      return v?.operation === "DEL" || v?.operation === "PURGE" ? (d = v !== null ? v.revision : 0, this.update(n, s, d)) : Promise.reject(l);
    } catch (v) {
      return Promise.reject(v);
    }
  }
  update(n, s, l) {
    if (l <= 0)
      throw new Error("version must be greater than 0");
    return this.put(n, s, {
      previousSeq: l
    });
  }
  async put(n, s, l = {}) {
    const d = this.encodeKey(n);
    this.validateKey(d);
    const v = {};
    if (l.previousSeq !== void 0) {
      const p = Ul();
      v.headers = p, p.set(Ho.ExpectedLastSubjectSequenceHdr, `${l.previousSeq}`);
    }
    try {
      return (await this.js.publish(this.subjectForKey(d, !0), s, v)).seq;
    } catch (p) {
      const E = p;
      return E.isJetStreamError() ? (E.message = E.api_error?.description, E.code = `${E.api_error?.code}`, Promise.reject(E)) : Promise.reject(p);
    }
  }
  async get(n, s) {
    const l = this.encodeKey(n);
    this.validateKey(l);
    let d = {
      last_by_subj: this.subjectForKey(l)
    };
    s && s.revision > 0 && (d = {
      seq: s.revision
    });
    let v;
    try {
      this.direct ? v = await this.jsm.direct.getMessage(this.bucketName(), d) : v = await this.jsm.streams.getMessage(this.bucketName(), d);
      const p = this.smToEntry(v);
      return p.key !== l ? null : p;
    } catch (p) {
      if (p.code === je.JetStream404NoMessages)
        return null;
      throw p;
    }
  }
  purge(n, s) {
    return this._deleteOrPurge(n, "PURGE", s);
  }
  delete(n, s) {
    return this._deleteOrPurge(n, "DEL", s);
  }
  async purgeDeletes(n = 30 * 60 * 1e3) {
    const s = nr(), l = [], d = await this.watch({
      key: ">",
      initializedFn: () => {
        s.resolve();
      }
    });
    (async () => {
      for await (const _ of d)
        (_.operation === "DEL" || _.operation === "PURGE") && l.push(_);
    })().then(), await s, d.stop();
    const v = Date.now() - n, p = l.map((_) => {
      const x = this.subjectForKey(_.key);
      return _.created.getTime() >= v ? this.jsm.streams.purge(this.stream, {
        filter: x,
        keep: 1
      }) : this.jsm.streams.purge(this.stream, {
        filter: x,
        keep: 0
      });
    }), E = await Promise.all(p);
    return E.unshift({
      success: !0,
      purged: 0
    }), E.reduce((_, x) => (_.purged += x.purged, _));
  }
  async _deleteOrPurge(n, s, l) {
    if (!this.hasWildcards(n))
      return this._doDeleteOrPurge(n, s, l);
    const d = await this.keys(n), v = [];
    for await (const p of d)
      v.push(this._doDeleteOrPurge(p, s)), v.length === 100 && (await Promise.all(v), v.length = 0);
    v.length > 0 && await Promise.all(v);
  }
  async _doDeleteOrPurge(n, s, l) {
    const d = this.encodeKey(n);
    this.validateKey(d);
    const v = Ul();
    v.set(l0, s), s === "PURGE" && v.set(sa.RollupHdr, sa.RollupValueSubject), l?.previousSeq && v.set(Ho.ExpectedLastSubjectSequenceHdr, `${l.previousSeq}`), await this.js.publish(this.subjectForKey(d, !0), Xa, {
      headers: v
    });
  }
  _buildCC(n, s, l = {}) {
    let v = (Array.isArray(n) ? n : [
      n
    ]).map((_) => {
      const x = this.encodeKey(_);
      return this.validateSearchKey(_), this.fullKeyName(x);
    }), p = Ar.LastPerSubject;
    s === eo.AllHistory && (p = Ar.All), s === eo.UpdatesOnly && (p = Ar.New);
    let E;
    return v.length === 1 && (E = v[0], v = void 0), Object.assign({
      deliver_policy: p,
      ack_policy: Pr.None,
      filter_subjects: v,
      filter_subject: E,
      flow_control: !0,
      idle_heartbeat: fr(5 * 1e3)
    }, l);
  }
  remove(n) {
    return this.purge(n);
  }
  async history(n = {}) {
    const s = n.key ?? ">", l = new ii(), d = {};
    d.headers_only = n.headers_only || !1;
    let v;
    v = () => {
      l.stop();
    };
    let p = 0;
    const E = this._buildCC(s, eo.AllHistory, d), _ = E.filter_subject, x = Uu(E);
    x.bindStream(this.stream), x.orderedConsumer(), x.callback((O, P) => {
      if (O) {
        l.stop(O);
        return;
      }
      if (P) {
        const z = this.jmToEntry(P);
        l.push(z), l.received++, (v && p > 0 && l.received >= p || P.info.pending === 0) && (l.push(v), v = void 0);
      }
    });
    const N = await this.js.subscribe(_, x);
    if (v) {
      const { info: { last: O } } = N, P = O.num_pending + O.delivered.consumer_seq;
      if (P === 0 || l.received >= P)
        try {
          v();
        } catch (z) {
          l.stop(z);
        } finally {
          v = void 0;
        }
      else
        p = P;
    }
    return l._data = N, l.iterClosed.then(() => {
      N.unsubscribe();
    }), N.closed.then(() => {
      l.stop();
    }).catch((O) => {
      l.stop(O);
    }), l;
  }
  canSetWatcherName() {
    const s = this.js.nc, { ok: l } = s.features.get(vn.JS_NEW_CONSUMER_CREATE_API);
    return l;
  }
  async watch(n = {}) {
    const s = n.key ?? ">", l = new ii(), d = {};
    d.headers_only = n.headers_only || !1;
    let v = eo.LastValue;
    n.include === eo.AllHistory ? v = eo.AllHistory : n.include === eo.UpdatesOnly && (v = eo.UpdatesOnly);
    const p = n.ignoreDeletes === !0;
    let E = n.initializedFn, _ = 0;
    const x = this._buildCC(s, v, d), N = x.filter_subject, O = Uu(x);
    this.canSetWatcherName() && O.consumerName(of.next()), O.bindStream(this.stream), n.resumeFromRevision && n.resumeFromRevision > 0 && O.startSequence(n.resumeFromRevision), O.orderedConsumer(), O.callback((z, B) => {
      if (z) {
        l.stop(z);
        return;
      }
      if (B) {
        const ie = this.jmToEntry(B);
        if (p && ie.operation === "DEL")
          return;
        l.push(ie), l.received++, E && (_ > 0 && l.received >= _ || B.info.pending === 0) && (l.push(E), E = void 0);
      }
    });
    const P = await this.js.subscribe(N, O);
    if (E) {
      const { info: { last: z } } = P, B = z.num_pending + z.delivered.consumer_seq;
      if (B === 0 || l.received >= B)
        try {
          E();
        } catch (ie) {
          l.stop(ie);
        } finally {
          E = void 0;
        }
      else
        _ = B;
    }
    return l._data = P, l.iterClosed.then(() => {
      P.unsubscribe();
    }), P.closed.then(() => {
      l.stop();
    }).catch((z) => {
      l.stop(z);
    }), l;
  }
  async keys(n = ">") {
    const s = new ii(), l = this._buildCC(n, eo.LastValue, {
      headers_only: !0
    }), d = Array.isArray(n) ? ">" : l.filter_subject, v = Uu(l);
    v.bindStream(this.stream), v.orderedConsumer();
    const p = await this.js.subscribe(d, v);
    return (async () => {
      for await (const _ of p) {
        const x = _.headers?.get(l0);
        if (x !== "DEL" && x !== "PURGE") {
          const N = this.decodeKey(_.subject.substring(this.prefixLen));
          s.push(N);
        }
        _.info.pending === 0 && p.unsubscribe();
      }
    })().then(() => {
      s.stop();
    }).catch((_) => {
      s.stop(_);
    }), p.info.last.num_pending === 0 && p.unsubscribe(), s;
  }
  purgeBucket(n) {
    return this.jsm.streams.purge(this.bucketName(), n);
  }
  destroy() {
    return this.jsm.streams.delete(this.bucketName());
  }
  async status() {
    const s = this.js.nc.info?.cluster ?? "", l = this.bucketName(), d = await this.jsm.streams.info(l);
    return new FT(d, s);
  }
}
class FT {
  si;
  cluster;
  constructor(n, s = "") {
    this.si = n, this.cluster = s;
  }
  get bucket() {
    return this.si.config.name.startsWith(Ga) ? this.si.config.name.substring(Ga.length) : this.si.config.name;
  }
  get values() {
    return this.si.state.messages;
  }
  get history() {
    return this.si.config.max_msgs_per_subject;
  }
  get ttl() {
    return Pw(this.si.config.max_age);
  }
  get bucket_location() {
    return this.cluster;
  }
  get backingStore() {
    return this.si.config.storage;
  }
  get storage() {
    return this.si.config.storage;
  }
  get replicas() {
    return this.si.config.num_replicas;
  }
  get description() {
    return this.si.config.description ?? "";
  }
  get maxBucketSize() {
    return this.si.config.max_bytes;
  }
  get maxValueSize() {
    return this.si.config.max_msg_size;
  }
  get max_bytes() {
    return this.si.config.max_bytes;
  }
  get placement() {
    return this.si.config.placement || {
      cluster: "",
      tags: []
    };
  }
  get placementCluster() {
    return this.si.config.placement?.cluster ?? "";
  }
  get republish() {
    return this.si.config.republish ?? {
      src: "",
      dest: ""
    };
  }
  get streamInfo() {
    return this.si;
  }
  get size() {
    return this.si.state.bytes;
  }
  get metadata() {
    return this.si.config.metadata ?? {};
  }
  get compression() {
    return this.si.config.compression ? this.si.config.compression !== Iu.None : !1;
  }
}
const Iw = "OBJ_", k1 = "SHA-256=";
function bU(o) {
  return Qy(o), `${Iw}${o}`;
}
function SU(o) {
  return o.startsWith(Iw) ? o.substring(4) : o;
}
class Ew {
  si;
  backingStore;
  constructor(n) {
    this.si = n, this.backingStore = "JetStream";
  }
  get bucket() {
    return SU(this.si.config.name);
  }
  get description() {
    return this.si.config.description ?? "";
  }
  get ttl() {
    return this.si.config.max_age;
  }
  get storage() {
    return this.si.config.storage;
  }
  get replicas() {
    return this.si.config.num_replicas;
  }
  get sealed() {
    return this.si.config.sealed;
  }
  get size() {
    return this.si.state.bytes;
  }
  get streamInfo() {
    return this.si;
  }
  get metadata() {
    return this.si.config.metadata;
  }
  get compression() {
    return this.si.config.compression ? this.si.config.compression !== Iu.None : !1;
  }
}
function Hy(o) {
  if (o === void 0)
    return;
  const { domain: n } = o;
  if (n === void 0)
    return o;
  const s = Object.assign({}, o);
  if (delete s.domain, n === "")
    return s;
  if (s.external)
    throw new Error("domain and external are both set");
  return s.external = {
    api: `$JS.${n}.API`
  }, s;
}
var _s;
(function(o) {
  o[o.Unset = -1] = "Unset", o[o.Consume = 0] = "Consume", o[o.Fetch = 1] = "Fetch";
})(_s || (_s = {}));
var jl;
(function(o) {
  o.HeartbeatsMissed = "heartbeats_missed", o.ConsumerNotFound = "consumer_not_found", o.StreamNotFound = "stream_not_found", o.ConsumerDeleted = "consumer_deleted", o.OrderedConsumerRecreated = "ordered_consumer_recreated";
})(jl || (jl = {}));
var Zd;
(function(o) {
  o.DebugEvent = "debug", o.Discard = "discard", o.Reset = "reset", o.Next = "next";
})(Zd || (Zd = {}));
const O1 = Uint8Array.of(43, 65, 67, 75), EU = Uint8Array.of(45, 78, 65, 75), gm = Uint8Array.of(43, 87, 80, 73), wU = Uint8Array.of(43, 78, 88, 84), _U = Uint8Array.of(43, 84, 69, 82, 77), xU = Uint8Array.of(32);
function Pm(o, n = 5e3) {
  return new BU(o, n);
}
class KE extends ii {
  consumer;
  opts;
  sub;
  monitor;
  pending;
  inbox;
  refilling;
  pong;
  callback;
  timeout;
  cleanupHandler;
  listeners;
  statusIterator;
  forOrderedConsumer;
  resetHandler;
  abortOnMissingResource;
  bind;
  constructor(n, s, l = !1) {
    super(), this.consumer = n;
    const d = s;
    this.opts = this.parseOptions(s, l), this.callback = d.callback || null, this.noIterator = typeof this.callback == "function", this.monitor = null, this.pong = null, this.pending = {
      msgs: 0,
      bytes: 0,
      requests: 0
    }, this.refilling = l, this.timeout = null, this.inbox = Pl(n.api.nc.options.inboxPrefix), this.listeners = [], this.forOrderedConsumer = !1, this.abortOnMissingResource = d.abort_on_missing_resource === !0, this.bind = d.bind === !0, this.start();
  }
  start() {
    const { max_messages: n, max_bytes: s, idle_heartbeat: l, threshold_bytes: d, threshold_messages: v } = this.opts;
    this.closed().then((E) => {
      if (this.cleanupHandler)
        try {
          this.cleanupHandler(E);
        } catch {
        }
    });
    const { sub: p } = this;
    p && p.unsubscribe(), this.sub = this.consumer.api.nc.subscribe(this.inbox, {
      callback: (E, _) => {
        if (E) {
          this.stop(E);
          return;
        }
        if (this.monitor?.work(), _.subject === this.inbox) {
          if (mw(_))
            return;
          const N = _.headers?.code, O = _.headers?.description?.toLowerCase() || "unknown", { msgsLeft: P, bytesLeft: z } = this.parseDiscard(_.headers);
          if (P > 0 || z > 0)
            this.pending.msgs -= P, this.pending.bytes -= z, this.pending.requests--, this.notify(Zd.Discard, {
              msgsLeft: P,
              bytesLeft: z
            });
          else if (N === 400) {
            this.stop(new nt(O, `${N}`));
            return;
          } else if (N === 409 && O === "consumer deleted") {
            if (this.notify(jl.ConsumerDeleted, `${N} ${O}`), !this.refilling || this.abortOnMissingResource) {
              const B = new nt(O, `${N}`);
              this.stop(B);
              return;
            }
          } else
            this.notify(Zd.DebugEvent, `${N} ${O}`);
        } else
          this._push(Pm(_, this.consumer.api.timeout)), this.received++, this.pending.msgs && this.pending.msgs--, this.pending.bytes && (this.pending.bytes -= _.size());
        if (this.pending.msgs === 0 && this.pending.bytes === 0 && (this.pending.requests = 0), this.refilling) {
          if (n && this.pending.msgs <= v || s && this.pending.bytes <= d) {
            const N = this.pullOptions();
            this.pull(N);
          }
        } else this.pending.requests === 0 && this._push(() => {
          this.stop();
        });
      }
    }), this.sub.closed.then(() => {
      this.sub.draining && this._push(() => {
        this.stop();
      });
    }), l && (this.monitor = new Uw(l, (E) => (this.notify(jl.HeartbeatsMissed, E), this.resetPending().then(() => {
    }).catch(() => {
    }), !1), {
      maxOut: 2
    })), (async () => {
      const E = this.consumer.api.nc.status();
      this.statusIterator = E;
      for await (const _ of E)
        switch (_.type) {
          case Ml.Disconnect:
            this.monitor?.cancel();
            break;
          case Ml.Reconnect:
            this.resetPending().then((x) => {
              x && this.monitor?.restart();
            }).catch(() => {
            });
            break;
        }
    })(), this.pull(this.pullOptions());
  }
  _push(n) {
    if (!this.callback)
      super.push(n);
    else {
      const s = typeof n == "function" ? n : null;
      try {
        s ? s() : this.callback(n);
      } catch (l) {
        this.stop(l);
      }
    }
  }
  notify(n, s) {
    this.listeners.length > 0 && this.listeners.forEach((l) => {
      l.done || l.push({
        type: n,
        data: s
      });
    });
  }
  resetPending() {
    return this.bind ? this.resetPendingNoInfo() : this.resetPendingWithInfo();
  }
  resetPendingNoInfo() {
    return this.pending.msgs = 0, this.pending.bytes = 0, this.pending.requests = 0, this.pull(this.pullOptions()), Promise.resolve(!0);
  }
  async resetPendingWithInfo() {
    let n = 0, s = 0;
    const l = Lw();
    let d = 0;
    for (; ; ) {
      if (this.done)
        return !1;
      if (this.consumer.api.nc.isClosed())
        return console.error("aborting resetPending - connection is closed"), !1;
      try {
        return await this.consumer.info(), n = 0, this.pending.msgs = 0, this.pending.bytes = 0, this.pending.requests = 0, this.pull(this.pullOptions()), !0;
      } catch (v) {
        if (v.message === "stream not found") {
          if (s++, this.notify(jl.StreamNotFound, s), !this.refilling || this.abortOnMissingResource)
            return this.stop(v), !1;
        } else if (v.message === "consumer not found") {
          if (n++, this.notify(jl.ConsumerNotFound, n), this.resetHandler)
            try {
              this.resetHandler();
            } catch {
            }
          if (!this.refilling || this.abortOnMissingResource)
            return this.stop(v), !1;
          if (this.forOrderedConsumer)
            return !1;
        } else
          n = 0, s = 0;
        const p = l.backoff(d), E = lh(p);
        await Promise.race([
          E,
          this.consumer.api.nc.closed()
        ]), E.cancel(), d++;
      }
    }
  }
  pull(n) {
    this.pending.bytes += n.max_bytes ?? 0, this.pending.msgs += n.batch ?? 0, this.pending.requests++;
    const s = this.consumer.api.nc;
    this._push(() => {
      s.publish(`${this.consumer.api.prefix}.CONSUMER.MSG.NEXT.${this.consumer.stream}.${this.consumer.name}`, this.consumer.api.jc.encode(n), {
        reply: this.inbox
      }), this.notify(Zd.Next, n);
    });
  }
  pullOptions() {
    const n = this.opts.max_messages - this.pending.msgs, s = this.opts.max_bytes - this.pending.bytes, l = fr(this.opts.idle_heartbeat), d = fr(this.opts.expires);
    return {
      batch: n,
      max_bytes: s,
      idle_heartbeat: l,
      expires: d
    };
  }
  parseDiscard(n) {
    const s = {
      msgsLeft: 0,
      bytesLeft: 0
    }, l = n?.get(sa.PendingMessagesHdr);
    l && (s.msgsLeft = parseInt(l));
    const d = n?.get(sa.PendingBytesHdr);
    return d && (s.bytesLeft = parseInt(d)), s;
  }
  trackTimeout(n) {
    this.timeout = n;
  }
  close() {
    return this.stop(), this.iterClosed;
  }
  closed() {
    return this.iterClosed;
  }
  clearTimers() {
    this.monitor?.cancel(), this.monitor = null, this.timeout?.cancel(), this.timeout = null;
  }
  setCleanupHandler(n) {
    this.cleanupHandler = n;
  }
  stop(n) {
    this.done || (this.sub?.unsubscribe(), this.clearTimers(), this.statusIterator?.stop(), this._push(() => {
      super.stop(n), this.listeners.forEach((s) => {
        s.stop();
      });
    }));
  }
  parseOptions(n, s = !1) {
    const l = n || {};
    if (l.max_messages = l.max_messages || 0, l.max_bytes = l.max_bytes || 0, l.max_messages !== 0 && l.max_bytes !== 0)
      throw new Error("only specify one of max_messages or max_bytes");
    if (l.max_messages === 0 && (l.max_messages = 100), l.expires = l.expires || 3e4, l.expires < 1e3)
      throw new Error("expires should be at least 1000ms");
    if (l.idle_heartbeat = l.idle_heartbeat || l.expires / 2, l.idle_heartbeat = l.idle_heartbeat > 3e4 ? 3e4 : l.idle_heartbeat, s) {
      const d = Math.round(l.max_messages * 0.75) || 1;
      l.threshold_messages = l.threshold_messages || d;
      const v = Math.round(l.max_bytes * 0.75) || 1;
      l.threshold_bytes = l.threshold_bytes || v;
    }
    return l;
  }
  status() {
    const n = new ii();
    return this.listeners.push(n), Promise.resolve(n);
  }
}
class CU extends ii {
  src;
  listeners;
  constructor() {
    super(), this.listeners = [];
  }
  setSource(n) {
    this.src && (this.src.resetHandler = void 0, this.src.setCleanupHandler(), this.src.stop()), this.src = n, this.src.setCleanupHandler((s) => {
      this.stop(s || void 0);
    }), (async () => {
      const s = await this.src.status();
      for await (const l of s)
        this.notify(l.type, l.data);
    })().catch(() => {
    });
  }
  notify(n, s) {
    this.listeners.length > 0 && this.listeners.forEach((l) => {
      l.done || l.push({
        type: n,
        data: s
      });
    });
  }
  stop(n) {
    this.done || (this.src?.stop(n), super.stop(n), this.listeners.forEach((s) => {
      s.stop();
    }));
  }
  close() {
    return this.stop(), this.iterClosed;
  }
  closed() {
    return this.iterClosed;
  }
  status() {
    const n = new ii();
    return this.listeners.push(n), Promise.resolve(n);
  }
}
class IT {
  api;
  _info;
  stream;
  name;
  constructor(n, s) {
    this.api = n, this._info = s, this.stream = s.stream_name, this.name = s.name;
  }
  consume(n = {
    max_messages: 100,
    expires: 3e4
  }) {
    return Promise.resolve(new KE(this, n, !0));
  }
  fetch(n = {
    max_messages: 100,
    expires: 3e4
  }) {
    const s = new KE(this, n, !1), l = Math.round(s.opts.expires * 1.05), d = th(l);
    return s.closed().catch(() => {
    }).finally(() => {
      d.cancel();
    }), d.catch(() => {
      s.close().catch();
    }), s.trackTimeout(d), Promise.resolve(s);
  }
  next(n = {
    expires: 3e4
  }) {
    const s = nr(), l = n;
    l.max_messages = 1;
    const d = new KE(this, l, !1), v = Math.round(d.opts.expires * 1.05);
    v >= 6e4 && (async () => {
      for await (const E of await d.status())
        if (E.type === jl.HeartbeatsMissed && E.data >= 2) {
          s.reject(new Error("consumer missed heartbeats"));
          break;
        }
    })().catch(), (async () => {
      for await (const E of d) {
        s.resolve(E);
        break;
      }
    })().catch(() => {
    });
    const p = th(v);
    return d.closed().then((E) => {
      E ? s.reject(E) : s.resolve(null);
    }).catch((E) => {
      s.reject(E);
    }).finally(() => {
      p.cancel();
    }), p.catch((E) => {
      s.resolve(null), d.close().catch();
    }), d.trackTimeout(p), s;
  }
  delete() {
    const { stream_name: n, name: s } = this._info;
    return this.api.delete(n, s);
  }
  info(n = !1) {
    if (n)
      return Promise.resolve(this._info);
    const { stream_name: s, name: l } = this._info;
    return this.api.info(s, l).then((d) => (this._info = d, this._info));
  }
}
class RU {
  api;
  consumerOpts;
  consumer;
  opts;
  cursor;
  stream;
  namePrefix;
  serial;
  currentConsumer;
  userCallback;
  iter;
  type;
  startSeq;
  constructor(n, s, l = {}) {
    this.api = n, this.stream = s, this.cursor = {
      stream_seq: 1,
      deliver_seq: 0
    }, this.namePrefix = of.next(), typeof l.name_prefix == "string" && (y0("name_prefix", l.name_prefix), this.namePrefix = l.name_prefix + this.namePrefix), this.serial = 0, this.currentConsumer = null, this.userCallback = null, this.iter = null, this.type = _s.Unset, this.consumerOpts = l, this.startSeq = this.consumerOpts.opt_start_seq || 0, this.cursor.stream_seq = this.startSeq > 0 ? this.startSeq - 1 : 0;
  }
  getConsumerOpts(n) {
    this.serial++;
    const s = `${this.namePrefix}_${this.serial}`;
    n = n === 0 ? 1 : n;
    const l = {
      name: s,
      deliver_policy: Ar.StartSequence,
      opt_start_seq: n,
      ack_policy: Pr.None,
      inactive_threshold: fr(5 * 60 * 1e3),
      num_replicas: 1
    };
    return this.consumerOpts.headers_only === !0 && (l.headers_only = !0), Array.isArray(this.consumerOpts.filterSubjects) && (l.filter_subjects = this.consumerOpts.filterSubjects), typeof this.consumerOpts.filterSubjects == "string" && (l.filter_subject = this.consumerOpts.filterSubjects), this.consumerOpts.replay_policy && (l.replay_policy = this.consumerOpts.replay_policy), n === this.startSeq + 1 && (l.deliver_policy = this.consumerOpts.deliver_policy || Ar.StartSequence, (this.consumerOpts.deliver_policy === Ar.LastPerSubject || this.consumerOpts.deliver_policy === Ar.New || this.consumerOpts.deliver_policy === Ar.Last) && (delete l.opt_start_seq, l.deliver_policy = this.consumerOpts.deliver_policy), l.deliver_policy === Ar.LastPerSubject && typeof l.filter_subjects > "u" && typeof l.filter_subject > "u" && (l.filter_subject = ">"), this.consumerOpts.opt_start_time && (delete l.opt_start_seq, l.deliver_policy = Ar.StartTime, l.opt_start_time = this.consumerOpts.opt_start_time), this.consumerOpts.inactive_threshold && (l.inactive_threshold = fr(this.consumerOpts.inactive_threshold))), l;
  }
  async resetConsumer(n = 0) {
    this.consumer?.delete().catch(() => {
    }), n = n === 0 ? 1 : n, this.cursor.deliver_seq = 0;
    const s = this.getConsumerOpts(n);
    s.max_deliver = 1, s.mem_storage = !0;
    const l = Lw();
    let d;
    for (let v = 0; ; v++)
      try {
        d = await this.api.add(this.stream, s), this.iter?.notify(jl.OrderedConsumerRecreated, d.name);
        break;
      } catch (p) {
        if (p.message === "stream not found" && (this.iter?.notify(jl.StreamNotFound, v), this.type === _s.Fetch || this.opts.abort_on_missing_resource === !0))
          return this.iter?.stop(p), Promise.reject(p);
        if (n === 0 && v >= 30)
          throw p;
        await lh(l.backoff(v + 1));
      }
    return d;
  }
  internalHandler(n) {
    return (s) => {
      if (this.serial !== n)
        return;
      const l = s.info.deliverySequence;
      if (l !== this.cursor.deliver_seq + 1) {
        this.notifyOrderedResetAndReset();
        return;
      }
      this.cursor.deliver_seq = l, this.cursor.stream_seq = s.info.streamSequence, this.userCallback ? this.userCallback(s) : this.iter?.push(s);
    };
  }
  async reset(n = {
    max_messages: 100,
    expires: 3e4
  }, s) {
    s = s || {};
    const l = s.fromFetch || !1, d = s.orderedReset || !1;
    if (this.type === _s.Fetch && d) {
      this.iter?.src.stop(), await this.iter?.closed(), this.currentConsumer = null;
      return;
    }
    (this.currentConsumer === null || d) && (this.currentConsumer = await this.resetConsumer(this.cursor.stream_seq + 1)), (this.iter === null || l) && (this.iter = new CU()), this.consumer = new IT(this.api, this.currentConsumer);
    const v = n;
    v.callback = this.internalHandler(this.serial);
    let p = null;
    this.type === _s.Fetch && l ? p = await this.consumer.fetch(n) : this.type === _s.Consume && (p = await this.consumer.consume(n));
    const E = p;
    E.forOrderedConsumer = !0, E.resetHandler = () => {
      this.notifyOrderedResetAndReset();
    }, this.iter.setSource(E);
  }
  notifyOrderedResetAndReset() {
    this.iter?.notify(Zd.Reset, ""), this.reset(this.opts, {
      orderedReset: !0
    });
  }
  async consume(n = {
    max_messages: 100,
    expires: 3e4
  }) {
    if (n.bind)
      return Promise.reject(new Error("bind is not supported"));
    if (this.type === _s.Fetch)
      return Promise.reject(new Error("ordered consumer initialized as fetch"));
    if (this.type === _s.Consume)
      return Promise.reject(new Error("ordered consumer doesn't support concurrent consume"));
    const { callback: l } = n;
    return l && (this.userCallback = l), this.type = _s.Consume, this.opts = n, await this.reset(n), this.iter;
  }
  async fetch(n = {
    max_messages: 100,
    expires: 3e4
  }) {
    if (n.bind)
      return Promise.reject(new Error("bind is not supported"));
    if (this.type === _s.Consume)
      return Promise.reject(new Error("ordered consumer already initialized as consume"));
    if (this.iter?.done === !1)
      return Promise.reject(new Error("ordered consumer doesn't support concurrent fetch"));
    const { callback: l } = n;
    return l && (this.userCallback = l), this.type = _s.Fetch, this.opts = n, await this.reset(n, {
      fromFetch: !0
    }), this.iter;
  }
  async next(n = {
    expires: 3e4
  }) {
    const s = n;
    if (s.bind)
      return Promise.reject(new Error("bind is not supported"));
    s.max_messages = 1;
    const l = nr();
    return s.callback = (v) => {
      this.userCallback = null, l.resolve(v);
    }, (await this.fetch(s)).iterClosed.then((v) => {
      v && l.reject(v), l.resolve(null);
    }).catch((v) => {
      l.reject(v);
    }), l;
  }
  delete() {
    return this.currentConsumer ? this.api.delete(this.stream, this.currentConsumer.name).then((n) => Promise.resolve(n)).catch((n) => Promise.reject(n)).finally(() => {
      this.currentConsumer = null;
    }) : Promise.resolve(!1);
  }
  async info(n) {
    return this.currentConsumer == null ? (this.currentConsumer = await this.resetConsumer(this.serial), Promise.resolve(this.currentConsumer)) : n && this.currentConsumer ? Promise.resolve(this.currentConsumer) : this.api.info(this.stream, this.currentConsumer.name);
  }
}
class zT {
  api;
  notified;
  constructor(n) {
    this.api = n, this.notified = !1;
  }
  checkVersion() {
    const n = this.api.nc.features.get(vn.JS_SIMPLIFICATION);
    return n.ok ? Promise.resolve() : Promise.reject(new Error(`consumers framework is only supported on servers ${n.min} or better`));
  }
  async get(n, s = {}) {
    return typeof s == "object" ? this.ordered(n, s) : (await this.checkVersion(), this.api.info(n, s).then((l) => l.config.deliver_subject !== void 0 ? Promise.reject(new Error("push consumer not supported")) : new IT(this.api, l)).catch((l) => Promise.reject(l)));
  }
  async ordered(n, s) {
    await this.checkVersion();
    const l = this.api;
    return new zw(l.nc, l.opts).info(n).then((v) => Promise.resolve(new RU(this.api, n, s))).catch((v) => Promise.reject(v));
  }
}
class b0 {
  api;
  _info;
  constructor(n, s) {
    this.api = n, this._info = s;
  }
  get name() {
    return this._info.config.name;
  }
  alternates() {
    return this.info().then((n) => n.alternates ? n.alternates : []);
  }
  async best() {
    if (await this.info(), this._info.alternates) {
      const n = await this.api.info(this._info.alternates[0].name);
      return new b0(this.api, n);
    } else
      return this;
  }
  info(n = !1, s) {
    return n ? Promise.resolve(this._info) : this.api.info(this.name, s).then((l) => (this._info = l, this._info));
  }
  getConsumer(n) {
    return new zT(new Fw(this.api.nc, this.api.opts)).get(this.name, n);
  }
  getMessage(n) {
    return this.api.getMessage(this.name, n);
  }
  deleteMessage(n, s) {
    return this.api.deleteMessage(this.name, n, s);
  }
}
class zw extends Vm {
  constructor(n, s) {
    super(n, s);
  }
  checkStreamConfigVersions(n) {
    const s = this.nc;
    if (n.metadata) {
      const { min: d, ok: v } = s.features.get(vn.JS_STREAM_CONSUMER_METADATA);
      if (!v)
        throw new Error(`stream 'metadata' requires server ${d}`);
    }
    if (n.first_seq) {
      const { min: d, ok: v } = s.features.get(vn.JS_STREAM_FIRST_SEQ);
      if (!v)
        throw new Error(`stream 'first_seq' requires server ${d}`);
    }
    if (n.subject_transform) {
      const { min: d, ok: v } = s.features.get(vn.JS_STREAM_SUBJECT_TRANSFORM);
      if (!v)
        throw new Error(`stream 'subject_transform' requires server ${d}`);
    }
    if (n.compression) {
      const { min: d, ok: v } = s.features.get(vn.JS_STREAM_COMPRESSION);
      if (!v)
        throw new Error(`stream 'compression' requires server ${d}`);
    }
    if (n.consumer_limits) {
      const { min: d, ok: v } = s.features.get(vn.JS_DEFAULT_CONSUMER_LIMITS);
      if (!v)
        throw new Error(`stream 'consumer_limits' requires server ${d}`);
    }
    function l(d, v) {
      if ((v?.subject_transforms?.length || 0) > 0) {
        const { min: E, ok: _ } = s.features.get(vn.JS_STREAM_SOURCE_SUBJECT_TRANSFORM);
        if (!_)
          throw new Error(`${d} 'subject_transforms' requires server ${E}`);
      }
    }
    n.sources && n.sources.forEach((d) => {
      l("stream sources", d);
    }), n.mirror && l("stream mirror", n.mirror);
  }
  async add(n = {}) {
    this.checkStreamConfigVersions(n), ia(n.name), n.mirror = Hy(n.mirror), n.sources = n.sources?.map(Hy);
    const l = await this._request(`${this.prefix}.STREAM.CREATE.${n.name}`, n);
    return this._fixInfo(l), l;
  }
  async delete(n) {
    return ia(n), (await this._request(`${this.prefix}.STREAM.DELETE.${n}`)).success;
  }
  async update(n, s = {}) {
    if (typeof n == "object") {
      const E = n;
      n = E.name, s = E, console.trace("\x1B[33m >> streams.update(config: StreamConfig) api changed to streams.update(name: string, config: StreamUpdateConfig) - this shim will be removed - update your code.  \x1B[0m");
    }
    this.checkStreamConfigVersions(s), ia(n);
    const l = await this.info(n), d = Object.assign(l.config, s);
    d.mirror = Hy(d.mirror), d.sources = d.sources?.map(Hy);
    const p = await this._request(`${this.prefix}.STREAM.UPDATE.${n}`, d);
    return this._fixInfo(p), p;
  }
  async info(n, s) {
    ia(n);
    const l = `${this.prefix}.STREAM.INFO.${n}`;
    let v = await this._request(l, s), { total: p, limit: E } = v, _ = v.state.subjects ? Object.getOwnPropertyNames(v.state.subjects).length : 1;
    if (p && p > _) {
      const x = [
        v
      ], N = s || {};
      let O = 0;
      for (; p > _; ) {
        O++, N.offset = E * O;
        const z = await this._request(l, N);
        p = z.total, x.push(z);
        const B = Object.getOwnPropertyNames(z.state.subjects).length;
        if (_ += B, B < E)
          break;
      }
      let P = {};
      for (let z = 0; z < x.length; z++)
        v = x[z], v.state.subjects && (P = Object.assign(P, v.state.subjects));
      v.offset = 0, v.total = 0, v.limit = 0, v.state.subjects = P;
    }
    return this._fixInfo(v), v;
  }
  list(n = "") {
    const s = n?.length ? {
      subject: n
    } : {}, l = (v) => {
      const p = v;
      return p.streams.forEach((E) => {
        this._fixInfo(E);
      }), p.streams;
    }, d = `${this.prefix}.STREAM.LIST`;
    return new Em(d, l, this, s);
  }
  _fixInfo(n) {
    n.config.sealed = n.config.sealed || !1, n.config.deny_delete = n.config.deny_delete || !1, n.config.deny_purge = n.config.deny_purge || !1, n.config.allow_rollup_hdrs = n.config.allow_rollup_hdrs || !1;
  }
  async purge(n, s) {
    if (s) {
      const { keep: d, seq: v } = s;
      if (typeof d == "number" && typeof v == "number")
        throw new Error("can specify one of keep or seq");
    }
    return ia(n), await this._request(`${this.prefix}.STREAM.PURGE.${n}`, s);
  }
  async deleteMessage(n, s, l = !0) {
    ia(n);
    const d = {
      seq: s
    };
    return l || (d.no_erase = !0), (await this._request(`${this.prefix}.STREAM.MSG.DELETE.${n}`, d)).success;
  }
  async getMessage(n, s) {
    ia(n);
    const d = await this._request(`${this.prefix}.STREAM.MSG.GET.${n}`, s);
    return new OU(d);
  }
  find(n) {
    return this.findStream(n);
  }
  listKvs() {
    const n = (l) => {
      const v = l.streams.filter((_) => _.config.name.startsWith(Ga));
      v.forEach((_) => {
        this._fixInfo(_);
      });
      let p = "";
      return v.length && (p = this.nc.info?.cluster ?? ""), v.map((_) => new FT(_, p));
    }, s = `${this.prefix}.STREAM.LIST`;
    return new Em(s, n, this);
  }
  listObjectStores() {
    const n = (l) => {
      const v = l.streams.filter((E) => E.config.name.startsWith(Iw));
      return v.forEach((E) => {
        this._fixInfo(E);
      }), v.map((E) => new Ew(E));
    }, s = `${this.prefix}.STREAM.LIST`;
    return new Em(s, n, this);
  }
  names(n = "") {
    const s = n?.length ? {
      subject: n
    } : {}, l = (v) => v.streams, d = `${this.prefix}.STREAM.NAMES`;
    return new Em(d, l, this, s);
  }
  async get(n) {
    const s = await this.info(n);
    return Promise.resolve(new b0(this, s));
  }
}
class TU extends Vm {
  constructor(n, s) {
    super(n, s);
  }
  async getMessage(n, s) {
    ia(n);
    let l = s;
    const { last_by_subj: d } = l;
    d && (l = null);
    const v = l ? this.jc.encode(l) : Xa, p = this.opts.apiPrefix || "$JS.API", E = d ? `${p}.DIRECT.GET.${n}.${d}` : `${p}.DIRECT.GET.${n}`, _ = await this.nc.request(E, v), x = Xd(_);
    if (x)
      return Promise.reject(x);
    const N = new N1(_);
    return Promise.resolve(N);
  }
  async getBatch(n, s) {
    ia(n);
    const d = `${this.opts.apiPrefix || "$JS.API"}.DIRECT.GET.${n}`;
    if (!Array.isArray(s.multi_last) || s.multi_last.length === 0)
      return Promise.reject("multi_last is required");
    const v = JSON.stringify(s, (_, x) => _ === "up_to_time" && x instanceof Date ? x.toISOString() : x), p = new ii(), E = await this.nc.requestMany(d, v, {
      strategy: to.SentinelMsg
    });
    return (async () => {
      let _ = !1, x = !1, N;
      for await (const O of E) {
        if (!_) {
          _ = !0;
          const P = O.headers?.code || 0;
          if (P !== 0 && P < 200 || P > 299) {
            N = O.headers?.description.toLowerCase();
            break;
          }
          if (O.headers?.get("Nats-Num-Pending") === "") {
            x = !0;
            break;
          }
        }
        if (O.data.length === 0)
          break;
        p.push(new N1(O));
      }
      p.push(() => {
        if (x)
          throw new Error("batch direct get not supported by the server");
        if (N)
          throw new Error(`bad request: ${N}`);
        p.stop();
      });
    })(), Promise.resolve(p);
  }
}
class N1 {
  data;
  header;
  static jc;
  constructor(n) {
    if (!n.headers)
      throw new Error("headers expected");
    this.data = n.data, this.header = n.headers;
  }
  get subject() {
    return this.header.last(Jd.Subject);
  }
  get seq() {
    const n = this.header.last(Jd.Sequence);
    return typeof n == "string" ? parseInt(n) : 0;
  }
  get time() {
    return new Date(Date.parse(this.timestamp));
  }
  get timestamp() {
    return this.header.last(Jd.TimeStamp);
  }
  get stream() {
    return this.header.last(Jd.Stream);
  }
  json(n) {
    return no(n).decode(this.data);
  }
  string() {
    return Qa.decode(this.data);
  }
}
class kU extends Vm {
  streams;
  consumers;
  direct;
  constructor(n, s) {
    super(n, s), this.streams = new zw(n, s), this.consumers = new Fw(n, s), this.direct = new TU(n, s);
  }
  async getAccountInfo() {
    return await this._request(`${this.prefix}.INFO`);
  }
  jetstream() {
    return this.nc.jetstream(this.getOptions());
  }
  advisories() {
    const n = new ii();
    return this.nc.subscribe("$JS.EVENT.ADVISORY.>", {
      callback: (s, l) => {
        if (s)
          throw s;
        try {
          const d = this.parseJsResponse(l), v = d.type.split("."), p = v[v.length - 1];
          n.push({
            kind: p,
            data: d
          });
        } catch (d) {
          n.stop(d);
        }
      }
    }), n;
  }
}
class OU {
  _header;
  smr;
  static jc;
  constructor(n) {
    this.smr = n;
  }
  get subject() {
    return this.smr.message.subject;
  }
  get seq() {
    return this.smr.message.seq;
  }
  get timestamp() {
    return this.smr.message.time;
  }
  get time() {
    return new Date(Date.parse(this.timestamp));
  }
  get data() {
    return this.smr.message.data ? this._parse(this.smr.message.data) : Xa;
  }
  get header() {
    if (!this._header)
      if (this.smr.message.hdrs) {
        const n = this._parse(this.smr.message.hdrs);
        this._header = Pu.decode(n);
      } else
        this._header = Ul();
    return this._header;
  }
  _parse(n) {
    const s = atob(n), l = s.length, d = new Uint8Array(l);
    for (let v = 0; v < l; v++)
      d[v] = s.charCodeAt(v);
    return d;
  }
  json(n) {
    return no(n).decode(this.data);
  }
  string() {
    return Qa.decode(this.data);
  }
}
class NU {
  api;
  constructor(n) {
    this.api = n;
  }
  get(n) {
    return this.api.info(n).then((s) => new b0(this.api, s));
  }
}
class XE {
  info;
  hdrs;
  constructor(n) {
    this.info = n;
  }
  get name() {
    return this.info.name;
  }
  get description() {
    return this.info.description ?? "";
  }
  get headers() {
    return this.hdrs || (this.hdrs = Pu.fromRecord(this.info.headers || {})), this.hdrs;
  }
  get options() {
    return this.info.options;
  }
  get bucket() {
    return this.info.bucket;
  }
  get chunks() {
    return this.info.chunks;
  }
  get deleted() {
    return this.info.deleted ?? !1;
  }
  get digest() {
    return this.info.digest;
  }
  get mtime() {
    return this.info.mtime;
  }
  get nuid() {
    return this.info.nuid;
  }
  get size() {
    return this.info.size;
  }
  get revision() {
    return this.info.revision;
  }
  get metadata() {
    return this.info.metadata || {};
  }
  isLink() {
    return this.info.options?.link !== void 0 && this.info.options?.link !== null;
  }
}
function A1(o) {
  const n = {
    name: o.name,
    description: o.description ?? "",
    options: o.options,
    metadata: o.metadata
  };
  if (o.headers) {
    const s = o.headers;
    n.headers = s.toRecord();
  }
  return n;
}
function AU() {
  return new ReadableStream({
    pull(o) {
      o.enqueue(new Uint8Array(0)), o.close();
    }
  });
}
class Tm {
  jsm;
  js;
  stream;
  name;
  constructor(n, s, l) {
    this.name = n, this.jsm = s, this.js = l;
  }
  _checkNotEmpty(n) {
    return !n || n.length === 0 ? {
      name: n,
      error: new Error("name cannot be empty")
    } : {
      name: n
    };
  }
  async info(n) {
    const s = await this.rawInfo(n);
    return s ? new XE(s) : null;
  }
  async list() {
    const n = [], s = await this.watch({
      ignoreDeletes: !0,
      includeHistory: !0
    });
    for await (const l of s) {
      if (l === null)
        break;
      n.push(l);
    }
    return Promise.resolve(n);
  }
  async rawInfo(n) {
    const { name: s, error: l } = this._checkNotEmpty(n);
    if (l)
      return Promise.reject(l);
    const d = this._metaSubject(s);
    try {
      const v = await this.jsm.streams.getMessage(this.stream, {
        last_by_subj: d
      }), E = no().decode(v.data);
      return E.revision = v.seq, E;
    } catch (v) {
      return v.code === "404" ? null : Promise.reject(v);
    }
  }
  async _si(n) {
    try {
      return await this.jsm.streams.info(this.stream, n);
    } catch (s) {
      return s.code === "404" ? null : Promise.reject(s);
    }
  }
  async seal() {
    let n = await this._si();
    return n === null ? Promise.reject(new Error("object store not found")) : (n.config.sealed = !0, n = await this.jsm.streams.update(this.stream, n.config), Promise.resolve(new Ew(n)));
  }
  async status(n) {
    const s = await this._si(n);
    return s === null ? Promise.reject(new Error("object store not found")) : Promise.resolve(new Ew(s));
  }
  destroy() {
    return this.jsm.streams.delete(this.stream);
  }
  async _put(n, s, l) {
    const d = this.js.getOptions();
    l = l || {
      timeout: d.timeout
    }, l.timeout = l.timeout || d.timeout, l.previousRevision = l.previousRevision ?? void 0;
    const { timeout: v, previousRevision: p } = l, _ = this.js.nc.info?.max_payload || 1024;
    n = n || {}, n.options = n.options || {};
    let x = n.options?.max_chunk_size || 128 * 1024;
    x = x > _ ? _ : x, n.options.max_chunk_size = x;
    const N = await this.info(n.name), { name: O, error: P } = this._checkNotEmpty(n.name);
    if (P)
      return Promise.reject(P);
    const z = of.next(), B = this._chunkSubject(z), ie = this._metaSubject(O), K = Object.assign({
      bucket: this.name,
      nuid: z,
      size: 0,
      chunks: 0
    }, A1(n)), be = nr(), ae = [], ve = new rh();
    try {
      const De = s ? s.getReader() : null, Re = new b1();
      for (; ; ) {
        const { done: lt, value: Ve } = De ? await De.read() : {
          done: !0,
          value: void 0
        };
        if (lt) {
          if (ve.size() > 0) {
            const Ke = ve.drain();
            Re.update(Ke), K.chunks++, K.size += Ke.length, ae.push(this.js.publish(B, Ke, {
              timeout: v
            }));
          }
          await Promise.all(ae), ae.length = 0, K.mtime = (/* @__PURE__ */ new Date()).toISOString();
          const wt = Re.digest("base64"), Rt = wt.length % 3, zt = Rt > 0 ? "=".repeat(Rt) : "";
          K.digest = `${k1}${wt}${zt}`, K.deleted = !1;
          const it = Ul();
          typeof p == "number" && it.set(Ho.ExpectedLastSubjectSequenceHdr, `${p}`), it.set(sa.RollupHdr, sa.RollupValueSubject);
          const Bt = await this.js.publish(ie, no().encode(K), {
            headers: it,
            timeout: v
          });
          if (K.revision = Bt.seq, N)
            try {
              await this.jsm.streams.purge(this.stream, {
                filter: `$O.${this.name}.C.${N.nuid}`
              });
            } catch {
            }
          be.resolve(new XE(K));
          break;
        }
        if (Ve)
          for (ve.fill(Ve); ve.size() > x; ) {
            K.chunks++, K.size += x;
            const wt = ve.drain(n.options.max_chunk_size);
            Re.update(wt), ae.push(this.js.publish(B, wt, {
              timeout: v
            }));
          }
      }
    } catch (De) {
      await this.jsm.streams.purge(this.stream, {
        filter: B
      }), be.reject(De);
    }
    return be;
  }
  putBlob(n, s, l) {
    function d(v) {
      return new ReadableStream({
        pull(p) {
          p.enqueue(v), p.close();
        }
      });
    }
    return s === null && (s = new Uint8Array(0)), this.put(n, d(s), l);
  }
  put(n, s, l) {
    return n?.options?.link ? Promise.reject(new Error("link cannot be set when putting the object in bucket")) : this._put(n, s, l);
  }
  async getBlob(n) {
    async function s(v) {
      const p = new rh(), E = v.getReader();
      for (; ; ) {
        const { done: _, value: x } = await E.read();
        if (_)
          return p.drain();
        x && x.length && p.fill(x);
      }
    }
    const l = await this.get(n);
    if (l === null)
      return Promise.resolve(null);
    const d = await Promise.all([
      l.error,
      s(l.data)
    ]);
    return d[0] ? Promise.reject(d[0]) : Promise.resolve(d[1]);
  }
  async get(n) {
    const s = await this.rawInfo(n);
    if (s === null || s.deleted)
      return Promise.resolve(null);
    if (s.options && s.options.link) {
      const N = s.options.link.name || "";
      if (N === "")
        throw new Error("link is a bucket");
      return (s.options.link.bucket !== this.name ? await Tm.create(this.js, s.options.link.bucket) : this).get(N);
    }
    const l = nr(), d = {
      info: new XE(s),
      error: l
    };
    if (s.size === 0)
      return d.data = AU(), l.resolve(null), Promise.resolve(d);
    let v;
    const p = Uu();
    p.orderedConsumer();
    const E = new b1(), _ = `$O.${this.name}.C.${s.nuid}`, x = await this.js.subscribe(_, p);
    return (async () => {
      for await (const N of x)
        if (N.data.length > 0 && (E.update(N.data), v.enqueue(N.data)), N.info.pending === 0) {
          const O = E.digest("base64"), P = O.length % 3, z = P > 0 ? "=".repeat(P) : "", B = `${k1}${O}${z}`;
          B !== s.digest ? v.error(new Error(`received a corrupt object, digests do not match received: ${s.digest} calculated ${B}`)) : v.close(), x.unsubscribe();
        }
    })().then(() => {
      l.resolve();
    }).catch((N) => {
      v.error(N), l.reject(N);
    }), d.data = new ReadableStream({
      start(N) {
        v = N;
      },
      cancel() {
        x.unsubscribe();
      }
    }), d;
  }
  linkStore(n, s) {
    if (!(s instanceof Tm))
      return Promise.reject("bucket required");
    const l = s, { name: d, error: v } = this._checkNotEmpty(n);
    if (v)
      return Promise.reject(v);
    const p = {
      name: d,
      options: {
        link: {
          bucket: l.name
        }
      }
    };
    return this._put(p, null);
  }
  async link(n, s) {
    const { name: l, error: d } = this._checkNotEmpty(n);
    if (d)
      return Promise.reject(d);
    if (s.deleted)
      return Promise.reject(new Error("src object is deleted"));
    if (s.isLink())
      return Promise.reject(new Error("src object is a link"));
    const v = await this.rawInfo(n);
    if (v !== null && !v.deleted)
      return Promise.reject(new Error("an object already exists with that name"));
    const p = {
      bucket: s.bucket,
      name: s.name
    }, E = {
      name: l,
      bucket: s.bucket,
      options: {
        link: p
      }
    };
    await this.js.publish(this._metaSubject(n), JSON.stringify(E));
    const _ = await this.info(n);
    return Promise.resolve(_);
  }
  async delete(n) {
    const s = await this.rawInfo(n);
    if (s === null)
      return Promise.resolve({
        purged: 0,
        success: !1
      });
    s.deleted = !0, s.size = 0, s.chunks = 0, s.digest = "";
    const l = no(), d = Ul();
    return d.set(sa.RollupHdr, sa.RollupValueSubject), await this.js.publish(this._metaSubject(s.name), l.encode(s), {
      headers: d
    }), this.jsm.streams.purge(this.stream, {
      filter: this._chunkSubject(s.nuid)
    });
  }
  async update(n, s = {}) {
    const l = await this.rawInfo(n);
    if (l === null)
      return Promise.reject(new Error("object not found"));
    if (l.deleted)
      return Promise.reject(new Error("cannot update meta for a deleted object"));
    s.name = s.name ?? l.name;
    const { name: d, error: v } = this._checkNotEmpty(s.name);
    if (v)
      return Promise.reject(v);
    if (n !== s.name) {
      const _ = await this.info(s.name);
      if (_ && !_.deleted)
        return Promise.reject(new Error("an object already exists with that name"));
    }
    s.name = d;
    const p = Object.assign({}, l, A1(s)), E = await this.js.publish(this._metaSubject(p.name), JSON.stringify(p));
    return n !== s.name && await this.jsm.streams.purge(this.stream, {
      filter: this._metaSubject(n)
    }), Promise.resolve(E);
  }
  async watch(n = {}) {
    n.includeHistory = n.includeHistory ?? !1, n.ignoreDeletes = n.ignoreDeletes ?? !1;
    let s = !1;
    const l = new ii(), d = this._metaSubjectAll();
    try {
      await this.jsm.streams.getMessage(this.stream, {
        last_by_subj: d
      });
    } catch (_) {
      _.code === "404" ? (l.push(null), s = !0) : l.stop(_);
    }
    const v = no(), p = Uu();
    p.orderedConsumer(), n.includeHistory ? p.deliverLastPerSubject() : (s = !0, p.deliverNew()), p.callback((_, x) => {
      if (_) {
        l.stop(_);
        return;
      }
      if (x !== null) {
        const N = v.decode(x.data);
        N.deleted && n.ignoreDeletes === !0 || l.push(N), x.info?.pending === 0 && !s && (s = !0, l.push(null));
      }
    });
    const E = await this.js.subscribe(d, p);
    return l._data = E, l.iterClosed.then(() => {
      E.unsubscribe();
    }), E.closed.then(() => {
      l.stop();
    }).catch((_) => {
      l.stop(_);
    }), l;
  }
  _chunkSubject(n) {
    return `$O.${this.name}.C.${n}`;
  }
  _metaSubject(n) {
    return `$O.${this.name}.M.${Cm.encode(n)}`;
  }
  _metaSubjectAll() {
    return `$O.${this.name}.M.>`;
  }
  async init(n = {}) {
    try {
      this.stream = bU(this.name);
    } catch (d) {
      return Promise.reject(d);
    }
    const s = n?.ttl || 0;
    delete n.ttl;
    const l = Object.assign({
      max_age: s
    }, n);
    l.name = this.stream, l.num_replicas = n.replicas ?? 1, l.allow_direct = !0, l.allow_rollup_hdrs = !0, l.discard = Mm.New, l.subjects = [
      `$O.${this.name}.C.>`,
      `$O.${this.name}.M.>`
    ], n.placement && (l.placement = n.placement), n.metadata && (l.metadata = n.metadata), typeof n.compression == "boolean" && (l.compression = n.compression ? Iu.S2 : Iu.None);
    try {
      await this.jsm.streams.info(l.name);
    } catch (d) {
      d.message === "stream not found" && await this.jsm.streams.add(l);
    }
  }
  static async create(n, s, l = {}) {
    const d = await n.jetstreamManager(), v = new Tm(s, d, n);
    return await v.init(l), Promise.resolve(v);
  }
}
class DU {
  js;
  constructor(n) {
    this.js = n;
  }
  kv(n, s = {}) {
    const l = this.js, { ok: d, min: v } = l.nc.features.get(vn.JS_KV);
    return d ? s.bindOnly ? Lm.bind(this.js, n, s) : Lm.create(this.js, n, s) : Promise.reject(new Error(`kv is only supported on servers ${v} or better`));
  }
  os(n, s = {}) {
    if (typeof crypto?.subtle?.digest != "function")
      return Promise.reject(new Error("objectstore: unable to calculate hashes - crypto.subtle.digest with sha256 support is required"));
    const l = this.js, { ok: d, min: v } = l.nc.features.get(vn.JS_OBJECTSTORE);
    return d ? Tm.create(this.js, n, s) : Promise.reject(new Error(`objectstore is only supported on servers ${v} or better`));
  }
}
class $w extends Vm {
  consumers;
  streams;
  consumerAPI;
  streamAPI;
  constructor(n, s) {
    super(n, s), this.consumerAPI = new Fw(n, s), this.streamAPI = new zw(n, s), this.consumers = new zT(this.consumerAPI), this.streams = new NU(this.streamAPI);
  }
  jetstreamManager(n) {
    n === void 0 && (n = this.opts.checkAPI);
    const s = Object.assign({}, this.opts, {
      checkAPI: n
    });
    return this.nc.jetstreamManager(s);
  }
  get apiPrefix() {
    return this.prefix;
  }
  get views() {
    return new DU(this);
  }
  async publish(n, s = Xa, l) {
    l = l || {}, l.expect = l.expect || {};
    const d = l?.headers || Ul();
    l && (l.msgID && d.set(Ho.MsgIdHdr, l.msgID), l.expect.lastMsgID && d.set(Ho.ExpectedLastMsgIdHdr, l.expect.lastMsgID), l.expect.streamName && d.set(Ho.ExpectedStreamHdr, l.expect.streamName), typeof l.expect.lastSequence == "number" && d.set(Ho.ExpectedLastSeqHdr, `${l.expect.lastSequence}`), typeof l.expect.lastSubjectSequence == "number" && d.set(Ho.ExpectedLastSubjectSequenceHdr, `${l.expect.lastSubjectSequence}`));
    const v = l.timeout || this.timeout, p = {};
    v && (p.timeout = v), l && (p.headers = d);
    let { retries: E, retry_delay: _ } = l;
    E = E || 1, _ = _ || 250;
    let x;
    for (let O = 0; O < E; O++)
      try {
        x = await this.nc.request(n, s, p);
        break;
      } catch (P) {
        if (P.code === "503" && O + 1 < E)
          await lh(_);
        else
          throw P;
      }
    const N = this.parseJsResponse(x);
    if (N.stream === "")
      throw nt.errorForCode(je.JetStreamInvalidAck);
    return N.duplicate = N.duplicate ? N.duplicate : !1, N;
  }
  async pull(n, s, l = 0) {
    ia(n), Kd(s);
    let d = this.timeout;
    l > d && (d = l), l = l < 0 ? 0 : fr(l);
    const v = {
      batch: 1,
      no_wait: l === 0,
      expires: l
    }, p = await this.nc.request(`${this.prefix}.CONSUMER.MSG.NEXT.${n}.${s}`, this.jc.encode(v), {
      noMux: !0,
      timeout: d
    }), E = Xd(p);
    if (E)
      throw E;
    return Pm(p, this.timeout);
  }
  fetch(n, s, l = {}) {
    ia(n), Kd(s);
    let d = null;
    const v = (l.max_bytes ?? 0) > 0;
    let p = 0;
    const E = v ? l.max_bytes : 0;
    let _ = null;
    const x = {};
    if (x.batch = l.batch || 1, E) {
      const be = this.nc.features.get(vn.JS_PULL_MAX_BYTES);
      if (!be.ok)
        throw new Error(`max_bytes is only supported on servers ${be.min} or better`);
      x.max_bytes = E;
    }
    x.no_wait = l.no_wait || !1, x.no_wait && x.expires && (x.expires = 0);
    const N = l.expires || 0;
    if (N && (x.expires = fr(N)), N === 0 && x.no_wait === !1)
      throw new Error("expires or no_wait is required");
    const O = l.idle_heartbeat || 0;
    O && (x.idle_heartbeat = fr(O), l.delay_heartbeat === !0 && (x.idle_heartbeat = fr(O * 4)));
    const P = new ii(), z = x.batch;
    let B = 0;
    P.protocolFilterFn = (be, ae = !1) => mw(be.msg) ? (_?.work(), !1) : !0, P.dispatchedFn = (be) => {
      if (be) {
        if (v && (p += be.data.length), B++, d && be.info.pending === 0)
          return;
        (P.getPending() === 1 && be.info.pending === 0 || z === B || E > 0 && p >= E) && P.stop();
      }
    };
    const ie = Pl(this.nc.options.inboxPrefix), K = this.nc.subscribe(ie, {
      max: l.batch,
      callback: (be, ae) => {
        be === null && (be = Xd(ae)), be !== null ? (d && (d.cancel(), d = null), t2(be) ? P.stop(BT(be) === null ? void 0 : be) : P.stop(be)) : (_?.work(), P.received++, P.push(Pm(ae, this.timeout)));
      }
    });
    return N && (d = th(N), d.catch(() => {
      K.isClosed() || (K.drain().catch(() => {
      }), d = null), _ && _.cancel();
    })), (async () => {
      try {
        O && (_ = new Uw(O, (be) => (P.push(() => {
          P.err = new nt(`${xs.IdleHeartbeatMissed}: ${be}`, je.JetStreamIdleHeartBeat);
        }), !0)));
      } catch {
      }
      await K.closed, d !== null && (d.cancel(), d = null), _ && _.cancel(), P.stop();
    })().catch(), this.nc.publish(`${this.prefix}.CONSUMER.MSG.NEXT.${n}.${s}`, this.jc.encode(x), {
      reply: ie
    }), P;
  }
  async pullSubscribe(n, s = Uu()) {
    const l = await this._processOptions(n, s);
    if (l.ordered)
      throw new Error("pull subscribers cannot be be ordered");
    if (l.config.deliver_subject)
      throw new Error("consumer info specifies deliver_subject - pull consumers cannot have deliver_subject set");
    const d = l.config.ack_policy;
    if (d === Pr.None || d === Pr.All)
      throw new Error("ack policy for pull consumers must be explicit");
    const v = this._buildTypedSubscriptionOpts(l), p = new PU(this, l.deliver, v);
    p.info = l;
    try {
      await this._maybeCreateConsumer(l);
    } catch (E) {
      throw p.unsubscribe(), E;
    }
    return p;
  }
  async subscribe(n, s = Uu()) {
    const l = await this._processOptions(n, s);
    if (!l.isBind && !l.config.deliver_subject)
      throw new Error("push consumer requires deliver_subject");
    const d = this._buildTypedSubscriptionOpts(l), v = new $T(this, l.deliver, d);
    v.info = l;
    try {
      await this._maybeCreateConsumer(l);
    } catch (p) {
      throw v.unsubscribe(), p;
    }
    return v._maybeSetupHbMonitoring(), v;
  }
  async _processOptions(n, s = Uu()) {
    const l = g1(s) ? s.getOpts() : s;
    if (l.isBind = g1(s) ? s.isBind : !1, l.flow_control = {
      heartbeat_count: 0,
      fc_count: 0,
      consumer_restarts: 0
    }, l.ordered) {
      if (l.ordered_consumer_sequence = {
        stream_seq: 0,
        delivery_seq: 0
      }, l.config.ack_policy !== Pr.NotSet && l.config.ack_policy !== Pr.None)
        throw new nt("ordered consumer: ack_policy can only be set to 'none'", je.ApiError);
      if (l.config.durable_name && l.config.durable_name.length > 0)
        throw new nt("ordered consumer: durable_name cannot be set", je.ApiError);
      if (l.config.deliver_subject && l.config.deliver_subject.length > 0)
        throw new nt("ordered consumer: deliver_subject cannot be set", je.ApiError);
      if (l.config.max_deliver !== void 0 && l.config.max_deliver > 1)
        throw new nt("ordered consumer: max_deliver cannot be set", je.ApiError);
      if (l.config.deliver_group && l.config.deliver_group.length > 0)
        throw new nt("ordered consumer: deliver_group cannot be set", je.ApiError);
      l.config.deliver_subject = Pl(this.nc.options.inboxPrefix), l.config.ack_policy = Pr.None, l.config.max_deliver = 1, l.config.flow_control = !0, l.config.idle_heartbeat = l.config.idle_heartbeat || fr(5e3), l.config.ack_wait = fr(22 * 60 * 60 * 1e3), l.config.mem_storage = !0, l.config.num_replicas = 1;
    }
    if (l.config.ack_policy === Pr.NotSet && (l.config.ack_policy = Pr.All), l.api = this, l.config = l.config || {}, l.stream = l.stream ? l.stream : await this.findStream(n), l.attached = !1, l.config.durable_name)
      try {
        const d = await this.consumerAPI.info(l.stream, l.config.durable_name);
        if (d) {
          if (d.config.filter_subject && d.config.filter_subject !== n)
            throw new Error("subject does not match consumer");
          const v = l.config.deliver_group ?? "";
          if (v === "" && d.push_bound === !0)
            throw new Error("duplicate subscription");
          const p = d.config.deliver_group ?? "";
          if (v !== p)
            throw p === "" ? new Error("durable requires no queue group") : new Error(`durable requires queue group '${p}'`);
          l.last = d, l.config = d.config, l.attached = !0, l.config.durable_name || (l.name = d.name);
        }
      } catch (d) {
        if (d.code !== "404")
          throw d;
      }
    return !l.attached && l.config.filter_subject === void 0 && l.config.filter_subjects === void 0 && (l.config.filter_subject = n), l.deliver = l.config.deliver_subject || Pl(this.nc.options.inboxPrefix), l;
  }
  _buildTypedSubscriptionOpts(n) {
    const s = {};
    return s.adapter = UU(n.callbackFn === void 0, this.timeout), s.ingestionFilterFn = $w.ingestionFn(n.ordered), s.protocolFilterFn = (l, d = !1) => {
      const v = l;
      return pw(v.msg) ? (d || v.msg.respond(), !1) : !0;
    }, !n.mack && n.config.ack_policy !== Pr.None && (s.dispatchedFn = zU), n.callbackFn && (s.callback = n.callbackFn), s.max = n.max || 0, s.queue = n.queue, s;
  }
  async _maybeCreateConsumer(n) {
    if (n.attached)
      return;
    if (n.isBind)
      throw new Error(`unable to bind - durable consumer ${n.config.durable_name} doesn't exist in ${n.stream}`);
    n.config = Object.assign({
      deliver_policy: Ar.All,
      ack_policy: Pr.Explicit,
      ack_wait: fr(30 * 1e3),
      replay_policy: nh.Instant
    }, n.config);
    const s = await this.consumerAPI.add(n.stream, n.config);
    if (Array.isArray(n.config.filter_subjects && !Array.isArray(s.config.filter_subjects)))
      throw new Error("jetstream server doesn't support consumers with multiple filter subjects");
    n.name = s.name, n.config = s.config, n.last = s;
  }
  static ingestionFn(n) {
    return (s, l) => {
      const d = l;
      if (!s) return {
        ingest: !1,
        protocol: !1
      };
      const v = s;
      if (Xd(v.msg) || d.monitor?.work(), mw(v.msg)) {
        const E = n ? d._checkHbOrderConsumer(v.msg) : !0;
        return n || d.info.flow_control.heartbeat_count++, {
          ingest: E,
          protocol: !0
        };
      } else if (pw(v.msg))
        return d.info.flow_control.fc_count++, {
          ingest: !0,
          protocol: !0
        };
      return {
        ingest: n ? d._checkOrderedConsumer(s) : !0,
        protocol: !1
      };
    };
  }
}
class Bw {
  options;
  protocol;
  draining;
  listeners;
  _services;
  constructor(n) {
    this.draining = !1, this.options = eU(n), this.listeners = [];
  }
  static connect(n = {}) {
    return new Promise((s, l) => {
      const d = new Bw(n);
      o0.connect(d.options, d).then((v) => {
        d.protocol = v, async function() {
          for await (const p of v.status())
            d.listeners.forEach((E) => {
              E.push(p);
            });
        }(), s(d);
      }).catch((v) => {
        l(v);
      });
    });
  }
  closed() {
    return this.protocol.closed;
  }
  async close() {
    await this.protocol.close();
  }
  _check(n, s, l) {
    if (this.isClosed())
      throw nt.errorForCode(je.ConnectionClosed);
    if (s && this.isDraining() || l && this.protocol.noMorePublishing)
      throw nt.errorForCode(je.ConnectionDraining);
    if (n = n || "", n.length === 0)
      throw nt.errorForCode(je.BadSubject);
  }
  publish(n, s, l) {
    this._check(n, !1, !0), this.protocol.publish(n, s, l);
  }
  publishMessage(n) {
    return this.publish(n.subject, n.data, {
      reply: n.reply,
      headers: n.headers
    });
  }
  respondMessage(n) {
    return n.reply ? (this.publish(n.reply, n.data, {
      reply: n.reply,
      headers: n.headers
    }), !0) : !1;
  }
  subscribe(n, s = {}) {
    this._check(n, !0, !1);
    const l = new PT(this.protocol, n, s);
    return this.protocol.subscribe(l), l;
  }
  _resub(n, s, l) {
    this._check(s, !0, !1);
    const d = n;
    d.max = l, l && (d.max = l + d.received), this.protocol.resub(d, s);
  }
  requestMany(n, s = Xa, l = {
    maxWait: 1e3,
    maxMessages: -1
  }) {
    const d = !this.protocol.options.noAsyncTraces;
    try {
      this._check(n, !0, !0);
    } catch (_) {
      return Promise.reject(_);
    }
    if (l.strategy = l.strategy || to.Timer, l.maxWait = l.maxWait || 1e3, l.maxWait < 1)
      return Promise.reject(new nt("timeout", je.InvalidOption));
    const v = new ii();
    function p(_) {
      v.push(() => {
        v.stop(_);
      });
    }
    function E(_, x) {
      _ || x === null ? p(_ === null ? void 0 : _) : v.push(x);
    }
    if (l.noMux) {
      const _ = d ? new Error().stack : null;
      let x = typeof l.maxMessages == "number" && l.maxMessages > 0 ? l.maxMessages : -1;
      const N = this.subscribe(Pl(this.options.inboxPrefix), {
        callback: (B, ie) => {
          if (ie?.data?.length === 0 && ie?.headers?.status === je.NoResponders && (B = nt.errorForCode(je.NoResponders)), B) {
            _ && (B.stack += `

${_}`), O(B);
            return;
          }
          E(null, ie), l.strategy === to.Count && (x--, x === 0 && O()), l.strategy === to.JitterTimer && (z(), P = setTimeout(() => {
            O();
          }, 300)), l.strategy === to.SentinelMsg && ie && ie.data.length === 0 && O();
        }
      });
      N.requestSubject = n, N.closed.then(() => {
        p();
      }).catch((B) => {
        v.stop(B);
      });
      const O = (B) => {
        B && v.push(() => {
          throw B;
        }), z(), N.drain().then(() => {
          p();
        }).catch((ie) => {
          p();
        });
      };
      v.iterClosed.then(() => {
        z(), N?.unsubscribe();
      }).catch((B) => {
        z(), N?.unsubscribe();
      });
      try {
        this.publish(n, s, {
          reply: N.getSubject()
        });
      } catch (B) {
        O(B);
      }
      let P = setTimeout(() => {
        O();
      }, l.maxWait);
      const z = () => {
        P && clearTimeout(P);
      };
    } else {
      const _ = l;
      _.callback = E, v.iterClosed.then(() => {
        x.cancel();
      }).catch((N) => {
        x.cancel(N);
      });
      const x = new b2(this.protocol.muxSubscriptions, n, _);
      this.protocol.request(x);
      try {
        this.publish(n, s, {
          reply: `${this.protocol.muxSubscriptions.baseInbox}${x.token}`,
          headers: l.headers
        });
      } catch (N) {
        x.cancel(N);
      }
    }
    return Promise.resolve(v);
  }
  request(n, s, l = {
    timeout: 1e3,
    noMux: !1
  }) {
    try {
      this._check(n, !0, !0);
    } catch (v) {
      return Promise.reject(v);
    }
    const d = !this.protocol.options.noAsyncTraces;
    if (l.timeout = l.timeout || 1e3, l.timeout < 1)
      return Promise.reject(new nt("timeout", je.InvalidOption));
    if (!l.noMux && l.reply)
      return Promise.reject(new nt("reply can only be used with noMux", je.InvalidOption));
    if (l.noMux) {
      const v = l.reply ? l.reply : Pl(this.options.inboxPrefix), p = nr(), E = d ? new Error() : null, _ = this.subscribe(v, {
        max: 1,
        timeout: l.timeout,
        callback: (x, N) => {
          x ? (E && x.code !== je.Timeout && (x.stack += `

${E.stack}`), _.unsubscribe(), p.reject(x)) : (x = xT(N), x ? (E && (x.stack += `

${E.stack}`), p.reject(x)) : p.resolve(N));
        }
      });
      return _.requestSubject = n, this.protocol.publish(n, s, {
        reply: v,
        headers: l.headers
      }), p;
    } else {
      const v = new NT(this.protocol.muxSubscriptions, n, l, d);
      this.protocol.request(v);
      try {
        this.publish(n, s, {
          reply: `${this.protocol.muxSubscriptions.baseInbox}${v.token}`,
          headers: l.headers
        });
      } catch (E) {
        v.cancel(E);
      }
      const p = Promise.race([
        v.timer,
        v.deferred
      ]);
      return p.catch(() => {
        v.cancel();
      }), p;
    }
  }
  flush() {
    return this.isClosed() ? Promise.reject(nt.errorForCode(je.ConnectionClosed)) : this.protocol.flush();
  }
  drain() {
    return this.isClosed() ? Promise.reject(nt.errorForCode(je.ConnectionClosed)) : this.isDraining() ? Promise.reject(nt.errorForCode(je.ConnectionDraining)) : (this.draining = !0, this.protocol.drain());
  }
  isClosed() {
    return this.protocol.isClosed();
  }
  isDraining() {
    return this.draining;
  }
  getServer() {
    const n = this.protocol.getServer();
    return n ? n.listen : "";
  }
  status() {
    const n = new ii();
    return n.iterClosed.then(() => {
      const s = this.listeners.indexOf(n);
      this.listeners.splice(s, 1);
    }), this.listeners.push(n), n;
  }
  get info() {
    return this.protocol.isClosed() ? void 0 : this.protocol.info;
  }
  async context() {
    return (await this.request("$SYS.REQ.USER.INFO")).json((s, l) => s === "time" ? new Date(Date.parse(l)) : l);
  }
  stats() {
    return {
      inBytes: this.protocol.inBytes,
      outBytes: this.protocol.outBytes,
      inMsgs: this.protocol.inMsgs,
      outMsgs: this.protocol.outMsgs
    };
  }
  async jetstreamManager(n = {}) {
    const s = new kU(this, n);
    if (n.checkAPI !== !1)
      try {
        await s.getAccountInfo();
      } catch (l) {
        const d = l;
        throw d.code === je.NoResponders && (d.code = je.JetStreamNotEnabled), d;
      }
    return s;
  }
  jetstream(n = {}) {
    return new $w(this, n);
  }
  getServerVersion() {
    const n = this.info;
    return n ? rf(n.version) : void 0;
  }
  async rtt() {
    if (!this.protocol._closed && !this.protocol.connected)
      throw nt.errorForCode(je.Disconnect);
    const n = Date.now();
    return await this.flush(), Date.now() - n;
  }
  get features() {
    return this.protocol.features;
  }
  get services() {
    return this._services || (this._services = new MU(this)), this._services;
  }
  reconnect() {
    return this.isClosed() ? Promise.reject(nt.errorForCode(je.ConnectionClosed)) : this.isDraining() ? Promise.reject(nt.errorForCode(je.ConnectionDraining)) : this.protocol.reconnect();
  }
}
class MU {
  nc;
  constructor(n) {
    this.nc = n;
  }
  add(n) {
    try {
      return new qm(this.nc, n).start();
    } catch (s) {
      return Promise.reject(s);
    }
  }
  client(n, s) {
    return new fU(this.nc, n, s);
  }
}
class jU {
  bucket;
  sm;
  prefixLen;
  constructor(n, s, l) {
    this.bucket = n, this.prefixLen = s, this.sm = l;
  }
  get key() {
    return this.sm.subject.substring(this.prefixLen);
  }
  get value() {
    return this.sm.data;
  }
  get delta() {
    return 0;
  }
  get created() {
    return this.sm.time;
  }
  get revision() {
    return this.sm.seq;
  }
  get operation() {
    return this.sm.header.get(l0) || "PUT";
  }
  get length() {
    const n = this.sm.header.get(sa.MessageSizeHdr) || "";
    return n !== "" ? parseInt(n, 10) : this.sm.data.length;
  }
  json() {
    return this.sm.json();
  }
  string() {
    return this.sm.string();
  }
}
class LU {
  bucket;
  key;
  sm;
  constructor(n, s, l) {
    this.bucket = n, this.key = s, this.sm = l;
  }
  get value() {
    return this.sm.data;
  }
  get created() {
    return new Date(Pw(this.sm.info.timestampNanos));
  }
  get revision() {
    return this.sm.seq;
  }
  get operation() {
    return this.sm.headers?.get(l0) || "PUT";
  }
  get delta() {
    return this.sm.info.pending;
  }
  get length() {
    const n = this.sm.headers?.get(sa.MessageSizeHdr) || "";
    return n !== "" ? parseInt(n, 10) : this.sm.data.length;
  }
  json() {
    return this.sm.json();
  }
  string() {
    return this.sm.string();
  }
}
class $T extends _2 {
  js;
  monitor;
  constructor(n, s, l) {
    super(n.nc, s, l), this.js = n, this.monitor = null, this.sub.closed.then(() => {
      this.monitor && this.monitor.cancel();
    });
  }
  set info(n) {
    this.sub.info = n;
  }
  get info() {
    return this.sub.info;
  }
  _resetOrderedConsumer(n) {
    if (this.info === null || this.sub.isClosed())
      return;
    const s = Pl(this.js.nc.options.inboxPrefix);
    this.js.nc._resub(this.sub, s);
    const d = this.info;
    d.config.name = of.next(), d.ordered_consumer_sequence.delivery_seq = 0, d.flow_control.heartbeat_count = 0, d.flow_control.fc_count = 0, d.flow_control.consumer_restarts++, d.deliver = s, d.config.deliver_subject = s, d.config.deliver_policy = Ar.StartSequence, d.config.opt_start_seq = n;
    const v = {};
    v.stream_name = this.info.stream, v.config = d.config;
    const p = `${d.api.prefix}.CONSUMER.CREATE.${d.stream}`;
    this.js._request(p, v, {
      retries: -1
    }).then((E) => {
      const _ = E, x = this.sub.info;
      x.last = _, this.info.config = _.config, this.info.name = _.name;
    }).catch((E) => {
      const _ = new nt(`unable to recreate ordered consumer ${d.stream} at seq ${n}`, je.RequestError, E);
      this.sub.callback(_, {});
    });
  }
  _maybeSetupHbMonitoring() {
    const n = this.info?.config?.idle_heartbeat || 0;
    n && this._setupHbMonitoring(Pw(n));
  }
  _setupHbMonitoring(n, s = 0) {
    const l = {
      cancelAfter: 0,
      maxOut: 2
    };
    s && (l.cancelAfter = s);
    const d = this.sub, v = (p) => {
      const E = a2(409, `${xs.IdleHeartbeatMissed}: ${p}`, this.sub.subject);
      if (!this.info?.ordered)
        this.sub.callback(null, E);
      else {
        if (!this.js.nc.protocol.connected)
          return !1;
        const x = this.info?.ordered_consumer_sequence?.stream_seq || 0;
        return this._resetOrderedConsumer(x + 1), this.monitor?.restart(), !1;
      }
      return !d.noIterator;
    };
    this.monitor = new Uw(n, v, l);
  }
  _checkHbOrderConsumer(n) {
    const s = n.headers.get(sa.ConsumerStalledHdr);
    s !== "" && this.js.nc.publish(s);
    const l = parseInt(n.headers.get(sa.LastConsumerSeqHdr), 10), d = this.info.ordered_consumer_sequence;
    return this.info.flow_control.heartbeat_count++, l !== d.delivery_seq && this._resetOrderedConsumer(d.stream_seq + 1), !1;
  }
  _checkOrderedConsumer(n) {
    const s = this.info.ordered_consumer_sequence, l = n.info.streamSequence, d = n.info.deliverySequence;
    return d != s.delivery_seq + 1 ? (this._resetOrderedConsumer(s.stream_seq + 1), !1) : (s.delivery_seq = d, s.stream_seq = l, !0);
  }
  async destroy() {
    this.isClosed() || await this.drain();
    const n = this.sub.info, s = n.config.durable_name || n.name, l = `${n.api.prefix}.CONSUMER.DELETE.${n.stream}.${s}`;
    await n.api._request(l);
  }
  async consumerInfo() {
    const n = this.sub.info, s = n.config.durable_name || n.name, l = `${n.api.prefix}.CONSUMER.INFO.${n.stream}.${s}`, d = await n.api._request(l);
    return n.last = d, d;
  }
}
class PU extends $T {
  constructor(n, s, l) {
    super(n, s, l);
  }
  pull(n = {
    batch: 1
  }) {
    const { stream: s, config: l, name: d } = this.sub.info, v = l.durable_name ?? d, p = {};
    if (p.batch = n.batch || 1, p.no_wait = n.no_wait || !1, (n.max_bytes ?? 0) > 0) {
      const x = this.js.nc.features.get(vn.JS_PULL_MAX_BYTES);
      if (!x.ok)
        throw new Error(`max_bytes is only supported on servers ${x.min} or better`);
      p.max_bytes = n.max_bytes;
    }
    let E = 0;
    n.expires && n.expires > 0 && (E = n.expires, p.expires = fr(E));
    let _ = 0;
    if (n.idle_heartbeat && n.idle_heartbeat > 0 && (_ = n.idle_heartbeat, p.idle_heartbeat = fr(_)), _ && E === 0)
      throw new Error("idle_heartbeat requires expires");
    if (_ > E)
      throw new Error("expires must be greater than idle_heartbeat");
    if (this.info) {
      this.monitor && this.monitor.cancel(), E && _ && (this.monitor ? this.monitor._change(_, E) : this._setupHbMonitoring(_, E));
      const x = this.info.api, N = `${x.prefix}.CONSUMER.MSG.NEXT.${s}.${v}`, O = this.sub.subject;
      x.nc.publish(N, x.jc.encode(p), {
        reply: O
      });
    }
  }
}
function UU(o, n) {
  return o ? IU(n) : FU(n);
}
function FU(o) {
  return (n, s) => n ? [
    n,
    null
  ] : (n = Xd(s), n ? [
    n,
    null
  ] : [
    null,
    Pm(s, o)
  ]);
}
function IU(o) {
  return (n, s) => {
    if (n)
      return [
        n,
        null
      ];
    const l = Xd(s);
    return l !== null ? [
      BT(l),
      null
    ] : [
      null,
      Pm(s, o)
    ];
  };
}
function BT(o) {
  if (o !== null)
    switch (o.code) {
      case je.JetStream404NoMessages:
      case je.JetStream408RequestTimeout:
        return null;
      case je.JetStream409:
        return s2(o) ? o : null;
      default:
        return o;
    }
  return null;
}
function zU(o) {
  o && o.ack();
}
function $U(o) {
  const n = o.split(".");
  if (n.length === 9 && n.splice(2, 0, "_", ""), n.length < 11 || n[0] !== "$JS" || n[1] !== "ACK")
    throw new Error("not js message");
  const s = {};
  return s.domain = n[2] === "_" ? "" : n[2], s.account_hash = n[3], s.stream = n[4], s.consumer = n[5], s.redeliveryCount = parseInt(n[6], 10), s.redelivered = s.redeliveryCount > 1, s.streamSequence = parseInt(n[7], 10), s.deliverySequence = parseInt(n[8], 10), s.timestampNanos = parseInt(n[9], 10), s.pending = parseInt(n[10], 10), s;
}
class BU {
  msg;
  di;
  didAck;
  timeout;
  constructor(n, s) {
    this.msg = n, this.didAck = !1, this.timeout = s;
  }
  get subject() {
    return this.msg.subject;
  }
  get sid() {
    return this.msg.sid;
  }
  get data() {
    return this.msg.data;
  }
  get headers() {
    return this.msg.headers;
  }
  get info() {
    return this.di || (this.di = $U(this.reply)), this.di;
  }
  get redelivered() {
    return this.info.redeliveryCount > 1;
  }
  get reply() {
    return this.msg.reply || "";
  }
  get seq() {
    return this.info.streamSequence;
  }
  doAck(n) {
    this.didAck || (this.didAck = !this.isWIP(n), this.msg.respond(n));
  }
  isWIP(n) {
    return n.length === 4 && n[0] === gm[0] && n[1] === gm[1] && n[2] === gm[2] && n[3] === gm[3];
  }
  async ackAck(n) {
    n = n || {}, n.timeout = n.timeout || this.timeout;
    const s = nr();
    if (this.didAck)
      s.resolve(!1);
    else if (this.didAck = !0, this.msg.reply) {
      const d = this.msg.publisher, v = !d.options?.noAsyncTraces, p = new NT(d.muxSubscriptions, this.msg.reply, {
        timeout: n.timeout
      }, v);
      d.request(p);
      try {
        d.publish(this.msg.reply, O1, {
          reply: `${d.muxSubscriptions.baseInbox}${p.token}`
        });
      } catch (E) {
        p.cancel(E);
      }
      try {
        await Promise.race([
          p.timer,
          p.deferred
        ]), s.resolve(!0);
      } catch (E) {
        p.cancel(E), s.reject(E);
      }
    } else
      s.resolve(!1);
    return s;
  }
  ack() {
    this.doAck(O1);
  }
  nak(n) {
    let s = EU;
    n && (s = hw().encode(`-NAK ${JSON.stringify({
      delay: fr(n)
    })}`)), this.doAck(s);
  }
  working() {
    this.doAck(gm);
  }
  next(n, s = {
    batch: 1
  }) {
    const l = {};
    l.batch = s.batch || 1, l.no_wait = s.no_wait || !1, s.expires && s.expires > 0 && (l.expires = fr(s.expires));
    const d = no().encode(l), v = rh.concat(wU, xU, d), p = n ? {
      reply: n
    } : void 0;
    this.msg.respond(v, p);
  }
  term(n = "") {
    let s = _U;
    n?.length > 0 && (s = hw().encode(`+TERM ${n}`)), this.doAck(s);
  }
  json() {
    return this.msg.json();
  }
  string() {
    return this.msg.string();
  }
}
const HU = "1.29.2", VU = "nats.ws";
class qU {
  version;
  lang;
  closeError;
  connected;
  done;
  socket;
  options;
  socketClosed;
  encrypted;
  peeked;
  yields;
  signal;
  closedNotification;
  constructor() {
    this.version = HU, this.lang = VU, this.connected = !1, this.done = !1, this.socketClosed = !1, this.encrypted = !1, this.peeked = !1, this.yields = [], this.signal = nr(), this.closedNotification = nr();
  }
  async connect(n, s) {
    const l = nr();
    if (s.tls)
      return l.reject(new nt("tls", je.InvalidOption)), l;
    this.options = s;
    const d = n.src;
    if (s.wsFactory) {
      const { socket: v, encrypted: p } = await s.wsFactory(n.src, s);
      this.socket = v, this.encrypted = p;
    } else
      this.encrypted = d.indexOf("wss://") === 0, this.socket = new WebSocket(d);
    return this.socket.binaryType = "arraybuffer", this.socket.onopen = () => {
      this.isDiscarded();
    }, this.socket.onmessage = (v) => {
      if (this.isDiscarded())
        return;
      if (this.yields.push(new Uint8Array(v.data)), this.peeked) {
        this.signal.resolve();
        return;
      }
      const p = rh.concat(...this.yields), E = O2(p);
      if (E !== "") {
        const _ = rU.exec(E);
        if (!_) {
          s.debug && console.error("!!!", zy(p)), l.reject(new Error("unexpected response from server"));
          return;
        }
        try {
          const x = JSON.parse(_[1]);
          tU(x, this.options), this.peeked = !0, this.connected = !0, this.signal.resolve(), l.resolve();
        } catch (x) {
          l.reject(x);
          return;
        }
      }
    }, this.socket.onclose = (v) => {
      if (this.isDiscarded())
        return;
      this.socketClosed = !0;
      let p;
      this.done || (v.wasClean || (p = new Error(v.reason)), this._closed(p));
    }, this.socket.onerror = (v) => {
      if (this.isDiscarded())
        return;
      const p = v, E = new nt(p.message, je.Unknown, new Error(p.error));
      l.reject(E);
    }, l;
  }
  disconnect() {
    this._closed(void 0, !0);
  }
  async _closed(n, s = !0) {
    if (!this.isDiscarded() && this.connected && !this.done) {
      if (this.closeError = n, !n)
        for (; !this.socketClosed && this.socket.bufferedAmount > 0; )
          await lh(100);
      this.done = !0;
      try {
        this.socket.close(n ? 1002 : 1e3, n ? n.message : void 0);
      } catch {
      }
      s && this.closedNotification.resolve(n);
    }
  }
  get isClosed() {
    return this.done;
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  async *iterate() {
    for (; ; ) {
      if (this.isDiscarded())
        return;
      this.yields.length === 0 && await this.signal;
      const n = this.yields;
      this.yields = [];
      for (let s = 0; s < n.length; s++)
        this.options.debug && console.info(`> ${zy(n[s])}`), yield n[s];
      if (this.done)
        break;
      this.yields.length === 0 && (n.length = 0, this.yields = n, this.signal = nr());
    }
  }
  isEncrypted() {
    return this.connected && this.encrypted;
  }
  send(n) {
    if (!this.isDiscarded())
      try {
        this.socket.send(n.buffer), this.options.debug && console.info(`< ${zy(n)}`);
        return;
      } catch (s) {
        this.options.debug && console.error(`!!! ${zy(n)}: ${s}`);
      }
  }
  close(n) {
    return this._closed(n, !1);
  }
  closed() {
    return this.closedNotification;
  }
  isDiscarded() {
    return this.done ? (this.discard(), !0) : !1;
  }
  discard() {
    this.done = !0;
    try {
      this.socket?.close();
    } catch {
    }
  }
}
function YU(o, n) {
  /^(.*:\/\/)(.*)/.test(o) || (typeof n == "boolean" ? o = `${n === !0 ? "https" : "http"}://${o}` : o = `https://${o}`);
  let l = new URL(o);
  const d = l.protocol.toLowerCase();
  d === "ws:" && (n = !1), d === "wss:" && (n = !0), d !== "https:" && d !== "http" && (o = o.replace(/^(.*:\/\/)(.*)/gm, "$2"), l = new URL(`http://${o}`));
  let v, p;
  const E = l.hostname, _ = l.pathname, x = l.search || "";
  switch (d) {
    case "http:":
    case "ws:":
    case "nats:":
      p = l.port || "80", v = "ws:";
      break;
    case "https:":
    case "wss:":
    case "tls:":
      p = l.port || "443", v = "wss:";
      break;
    default:
      p = l.port || n === !0 ? "443" : "80", v = n === !0 ? "wss:" : "ws:";
      break;
  }
  return `${v}//${E}:${p}${_}${x}`;
}
function D1(o = {}) {
  return x2({
    defaultPort: 443,
    urlParseFn: YU,
    factory: () => new qU()
  }), Bw.connect(o);
}
const ym = (o) => {
  let n = o.data;
  o.data instanceof Uint8Array && (n = btoa(String.fromCharCode(...o.data)));
  const s = {
    ...o,
    data: n
    // Asignar la versin en base64
  };
  return JSON.stringify(s);
}, WU = (o) => {
  console.log("deserializeMessage:", o);
  const n = JSON.parse(o);
  if (n.data) {
    const s = atob(n.data);
    n.data = s;
  }
  return n;
}, ZE = (o, n) => ({
  subject: o,
  // El nombre del topic
  data: new TextEncoder().encode(n),
  // Convertir el mensaje de texto a Uint8Array
  timestamp: (/* @__PURE__ */ new Date()).toISOString(),
  // Timestamp actual
  headers: {}
  // Si necesitas agregar encabezados, puedes hacerlo aqu
}), ew = "ws://localhost:8080".split(",") || ["ws://localhost:8080"], ww = "principal", M1 = "user", j1 = "user123", u0 = "roomlistusers", _w = "MYGOCHAT_STREAM";
class Hw {
  nc = null;
  // Conexin a nats
  jsm = null;
  // Gestor de streams de nats
  js = null;
  // Cliente de streams de nats
  codec = hw();
  // Codificador de mensajes
  producersConsumers = /* @__PURE__ */ new Map();
  _isConnected = !1;
  // Estado de la conexin
  subscribedTopics = /* @__PURE__ */ new Set();
  // Conjunto de temas a los que se ha suscrito
  get isConnected() {
    return this._isConnected;
  }
  static async create(n) {
    const s = ew, l = new Hw();
    return n = n || "user-default", await l.connect(n, s).catch((d) => {
      console.error("Error al conectar en el constructor:", d);
    }), console.log("En final de create: Hemos creado los productores y consumidore "), console.log(l.producersConsumers), l;
  }
  constructor() {
    console.log(" Constructor NatsManagement");
  }
  // Mtodo para establecer la conexin a NATS y JetStream
  async connect(n, s) {
    try {
      const l = {
        servers: ew,
        // Usar la URL de NATS desde las variables de entorno
        user: M1,
        // El usuario de NATS desde las variables de entorno
        pass: j1
        // La contrasea de NATS desde las variables de entorno
        //protocol: 'ws',            // Asegrate de indicar que usas WebSocket
        //port:8080,
      };
      if (console.log("Iniciando conexin con NATS:", l), this.nc = await D1(l), console.log("Conexin establecida con NATS:", s), this.jsm = await this.nc.jetstreamManager(), this.js = this.nc.jetstream(), this.jsm && this.js)
        console.log("JetStream Manager y Client inicializados correctamente.");
      else
        throw new Error("Fallo al inicializar JetStream Manager o Client.");
      console.log("Iniciando configuracin de streams para los topics..."), await this.ensureTopicExists(ww, null), await this.ensureTopicExists(u0, n), console.log("Todos los streams y consumidores configurados."), this._isConnected = !0;
    } catch (l) {
      throw console.error("Error al conectar con NATS:", l), l;
    }
  }
  // Funcin para registrar productor y consumidor con sus respectivos subjects
  ProducerConsumer(n, s, l, d, v) {
    this.producersConsumers.set(n, {
      producer: s,
      consumer: l,
      producerSubject: d,
      consumerSubject: v
    });
  }
  getProducerForTopic(n) {
    return this.producersConsumers.get(n)?.producer;
  }
  getProducerSubjectForTopic(n) {
    return this.producersConsumers.get(n)?.producerSubject ?? "defaultSubject";
  }
  getConsumerForTopic(n) {
    return this.producersConsumers.get(n);
  }
  getConsumerSubjectForTopic(n) {
    return this.producersConsumers.get(n)?.consumerSubject ?? "defaultConsumerSubject";
  }
  createNatsMessage(n, s) {
    const l = {
      roomId: n.roomid,
      nickname: n.nickname,
      tokensession: n.tokensession,
      roomname: n.roomname
    };
    new TextEncoder();
    const d = /* @__PURE__ */ new Date();
    return {
      subject: s,
      data: btoa(n),
      //Buffer.from(JSON.stringify(requestData))
      timestamp: d.toLocaleTimeString(),
      headers: l
    };
  }
  // Verifica si un stream existe, si no, lo crea
  // Verifica si un stream existe, si no, lo crea
  async ensureTopicExists(n, s) {
    console.log(`ensureTopicExists iniciado: topic=${n}, nickname=${s}`);
    const l = `${n}.server`, d = s ? `${s}.client` : `${n}.client`;
    console.log(`Producer Topic: ${l}, Consumer Topic: ${d}`), await Promise.all([
      await this.ensureStreamExists(l, n, "server"),
      await this.ensureStreamExists(d, n, "client")
    ]), console.log(`Hemos creado el consu idor y productor del topic ${n}`), console.log(this.producersConsumers);
  }
  async ensureStreamExists(n, s, l) {
    console.log(`ensureStreamExists iniciado: topic=${n}, baseTopic=${s}, type=${l}`);
    let d = `${_w}.${n}`;
    try {
      console.log(`1. Verificando existencia del stream: ${d}`), d = d.replace(/\./g, "_"), console.log(`2. Verificando existencia del stream: ${d}`);
      const v = await this.jsm?.streams.info(d);
      if (v) {
        console.log(`Stream ya existe: ${JSON.stringify(v, null, 2)}`);
        const p = this.producersConsumers.get(s) || { producer: null, consumer: null, producerSubject: "", consumerSubject: "" };
        l === "server" && !p.producer && (p.producer = await this.createProducer(d, l), p.producerSubject = d, console.log(`Productor asociado al stream ${d} con subject ${d}`), p.consumer = p.consumer, p.consumerSubject = p.consumerSubject), l === "client" && !p.consumer && (p.consumer = await this.createConsumer(d, l), p.consumerSubject = d, console.log(`Consumidor asociado al stream ${d} con subject ${d}`), p.producer = p.producer, p.producerSubject = p.producerSubject), console.log(`Asignamos el productor y/o consumidor al topic ${s} -- ${p}`), this.producersConsumers.set(s, p);
        return;
      } else {
        console.log(`Stream no encontrado. Procediendo a crear el stream: ${d}`), await this.createStream(d, s, l), console.log("Stream creado. Procediendo a asociar productor y consumidor.");
        let p, E, _, x;
        l === "server" ? (p = await this.createProducer(d, l), E = null, _ = d, x = "") : l === "client" && (p = null, E = await this.createConsumer(d, l), _ = "", x = d), p && (this.producersConsumers.set(s, { producer: p, consumer: null, producerSubject: d, consumerSubject: "" }), console.log(`Productor creado y asociado al baseTopic ${s}`)), E && (this.producersConsumers.set(s, { producer: null, consumer: E, producerSubject: "", consumerSubject: d }), console.log(`Consumidor creado y asociado al baseTopic ${s}`));
      }
    } catch (v) {
      this.isErrorWithMessage(v) ? (console.warn(`Error al verificar o crear el stream ${d} para el topic ${n}:`, v.message), v.message.includes("stream not found") ? (console.log(`El stream ${d} no fue encontrado, creando uno nuevo.`), await this.createStream(d, s, l)) : console.error("Error desconocido al verificar o crear el stream:", v.message)) : console.error("Error desconocido al verificar o crear el stream:", v);
    }
  }
  async createProducer(n, s) {
    return {
      publish: async (l, d) => {
        console.log(`Publicando mensaje al subject: ${l}`);
        const v = ZE(l, d);
        await this.js?.publish(l, ym(v));
      }
    };
  }
  async getProducer(n) {
    return console.log(`Obteniendo productor para el stream ${n}`), {
      publish: async (s, l) => {
        console.log(`Publicando mensaje al subject: ${s}`);
        const d = ZE(s, l);
        await this.js?.publish(s, ym(d));
      }
    };
  }
  async createConsumer(n, s) {
    console.log(`Creando o obteniendo consumidor para el stream ${n} con tipo ${s}`);
    try {
      const l = await this.js?.consumers.get(n, `${n}-consumer`);
      return console.log(`Consumidor encontrado para el stream ${n}`), l;
    } catch (l) {
      if (l instanceof Error)
        if (l.message.includes("consumer not found") || l.code === "404") {
          console.log(`El consumidor no existe para el stream ${n}, creando uno nuevo...`);
          try {
            return await this.jsm?.streams.get(n) ? (await this.jsm?.consumers.add(n, {
              durable_name: `${n}-consumer`,
              ack_policy: Pr.Explicit,
              deliver_subject: `${n}-deliver`,
              // Necesario para push
              filter_subject: n
            }), console.log(`Consumidor creado exitosamente para el stream ${n}`), await this.js?.consumers.get(n, `${n}-consumer`)) : (console.error(`El stream ${n} no existe. Asegrate de crearlo antes.`), null);
          } catch (d) {
            throw console.error(`Error al crear el consumidor para el stream ${n}:`, d), d;
          }
        } else
          throw console.error(`Error desconocido al obtener el consumidor para el stream ${n}:`, l), l;
      else
        throw console.error("Error no controlado de tipo desconocido:", l), new Error("Error inesperado");
    }
  }
  async getConsumer(n, s) {
    try {
      const v = (await D1({
        servers: ew,
        // Usamos la URL de NATS desde las variables de entorno
        user: M1,
        // Usamos el usuario de NATS desde las variables de entorno
        pass: j1
        // Usamos la contrasea de NATS desde las variables de entorno
      })).jetstream();
      return console.log(`Obteniendo consumidor para el stream ${n}, consumidor: ${s}`), await v.consumers.get(n, s);
    } catch (l) {
      throw console.error("Error al obtener el consumidor:", l), l;
    }
  }
  // Funcin de guardia para verificar si el error tiene la propiedad 'message'
  isErrorWithMessage(n) {
    return typeof n == "object" && n !== null && "message" in n;
  }
  // Crear un stream si no existe
  async createStream(n, s, l) {
    console.log(`createStream iniciado: streamName=${n}, topic=${s}, type=${l}`);
    try {
      let d = `${n}`;
      d = d.replace(/\./g, "_");
      const v = {
        name: d,
        subjects: [d],
        retention: i0.Limits,
        max_msgs_per_subject: 1e3
        //max_age: 60 * 60 * 1000,
      };
      console.log(`Configuracin del stream: ${JSON.stringify(v, null, 2)}`), await this.jsm?.streams.add(v), console.log(`Stream creado con xito: ${d}`), await this.createProducerConsumer(d, s, l);
    } catch (d) {
      console.error(`Error al crear el stream ${n} para el topic ${s}:`, d);
    }
  }
  // Crear un productor y un consumidor para un stream
  async createProducerConsumer(n, s, l) {
    console.log(`**** createProducerConsumer iniciado: streamName=${n}, topic=${s}, type=${l}`);
    const d = n;
    console.log(`Subject generado: ${d}`);
    try {
      const v = this.producersConsumers.get(s) || { producer: null, consumer: null, producerSubject: "", consumerSubject: "" };
      if (l === "server") {
        const p = new TextEncoder();
        console.log(`Creando productor para el subject: ${d}`);
        const E = ZE(d, "Mensaje de prueba");
        await this.js?.publish(d, ym(E)), console.log(`Productor creado para el subject: ${d}`), this.producersConsumers.set(s, {
          producer: d,
          consumer: v.consumer,
          producerSubject: n,
          consumerSubject: v.consumerSubject
        }), console.log(`Productor almacenado para el topic: ${s}`);
      } else {
        console.log(`Creando consumidor para el subject: ${d}`), await this.jsm?.consumers.add(n, {
          durable_name: `${d}-consumer`,
          ack_policy: Pr.Explicit,
          filter_subject: d
        }), console.log(`Consumidor registrado en JetStreamManager para el subject: ${d}`);
        const p = await this.js?.consumers.get(n, `${d}-consumer`);
        p && (this.producersConsumers.set(s, {
          producer: v.producer,
          consumer: p,
          producerSubject: v.producerSubject,
          consumerSubject: n
        }), console.log(`Consumidor almacenado para el topic: ${s}`));
      }
    } catch (v) {
      console.error(`Error al crear productor o consumidor para el stream ${n} y topic ${s}:`, v);
    }
  }
  createNatsMessageFromMessage(n, s) {
    const l = {
      messageId: n.messageId,
      messageType: n.messageType,
      sendDate: n.sendDate,
      serverDate: n.serverDate,
      nickname: n.nickname,
      token: n.token,
      roomId: n.roomId,
      roomName: n.roomName,
      metadata: JSON.stringify(n.metadata)
      // Convertir Metadata a string JSON
    };
    new TextEncoder();
    const d = btoa(n.messageText);
    return {
      subject: s,
      // El topic es el nombre del subject
      data: d,
      // El contenido del mensaje como Uint8Array
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      // Fecha y hora actuales como timestamp
      headers: l
      // Los headers definidos
    };
  }
  async publishMessage(n, s) {
    try {
      console.log(`Entrando en publishMessage para el topic: ${s}`);
      const l = this.getProducerForTopic(s);
      if (!l)
        throw new Error(`No se encontr un productor para el topic: ${s}`);
      const d = this.getProducerSubjectForTopic(s);
      if (console.log("Productor encontrado:", l), !this._isConnected)
        throw new Error("JetStream no est conectado");
      try {
        console.log("Streams en await this.js?.views:", await this.js?.views), console.log("Streams en await this.js?.streams:", await this.js?.streams);
      } catch (N) {
        console.error("Error al obtener informacin de los streams de JetStream:", N);
      }
      const v = this.createNatsMessageFromMessage(n, d);
      console.log(`Mensaje transformado a NatsMessage: ${JSON.stringify(v)}`);
      const p = ym(v);
      console.log(`Mensaje transformado y serializado: ${p}`);
      const E = 3;
      let _ = 0, x = null;
      for (; _ < E; )
        try {
          if (x = await this.js?.publish(d, p), x?.seq) {
            console.log(`Mensaje publicado con xito en ${s}. Seq: ${x.seq}`);
            return;
          } else
            throw new Error("No se recibi un ack de la publicacin.");
        } catch (N) {
          if (_++, _ >= E) {
            console.error(`Error al publicar el mensaje en ${s} despus de ${E} intentos`, N);
            break;
          } else
            console.log(`Reintentando publicacin en ${s}... Intento ${_}`);
        }
    } catch (l) {
      console.error(`Error al publicar el mensaje en ${s}:`, l);
    }
  }
  // Enviar un mensaje de peticin inicial de lsitado de usaurios 
  createNatsMessageFromRequestListUsers(n, s) {
    console.log("createNatsMessageFromRequestListUsers:", n);
    const l = {
      roomId: n.roomId,
      tokenSesion: n.tokenSesion,
      nickname: n.nickname,
      request: n.request,
      operation: n.operation,
      X_GoChat: n.X_GoChat
    };
    new TextEncoder();
    const d = {
      subject: s,
      // El subject ser el topic proporcionado
      data: btoa(n.message),
      // Si necesitas incluir datos adicionales, puedes ajustarlo aqu Buffer.from(  request.message  ) 
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      // Fecha y hora actual como timestamp
      headers: l
      // Los headers generados a partir del request
    };
    return console.log("createNatsMessageFromRequestListUsers::natsMessage:", d), d;
  }
  async publisRequestListUsershMessage(n, s) {
    try {
      console.log(`publisRequestListUsershMessage: Obtener el productor asociado al topic-stream: ${s}`);
      const l = this.getProducerForTopic(s), d = this.getProducerSubjectForTopic(s);
      if (console.log(l), !l)
        throw new Error(`No se encontr un productor para el topic: ${s}`);
      const v = this.createNatsMessageFromRequestListUsers(n, s), p = ym(v);
      console.log(`Mensaje transformado y serializado: ${p}`);
      const E = await this.js?.publish(d, p);
      console.log(`Mensaje publicado con xito en ${d}. Seq: ${E?.seq}`);
    } catch (l) {
      console.error(`Error al publicar el mensaje en el subject del topic : ${s}:`, l);
    }
  }
  async assignCallback(n, s, l, d = !1) {
    console.log(`Entrando en assignCallback con el tema: "${n}"`);
    try {
      console.log(`Verificando si el consumidor para el tema "${n}" existe...`);
      const v = this.getConsumerForTopic(n)?.consumer;
      if (!v)
        throw console.error(`No se encontr un consumidor para el tema: "${n}"`), new Error(`No se encontr un consumidor para el tema: ${n}`);
      console.log(`Consumidor encontrado para el tema: "${n}"`);
      const p = this.getConsumerSubjectForTopic(n);
      console.log("Consumer desde el contexto:", v), await v.consume({
        callback: (E) => {
          try {
            console.log("m:", E), console.log("Sequence:", E.seq), console.log("Reply:", E.reply), console.log("Subject:", E.subject);
            const _ = new TextDecoder().decode(E.data), x = WU(_);
            console.log("Mensaje deserializado con xito:", x), console.log("Data:", E.data), console.log("Headers:", E.headers);
            const N = {
              seq: E.seq,
              subject: E.subject,
              data: E.data,
              decodedData: x,
              // Aqu guardamos los datos decodificados
              headers: E.headers
            };
            console.log("Full message:", N), s(null, x, l), E.ack();
          } catch (_) {
            console.error("Error al procesar el mensaje:", _);
          }
        }
      }), console.log(`Callback asignado correctamente para el tema: "${n}"`);
    } catch (v) {
      throw console.error(`Error al asignar callback para el tema "${n}":`, v), v instanceof Error ? v : new Error(String(v));
    }
  }
}
const tw = "http://localhost:8081", GU = async (o) => {
  console.log("login _ API URL:", tw);
  try {
    const s = (await Ur.post(
      `${tw}/login`,
      JSON.stringify({ nickname: o }),
      {
        headers: {
          "Content-Type": "application/json",
          x_gochat: tw
        }
      }
    )).data;
    return {
      status: s.status || "nok",
      message: s.message || "Error desconocido",
      token: s.token || "",
      nickname: s.nickname || o,
      roomid: s.roomid || "",
      roomname: s.roomname || ""
    };
  } catch (n) {
    return console.warn("Error during login:", n), n.code === "ERR_NETWORK" ? {
      status: "nok",
      message: "El servidor GoChat no est disponible. Disculpe las molestias.",
      token: "",
      nickname: o,
      roomid: "",
      roomname: ""
    } : {
      status: "nok",
      message: "Error durante el login. Intntelo de nuevo ms tarde.",
      token: "",
      nickname: o,
      roomid: "",
      roomname: ""
    };
  }
}, JU = async (o, n, s, l, d, v, p) => {
  const E = {
    ackStatus: !0,
    // Estado de confirmacin
    priority: 1,
    // Prioridad del mensaje
    originalLang: "es"
    // Idioma original
  }, _ = new ST(
    s,
    // nombre de usuario
    p,
    // el mensaje que deseas enviar
    (/* @__PURE__ */ new Date()).toISOString(),
    // fecha de envo (sendDate)
    d,
    // ID de la sala
    l,
    // token de sesin
    v,
    // nombre de la sala
    E,
    // metadata (puede ser ms detallada segn lo necesites)
    ET.TEXT
    // messageType (tipo de mensaje)
  );
  try {
    return console.log(`sendMessage: Enviando mensaje al topic ${o} con el contenido: ${p}`), await n.publishMessage(_, o), console.log("Mensaje enviado correctamente a travs de NATS."), JSON.stringify({
      status: "success",
      message: "El mensaje fue enviado correctamente."
    });
  } catch (x) {
    return console.warn("Error al enviar el mensaje a NATS:", x), JSON.stringify({
      status: "error",
      message: "El servidor est temporalmente fuera de servicio. Por favor, intenta nuevamente en un instante."
    });
  }
}, QU = (o) => (n, s, l) => {
  if (n) {
    console.error("Error recibido en el callback:", n);
    return;
  }
  try {
    console.log("Mensaje recibido en el wrapper:", s), KU(o)(s);
  } catch (d) {
    console.error("Error al procesar el mensaje en el wrapper:", d);
  }
}, KU = (o) => (n) => {
  try {
    console.log("Procesando mensaje:", n);
    const s = n.headers?.nickname, l = n.subject ?? "default";
    let d = "";
    n.data && (n.data instanceof Uint8Array ? d = new TextDecoder().decode(n.data) : d = n.data.toString()), console.log("Detalles del mensaje recibido:"), console.log("  Subject (tema):", l), console.log("  Nickname (remitente):", s), console.log("  Message (contenido):", d), typeof s == "string" ? o((v) => {
      const p = new Map(v);
      return p.set(s, { nickname: s, message: d }), p;
    }) : console.error("El campo 'nickname' no es vlido:", s);
  } catch (s) {
    console.error("Error al procesar el mensaje:", s);
  }
}, XU = (o) => (n, s, l) => {
  if (n) {
    console.error("Error recibido en el callback de usuarios vivos:", n);
    return;
  }
  try {
    console.log("Mensaje recibido en el wrapper de usuarios vivos:", s), ZU(o)(s);
  } catch (d) {
    console.error("Error al procesar el mensaje en el wrapper de usuarios vivos:", d);
  }
}, ZU = (o) => (n) => {
  console.log("********** Inicio de handleNatsGetAliveUsers **********"), console.log("Mensaje recibido en handleNatsGetAliveUsers:", n);
  try {
    if (!n) {
      console.warn("Mensaje recibido es nulo o indefinido.");
      return;
    }
    console.log("Propiedades del mensaje recibido:", Object.keys(n)), console.log("Headers del mensaje:", n.headers), console.log("Datos crudos del mensaje:", n.data);
    const s = n.headers?.AliveUsers;
    if (typeof s == "string")
      try {
        const l = JSON.parse(s);
        console.log("Lista de usuarios vivos deserializada:", l);
        const d = l.map((v) => v?.nickname).filter(Boolean);
        o(d), console.log("Estado actualizado con los usuarios vivos:", d);
      } catch (l) {
        console.error("Error al intentar parsear el JSON de AliveUsers:", l);
      }
    else
      console.warn("El campo 'AliveUsers' no contiene un JSON vlido.");
  } catch (s) {
    console.error("Error procesando el mensaje de usuarios vivos:", s);
  }
  console.log("********** Fin de handleNatsGetAliveUsers **********");
};
async function eF(o, n, s, l, d) {
  const v = u0, p = `${_w}_${u0}_server`, E = `${_w}_${l}_client`;
  try {
    const _ = {
      roomId: n,
      tokenSesion: s,
      nickname: l,
      request: E,
      message: "Solicitud de usuarios activos",
      operation: "listUsers",
      topic: p,
      X_GoChat: d
    };
    return await o.publisRequestListUsershMessage(_, v), "ok";
  } catch (_) {
    return console.error("Error al enviar la solicitud de lista de usuarios:", _), `Error: ${_ instanceof Error ? _.message : String(_)}`;
  }
}
const HT = se.createContext(void 0), tF = ({ children: o }) => {
  const [n, s] = se.useState(""), [l, d] = se.useState(""), [v, p] = se.useState(""), [E, _] = se.useState(""), [x, N] = se.useState(null), O = zm();
  se.useEffect(() => {
    const z = localStorage.getItem("token");
    z && (s(z), d(localStorage.getItem("nickName") || ""), p(localStorage.getItem("roomId") || ""), _(localStorage.getItem("roomName") || ""));
  }, []), se.useEffect(() => {
    console.log("Redirigiendo por error", x), x && (console.log("Redirigiendo por error", x), O(`/?errorMessage=${encodeURIComponent(x)}`));
  }, [n, x, O]);
  const P = se.useMemo(() => ({
    token: n,
    nickName: l,
    roomId: v,
    roomName: E,
    setToken: s,
    setNickName: d,
    setRoomId: p,
    setRoomName: _,
    error: x,
    setError: N
    // Incluir la funcin setError
  }), [n, l, v, E, x]);
  return console.log("AuthContext State:", { token: n, nickName: l, roomId: v, roomName: E, error: x }), /* @__PURE__ */ me.jsx(HT.Provider, { value: P, children: o });
}, VT = () => {
  const o = se.useContext(HT);
  if (console.log("useAuth State context:", { context: o }), !o)
    throw new Error("useAuth must be used within an AuthProvider");
  return o;
}, nF = () => {
  const [o, n] = se.useState(""), [s, l] = se.useState(null), [d, v] = se.useState(!1), [p, E] = se.useState(!1), _ = zm(), { setNickName: x, setToken: N, setRoomId: O, setRoomName: P } = VT(), z = zu();
  se.useEffect(() => {
    const ve = new URLSearchParams(z.search).get("errorMessage");
    ve ? (l(ve), v(!0)) : (v(!1), l(null));
  }, [z]), se.useEffect(() => {
    z.state?.errorMessage && (l(z.state.errorMessage), v(!0));
  }, [z]);
  const B = async () => {
    console.log("Intentando iniciar sesin..."), v(!1), n("");
    try {
      const ae = await GU(o);
      if (console.log("Login --> response :", ae), ae.status === "nickname_taken") {
        l("El nickname ya est en uso. Intenta con otro."), v(!0), console.log("Mostrar error: Nickname ya en uso");
        return;
      }
      if (ae.status === "nok") {
        l(ae.message || "Error desconocido al iniciar sesin."), v(!0), console.log("Mostrar error: Error desconocido");
        return;
      }
      ae.status === "ok" && (x(o), N(ae.token), O(ae.roomid), P(ae.roomname), _("/chat"));
    } catch {
      l("Hubo un error al intentar iniciar sesin. Intenta de nuevo."), v(!0), console.log("Mostrar error: Error al iniciar sesin");
    }
  }, ie = () => v(!1), K = () => E(!0), be = () => E(!1);
  return /* @__PURE__ */ me.jsxs("div", { className: "login-container", children: [
    /* @__PURE__ */ me.jsxs("div", { className: "left-column", children: [
      /* @__PURE__ */ me.jsx("div", { className: "logo", children: "ChatSphere" }),
      /* @__PURE__ */ me.jsx("div", { className: "subtitle", children: "GoChat ZeroMQ" }),
      /* @__PURE__ */ me.jsxs("div", { className: "footer", children: [
        /* @__PURE__ */ me.jsx("p", { children: " 2024 SmartIAService's" }),
        /* @__PURE__ */ me.jsx("p", { children: (/* @__PURE__ */ new Date()).toLocaleDateString() })
      ] })
    ] }),
    /* @__PURE__ */ me.jsxs("div", { className: "right-column", children: [
      /* @__PURE__ */ me.jsxs("div", { className: "login-box", children: [
        /* @__PURE__ */ me.jsx("h2", { children: "Iniciar sesin" }),
        /* @__PURE__ */ me.jsx(
          "input",
          {
            type: "text",
            placeholder: "Introduce tu nickname",
            value: o,
            onChange: (ae) => n(ae.target.value),
            className: "nickname-input",
            disabled: d
          }
        ),
        /* @__PURE__ */ me.jsx("button", { onClick: B, disabled: d, children: "Iniciar sesin" }),
        "  "
      ] }),
      d && /* @__PURE__ */ me.jsxs("div", { className: "message-window", children: [
        /* @__PURE__ */ me.jsxs("div", { className: "header", children: [
          /* @__PURE__ */ me.jsx("span", { className: "title", children: "Error" }),
          /* @__PURE__ */ me.jsxs("div", { className: "controls", children: [
            p ? /* @__PURE__ */ me.jsx("button", { onClick: be, title: "Maximizar", children: "" }) : /* @__PURE__ */ me.jsx("button", { onClick: K, title: "Minimizar", children: "_" }),
            /* @__PURE__ */ me.jsx("button", { onClick: ie, title: "Cerrar", children: "X" })
          ] })
        ] }),
        !p && /* @__PURE__ */ me.jsxs("div", { className: "content", children: [
          /* @__PURE__ */ me.jsx("p", { children: s }),
          /* @__PURE__ */ me.jsx("button", { className: "ok-button", onClick: ie, children: "Ok" })
        ] })
      ] })
    ] })
  ] });
};
class rF {
  _roomid = "00000000-0000-0000-0000-000000000000";
  nombre;
  usuarios;
  messages = [];
  lastIdMessage = "00000000-0000-0000-0000-000000000000";
  constructor(n, s) {
    this.roomId = n, this.nombre = s, this.usuarios = [];
  }
  // Getter y Setter para idRoom
  get roomId() {
    return this._roomid;
  }
  set roomId(n) {
    if (!e0(n))
      throw new Error("El ID de la sala no es un UUID vlido");
    this._roomid = n;
  }
  // Getter y Setter para nombre
  get roomName() {
    return this.nombre;
  }
  set roomName(n) {
    this.nombre = n;
  }
  // Getter y Setter para usuarios
  get userList() {
    return this.usuarios;
  }
  set userList(n) {
    this.usuarios = n;
  }
  // Getter y Setter para messages
  get messageList() {
    return this.messages;
  }
  set messageList(n) {
    this.messages = n;
  }
  // Getter y Setter para lastIdMessage
  get lastIDMessageId() {
    return this.lastIdMessage;
  }
  set lastIDMessageId(n) {
    this.lastIdMessage = n;
  }
  // Mtodo para aadir un usuario a la sala
  addUser(n) {
    this.usuarios.includes(n) ? console.log("El usuario ya est en la sala") : this.usuarios.push(n);
  }
  // Mtodo para eliminar un usuario de la sala
  removeUser(n) {
    const s = this.usuarios.indexOf(n);
    s > -1 ? this.usuarios.splice(s, 1) : console.log("El usuario no est en la sala");
  }
  // Nueva funcin para procesar el JSON y aadir usuarios
  addUsersFromJson(n) {
    try {
      const s = JSON.parse(n);
      if (s.roomId !== this.roomId) {
        console.log("La sala en el JSON no coincide con la sala de la instancia.");
        return;
      }
      s.data.forEach((l) => {
        this.addUser(l.nickname);
      }), console.log(`${s.data.length} usuarios aadidos a la sala.`);
    } catch (s) {
      console.warn("Error al procesar el JSON:", s);
    }
  }
  // Mtodo para actualizar los mensajes de la sala con los datos de la respuesta
  updateMessages(n) {
    if (n.length > 0) {
      n.forEach((l) => {
        const d = new ST(
          l.nickname,
          // nickname extrado
          l.messagetext,
          // messageText extrado
          (/* @__PURE__ */ new Date()).toISOString(),
          // Asignamos la fecha actual como timestamp
          l.messageid,
          // id del mensaje
          this.roomId
          // roomId correspondiente
        );
        this.messages.push(d);
      });
      const s = n[n.length - 1];
      this.lastIDMessageId = s.messageid;
    }
  }
  // Mtodo para obtener el ltimo mensaje
  getLastMessage() {
    return this.lastIdMessage ? this.messages.find((n) => n.idMessage === this.lastIdMessage) : null;
  }
  // Mtodo para obtener todos los usuarios de la sala
  getUsers() {
    return this.usuarios;
  }
}
class wm extends Error {
}
wm.prototype.name = "InvalidTokenError";
function iF(o) {
  return decodeURIComponent(atob(o).replace(/(.)/g, (n, s) => {
    let l = s.charCodeAt(0).toString(16).toUpperCase();
    return l.length < 2 && (l = "0" + l), "%" + l;
  }));
}
function aF(o) {
  let n = o.replace(/-/g, "+").replace(/_/g, "/");
  switch (n.length % 4) {
    case 0:
      break;
    case 2:
      n += "==";
      break;
    case 3:
      n += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return iF(n);
  } catch {
    return atob(n);
  }
}
function L1(o, n) {
  if (typeof o != "string")
    throw new wm("Invalid token specified: must be a string");
  n || (n = {});
  const s = n.header === !0 ? 0 : 1, l = o.split(".")[s];
  if (typeof l != "string")
    throw new wm(`Invalid token specified: missing part #${s + 1}`);
  let d;
  try {
    d = aF(l);
  } catch (v) {
    throw new wm(`Invalid token specified: invalid base64 for part #${s + 1} (${v.message})`);
  }
  try {
    return JSON.parse(d);
  } catch (v) {
    throw new wm(`Invalid token specified: invalid json for part #${s + 1} (${v.message})`);
  }
}
class sF {
  nickname;
  status;
  _token = l1;
  _roomId = "00000000-0000-0000-0000-000000000000";
  _roomName = "Sala Principal";
  constructor(n, s, l, d, v) {
    this.nickname = n, this.status = s, this.roomId = l, this.roomName = d, console.log(`Creando el objeto user: nick: ${n}, status: ${s}, roomid: ${l}, roomname: ${d}, token: ${v}`), this.token = v || l1;
  }
  // Getter para _token
  get token() {
    return this._token;
  }
  // Setter para _token con validacin
  set token(n) {
    if (this.isValidToken(n))
      this._token = n;
    else
      throw new Error("El token no es vlido");
  }
  // Mtodo para validar si el token es vlido
  isValidToken(n) {
    try {
      const s = L1(n);
      return s != null && this.tokenIsValid(s.exp);
    } catch (s) {
      return console.warn("Error al validar el token:", s), !1;
    }
  }
  // Verifica si el token ha expirado
  tokenIsValid(n) {
    if (n === void 0)
      return !1;
    const s = Math.floor(Date.now() / 1e3), l = n + 60 * 60 * 24;
    return s < l;
  }
  // Mtodo para obtener el ID del usuario decodificado desde el token
  getUserIdFromToken() {
    try {
      const n = L1(this._token);
      return console.log("decode token", n), n ? n.userid : null;
    } catch (n) {
      return console.warn("Error al obtener el ID del token:", n), null;
    }
  }
  // Getter y Setter para roomId
  get roomName() {
    return this._roomName;
  }
  set roomName(n) {
    this._roomName = n;
  }
  // Getter y Setter para roomId
  get roomId() {
    return this._roomId;
  }
  set roomId(n) {
    if (!e0(n))
      throw new Error("El ID de la sala no es un UUID vlido");
    this._roomId = n;
  }
}
const oF = ({
  message: o,
  showError: n,
  isDarkMode: s,
  closeErrorMessage: l,
  minimizeErrorMessage: d,
  restoreErrorMessage: v,
  minimized: p,
  iconType: E
  // Asegrate de que iconType est definido
}) => (console.log("Dentro de WErrorMessage con mensaje:", o), console.log("Dentro de WErrorMessage con showError:", n), console.log("Dentro de WErrorMessage con isDarkMode:", s), console.log("Dentro de WErrorMessage con minimized:", p), n && /* @__PURE__ */ me.jsxs(
  "div",
  {
    className: `w-message-window ${s ? "dark" : "light"} ${E === "error" ? "error" : "info"}`,
    children: [
      /* @__PURE__ */ me.jsxs("div", { className: `w-header ${s ? "dark" : "light"}`, children: [
        /* @__PURE__ */ me.jsx("span", { className: `w-icon ${E}`, children: E === "error" ? /* @__PURE__ */ me.jsx("i", { className: "fas fa-times-circle" }) : /* @__PURE__ */ me.jsx("i", { className: "fas fa-exclamation-triangle" }) }),
        /* @__PURE__ */ me.jsx("span", { className: "w-title", children: E === "error" ? "Error" : "Informacin" }),
        /* @__PURE__ */ me.jsxs("div", { className: "w-controls", children: [
          /* @__PURE__ */ me.jsx(
            "button",
            {
              onClick: p ? v : d,
              title: p ? "Maximizar" : "Minimizar",
              children: p ? "" : "_"
            }
          ),
          /* @__PURE__ */ me.jsx("button", { onClick: l, title: "Cerrar", children: "X" })
        ] })
      ] }),
      !p && /* @__PURE__ */ me.jsxs("div", { className: "w-content", children: [
        /* @__PURE__ */ me.jsx("p", { children: o }),
        /* @__PURE__ */ me.jsx(
          "button",
          {
            className: `w-ok-button ${s ? "dark" : "light"}`,
            onClick: l,
            children: "Ok"
          }
        )
      ] })
    ]
  }
)), qT = (o) => {
  console.log(`Clic en el banner de: ${o}`);
}, YT = (o) => {
  console.log(`Mouse ha pasado sobre el banner de: ${o}`);
}, lF = ({ imageUrl: o, titleSlogan: n, subtitleSlogan: s }) => {
  const [l, d] = se.useState(!1);
  return /* @__PURE__ */ me.jsx(
    "div",
    {
      className: "chat-banner-programming",
      onClick: () => qT("Programacin en la Nube"),
      onMouseEnter: () => {
        YT("Programacin en la Nube"), d(!0);
      },
      onMouseLeave: () => d(!1),
      children: /* @__PURE__ */ me.jsxs("div", { className: "banner-content", children: [
        /* @__PURE__ */ me.jsx("img", { src: o, alt: "Banner de Programacin en la Nube", className: "banner-image" }),
        /* @__PURE__ */ me.jsxs("div", { className: "banner-slogan", children: [
          /* @__PURE__ */ me.jsx("h2", { children: n }),
          /* @__PURE__ */ me.jsx("p", { children: s })
        ] }),
        l && /* @__PURE__ */ me.jsx("div", { className: "chat-icon-banner", children: /* @__PURE__ */ me.jsxs("div", { className: "chat-tech-icons", children: [
          /* @__PURE__ */ me.jsx("img", { src: "https://miro.medium.com/v2/resize:fit:740/1*rxDdNJHiz1R38J_JEz23Zw.jpeg", alt: "Go", className: "chat-icon" }),
          /* @__PURE__ */ me.jsx("img", { src: "https://upload.wikimedia.org/wikipedia/commons/d/d9/Node.js_logo.svg", alt: "Node.js", className: "chat-icon" }),
          /* @__PURE__ */ me.jsx("img", { src: "https://www.typescriptlang.org/images/branding/two-longform.svg", alt: "TypeScript", className: "chat-icon" }),
          /* @__PURE__ */ me.jsx("img", { src: "https://upload.wikimedia.org/wikipedia/commons/4/47/React.svg", alt: "React", className: "chat-icon" }),
          /* @__PURE__ */ me.jsx("img", { src: "/images/concepts.png", alt: "concepts", className: "chat-icon" })
        ] }) })
      ] })
    }
  );
}, uF = ({ imageUrl: o, titleSlogan: n, subtitleSlogan: s }) => {
  const [l, d] = se.useState(!1);
  return /* @__PURE__ */ me.jsx(
    "div",
    {
      className: "banner-container",
      onClick: () => qT("Cloud Computing"),
      onMouseEnter: () => {
        YT("Cloud Computing"), d(!0);
      },
      onMouseLeave: () => d(!1),
      children: /* @__PURE__ */ me.jsxs("div", { className: "banner-content", children: [
        /* @__PURE__ */ me.jsx("div", { className: "banner-image-container", children: /* @__PURE__ */ me.jsx("img", { src: o, alt: "Banner de Cloud Computing", className: "banner-image" }) }),
        /* @__PURE__ */ me.jsxs("div", { className: "banner-slogan", children: [
          /* @__PURE__ */ me.jsx("h2", { children: n }),
          /* @__PURE__ */ me.jsx("p", { children: s })
        ] }),
        l && /* @__PURE__ */ me.jsx("div", { className: "banner-summary", children: /* @__PURE__ */ me.jsxs("div", { className: "tech-icons", children: [
          /* @__PURE__ */ me.jsx("img", { src: "https://es.m.wikipedia.org/wiki/Archivo:Amazon_Web_Services_Logo.svg", alt: "AWS", className: "icon" }),
          /* @__PURE__ */ me.jsx("img", { src: "https://logodownload.org/wp-content/uploads/2021/06/google-cloud-logo-0.png", alt: "Google Cloud", className: "icon" }),
          /* @__PURE__ */ me.jsx("img", { src: "https://upload.wikimedia.org/wikipedia/commons/f/fa/Microsoft_Azure.svg", alt: "Azure", className: "icon" })
        ] }) }),
        /* @__PURE__ */ me.jsx("div", { className: "banner-footer", children: /* @__PURE__ */ me.jsx("small", { children: " SmartIAService's - Jos Javier Gutirrez Gil" }) })
      ] })
    }
  );
}, cF = [
  // Espaol
  "maldicin",
  "vulgaridad",
  "insulto",
  "tonto",
  "grosera",
  "estpido",
  "idiota",
  "imbcil",
  "mierda",
  "puta",
  "puto",
  "cabron",
  "gilipollas",
  "coo",
  "zorra",
  "pendejo",
  "culero",
  // Ingls
  "curse",
  "swear",
  "insult",
  "stupid",
  "idiot",
  "moron",
  "dumb",
  "fuck",
  "shit",
  "bitch",
  "bastard",
  "whore",
  "slut",
  "asshole",
  // Francs
  "maldiction",
  "vulgarit",
  "insulte",
  "stupide",
  "idiot",
  "imbcile",
  "con",
  "merde",
  "putain",
  "salope",
  "connard",
  "bordel",
  "pute",
  // Italiano
  "maledizione",
  "volgarit",
  "insulto",
  "stupido",
  "idiota",
  "cretino",
  "stronzo",
  "cazzo",
  "merda",
  "puttana",
  "bastardo",
  "troia",
  "testa di cazzo"
];
let P1 = !1;
async function fF() {
  const o = {
    userAgent: navigator.userAgent,
    // Cadena completa del navegador
    language: navigator.language,
    // Idioma del navegador
    vendor: navigator.vendor,
    // Proveedor del navegador
    urlActual: window.location.href
    // URL actual del sitio
  }, n = async () => {
    if (P1)
      return console.log("La solicitud ya fue bloqueada por un bloqueador de anuncios."), { ip: "Desconocida", pais: "Desconocido" };
    try {
      const v = await fetch("http://ip-api.com/json");
      if (!v.ok)
        throw new Error("No se pudo obtener la respuesta de la API");
      const p = await v.json(), E = p.query || "Desconocida", _ = p.country || "Desconocido";
      return { ip: E, pais: _ };
    } catch (v) {
      return v instanceof Error && v.message.includes("ERR_BLOCKED_BY_ADBLOCKER") ? (console.log("Solicitud bloqueada por un bloqueador de anuncios."), P1 = !0) : console.log("Error al obtener la ubicacin:", v.message || v), { ip: "Desconocida", pais: "Desconocido" };
    }
  }, { ip: s, pais: l } = await n();
  return JSON.stringify({
    navegador: o,
    ip: s,
    pais: l
  }, null, 2);
}
const dF = () => {
  const [o, n] = se.useState(""), s = () => {
    n((/* @__PURE__ */ new Date()).toLocaleTimeString());
  };
  return se.useEffect(() => {
    s();
    const l = setInterval(s, 1e3);
    return () => clearInterval(l);
  }, []), /* @__PURE__ */ me.jsxs("p", { children: [
    /* @__PURE__ */ me.jsx("strong", { children: "Fecha:" }),
    " ",
    o
  ] });
}, hF = () => {
  zm();
  const [o, n] = se.useState(!1), [s, l] = se.useState(/* @__PURE__ */ new Map()), [d, v] = se.useState(""), [p, E] = se.useState([]), [_, x] = se.useState(!1), N = se.useRef(null), O = () => {
    N.current?.scrollIntoView({ behavior: "smooth" });
  }, [P, z] = se.useState([]), [B, ie] = se.useState(!1), K = () => {
    z((We) => {
      const Tt = We.slice(1);
      return ue(Tt[0] || ""), Tt.length === 0 && ke(!1), Tt;
    });
  }, be = () => {
    ie(!0);
  }, ae = () => ie(!1), ve = (We) => {
    console.log("Dentro de showErrorModal con message:", We), z((Tt) => [...Tt, We]), Ze || (ke(!0), ue(We));
  }, [De, Re] = se.useState(!1), lt = () => {
    Re(!De);
  }, { token: Ve, nickName: wt, roomId: Rt, roomName: zt } = VT(), [it, Bt] = se.useState(null), [Ke, Jt] = se.useState(null), [jt, Ht] = se.useState(!1), [Ye, Ce] = se.useState(!1), [Ze, ke] = se.useState(!1), [Y, ue] = se.useState("");
  se.useState(!1), se.useRef(null);
  const [st, dt] = se.useState(!1), [ot, Ot] = se.useState(null), [ct, ht] = se.useState(!1), [Ae, Lt] = se.useState(!1), Un = {
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    '"': "&quot;",
    "'": "&#39;"
  }, dr = (We) => We.replace(/[<>&"']/g, (Tt) => Un[Tt] || Tt), wn = (We) => We.replace(/[^a-zA-Z0-9\s]/g, ""), $n = (We) => cF.some((Tt) => We.toLowerCase().includes(Tt)), Fn = async () => {
    if (!(!d.trim() || !o))
      try {
        if (it && Ke) {
          const We = wn(d.trim()), Tt = dr(We);
          if (!Tt) {
            ve("No puedes enviar un mensaje vaco.");
            return;
          }
          if ($n(Tt)) {
            ve("El mensaje contiene lenguaje prohibido.");
            return;
          }
          if (ot) {
            const hr = await JU(ww, ot, it.nickname, it.token, Ke.roomId, Ke.roomName, d);
          } else
            console.error("No se pudo enviar el mensaje. No existe conexin con Nats");
          v("");
        }
      } catch (We) {
        throw ve("No se pudo enviar el mensaje. Intente de nuevo."), console.error("Error al enviar el mensaje:", We), new Error("El servicio de chat no est disponible. Disculpe las molestias. Por favor, intente ingresar nuevamente ms tarde.");
      }
  }, jn = async () => {
    if (console.log("Dentro de onst connectToNats = async ()"), !jt || !it) {
      console.error("Usuario no autenticado. No se puede conectar a NATS.");
      return;
    }
    try {
      ot ? console.error("No se pudo conectar a NATS. El objeto natsManager ya existe.") : await (async () => {
        if (it.nickname)
          try {
            console.log("Creando NatsManager para el usuario:", it.nickname);
            const Tt = await Hw.create(it.nickname);
            Ot(Tt), console.log("Conexin a NATS establecida para el usuario:", it.nickname), console.log(Tt), Lt(!0), console.log("Consumidores y productores creados correctamente.");
          } catch (Tt) {
            console.error("Error al crear NatsManager o al inicializar consumidores/productores:", Tt), ht(!0);
          }
        else
          console.error("Nickname no disponible o no vlido.");
      })();
    } catch {
      console.error("Error al conectar al servidor de mensajera NATS"), ht(!0);
    }
  }, xr = async () => {
    if (ot && it) {
      console.log("--> Dentro de const pushCallback = async () => { ");
      const We = ww, Tt = u0;
      ot.assignCallback(We, QU(l), !0), console.log(`--> Callback asignado para el consumidor ${We}.client`), ot.assignCallback(Tt, XU(E), !1), console.log(`--> Callback asignado para el consumidor de usuarios vivos: ${Tt}.client`);
    }
  }, wi = async () => {
    try {
      const We = await fF();
      console.log("Usuarios activos:datosCliente:", We), it && ot && eF(ot, it.roomId, it.token, it.nickname, We);
    } catch (We) {
      ve("Error GRAVE al obtener los usuarios activos: " + We), console.error("Error al obtener usuarios activos:", We);
      return;
    }
  }, Fr = (We) => {
    v(We.target.value), console.log("Cambio en el mensaje:", We.target.value), n(We.target.value.trim() !== "");
  }, Kn = (We) => {
    localStorage.removeItem("Room"), localStorage.removeItem("User"), localStorage.removeItem("Messages"), Ht(!1), window.location.href = "/";
  }, Sn = async () => {
    console.log("Dentro de authenticateUser:");
    try {
      if (wt && Rt && zt && Ve) {
        const We = new sF(wt, "Alive", Rt, zt, Ve);
        Bt(We), n(!0), Ht(!0), console.log("Usuario autenticado:", We), console.log("Usuario autenticado: IsAuthenticated:", jt);
      } else
        throw new Error("Datos del usuario no vlidos");
    } catch (We) {
      throw Ht(!1), ve(`Error setIsAuthenticated: ${We}`), console.error(We), We;
    }
  }, Bn = async () => {
    if (console.log(
      `Se llama a initializeRoom. Valores actuales:
userChat: ${JSON.stringify(it)},
natsManager.isConnected: ${ot?.isConnected},
initialized: ${Ye}`
    ), it && ot?.isConnected) {
      const We = new rF(it.roomId, it.roomName);
      Jt(We), console.log("Sala creada:", We);
    }
  }, qn = (We) => {
    We.key === "Enter" && o && Fn();
  };
  return se.useEffect(() => {
    wt && Rt && zt && Ve && !jt ? (console.log("Autenticacin no realizada, llamando a authenticateUser."), Sn()) : console.log("Condiciones de autenticacin no cumplidas o ya autenticado.");
  }, [wt, Rt, zt, Ve, jt]), se.useEffect(() => {
    console.log("Dentro de useEffect: connectToNats()"), console.log("isAuthenticated:", jt), console.log("shouldConnectToNats:", Ae), console.log("userChat (nickname):", it?.nickname), jt && it?.nickname && !Ae ? (console.log("Usuario autenticado y nickname no vaco. Conectando a Nats..."), jn()) : console.log(Ae ? "Conexin Nats ya est establecida" : "No se conecta a Nats, no se cumplen las condiciones.");
  }, [jt, it, Ae]), se.useEffect(() => {
    console.log("Dentro de useEffect: pushCallback."), console.log("isAuthenticated:", jt), console.log("shouldConnectToNats:", Ae), console.log("natsManager.isConnected:", ot?.isConnected), console.log("callbackExecuted:", st), Ae && ot && ot.isConnected && !st ? (console.log("Llamando a pushCallback para la conexin."), xr(), dt(!0), wi()) : console.log("No se  llama a pushCallback porque no se cumplen las condiciones.");
  }, [Ae, st]), se.useEffect(() => {
    console.log("Inicializando la sala..."), Bn();
  }, [Ye]), se.useEffect(() => {
    it && ot?.isConnected && !Ye ? (console.log("Se ejecuta setInitialized para crear el objeto room."), Ye || Ce(!0)) : console.log("No se ejecuta setInitialized porque initialized ya es:", Ye);
  }, [it, ot?.isConnected]), se.useEffect(() => {
    ct && (console.log("Error en la conexin detectado."), ve("Error en la conexin con el servidor. Espere unos instantes y vuelva a logarse."));
  }, [ct]), se.useEffect(() => {
    console.log("Desplazndose al final de los mensajes."), O(), x(!1);
  }, [s, _]), !it || !ot?.isConnected || !Ke ? /* @__PURE__ */ me.jsx("div", { children: "Cargando..." }) : /* @__PURE__ */ me.jsxs("div", { className: "chat-container", children: [
    /* @__PURE__ */ me.jsxs("div", { className: "chat-left-column", children: [
      /* @__PURE__ */ me.jsx("div", { className: "chat-title", children: "Gochat" }),
      /* @__PURE__ */ me.jsx("div", { className: "chat-subtitle", children: "GoChat ZeroMQ//Nats" }),
      /* @__PURE__ */ me.jsx("div", { className: "chat-logo-container", children: /* @__PURE__ */ me.jsx("div", { className: "chat-logo", children: /* @__PURE__ */ me.jsx("img", { src: "/images/logo.webp", alt: "Logo" }) }) }),
      /* @__PURE__ */ me.jsx("div", { className: "chat-banners", children: /* @__PURE__ */ me.jsx("div", { className: "chat-banner-programming", children: /* @__PURE__ */ me.jsx(
        lF,
        {
          titleSlogan: "Desarrollos giles para tus aplicaciones",
          subtitleSlogan: "Escalabilidad y elasticidad eficientes",
          imageUrl: "/images/pattern.png"
        }
      ) }) }),
      /* @__PURE__ */ me.jsxs("div", { className: "footer", children: [
        /* @__PURE__ */ me.jsx("p", { children: " 2024 Jos Javier Gutirrez Gil" }),
        /* @__PURE__ */ me.jsx("p", { className: "email-style", children: " jogugil@gmail.com // jogugi@posgrado.upv.es" })
      ] })
    ] }),
    /* @__PURE__ */ me.jsx("div", { className: `chat-room ${De ? "chat-room-dark" : "chat-room-light"}`, children: /* @__PURE__ */ me.jsxs("div", { className: "chat-content", children: [
      /* @__PURE__ */ me.jsxs("div", { className: "messages-display", children: [
        /* @__PURE__ */ me.jsx("div", { className: "theme-toggle-btn", onClick: lt, children: "Cambiar Tema" }),
        /* @__PURE__ */ me.jsx("h3", { children: "Mensajes" }),
        /* @__PURE__ */ me.jsx("ul", { children: Array.from(s.entries()).map(([We, Tt], hr) => /* @__PURE__ */ me.jsxs("li", { children: [
          /* @__PURE__ */ me.jsx("strong", { children: Tt.nickname }),
          ": ",
          Tt.message
        ] }, We)) }),
        /* @__PURE__ */ me.jsx("div", { ref: N })
      ] }),
      /* @__PURE__ */ me.jsxs("div", { className: "input-section", children: [
        /* @__PURE__ */ me.jsx("div", { className: "user-nickname", children: /* @__PURE__ */ me.jsx("span", { className: "nickname-value", children: it && it.nickname ? it.nickname : "Annimo" }) }),
        /* @__PURE__ */ me.jsx(
          "input",
          {
            type: "text",
            value: d,
            onChange: Fr,
            disabled: !o,
            placeholder: "Escribe tu mensaje...",
            onKeyDown: qn
          }
        ),
        /* @__PURE__ */ me.jsx(
          "button",
          {
            className: "send-btn",
            onClick: Fn,
            disabled: !o,
            children: "Enviar"
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ me.jsxs("div", { className: "chat-right-column", children: [
      /* @__PURE__ */ me.jsxs("div", { className: "chat-metricsbox", children: [
        /* @__PURE__ */ me.jsx(dF, {}),
        /* @__PURE__ */ me.jsxs("p", { children: [
          /* @__PURE__ */ me.jsx("strong", { children: "Mensajes enviados:" }),
          " ",
          s.size
        ] }),
        /* @__PURE__ */ me.jsxs("p", { children: [
          /* @__PURE__ */ me.jsx("strong", { children: "Usuarios activos:" }),
          " ",
          p.length
        ] })
      ] }),
      /* @__PURE__ */ me.jsxs("div", { className: "chat-active-users-box", children: [
        /* @__PURE__ */ me.jsx("div", { className: "chat-active-users-header", children: /* @__PURE__ */ me.jsx("h3", { children: "Usuarios Activos" }) }),
        /* @__PURE__ */ me.jsx("ul", { children: p.map((We, Tt) => /* @__PURE__ */ me.jsx("li", { children: We }, Tt)) })
      ] }),
      /* @__PURE__ */ me.jsx("div", { className: "chat-banner-cloud", children: /* @__PURE__ */ me.jsx(
        uF,
        {
          imageUrl: "../../public/images/cloudcomm.png",
          titleSlogan: "Inteligencia Aplicada en la Nube",
          subtitleSlogan: "Soluciones avanzadas en Cloud, Clusters y Serverless para un futuro ms eficiente"
        }
      ) }),
      Ze && /* @__PURE__ */ me.jsx("div", { className: "chat-error-message", children: /* @__PURE__ */ me.jsx(
        oF,
        {
          message: Y || "Ocurri un error desconocido",
          showError: Ze,
          isDarkMode: De,
          closeErrorMessage: K,
          minimizeErrorMessage: be,
          restoreErrorMessage: ae,
          minimized: B,
          iconType: "error"
        }
      ) }),
      /* @__PURE__ */ me.jsx("button", { id: "logoutButton", className: "logout-btn", onClick: Kn, children: "Salir" })
    ] })
  ] });
}, pF = () => /* @__PURE__ */ me.jsx(hL, { children: /* @__PURE__ */ me.jsxs(Ij, { children: [
  /* @__PURE__ */ me.jsx(iw, { path: "/", element: /* @__PURE__ */ me.jsx(nF, {}) }),
  /* @__PURE__ */ me.jsx(iw, { path: "/chat", element: /* @__PURE__ */ me.jsx(hF, {}) })
] }) });
window.onerror = (o, n, s, l, d) => {
  console.error("Error global capturado:", { message: o, source: n, lineno: s, colno: l, error: d });
};
window.onunhandledrejection = (o) => {
  console.error("Promesa no manejada:", o.reason);
};
const mF = qM.createRoot(document.getElementById("root"));
mF.render(
  /* @__PURE__ */ me.jsx(eL, { children: /* @__PURE__ */ me.jsx(tF, { children: /* @__PURE__ */ me.jsx(pF, {}) }) })
);
